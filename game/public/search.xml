<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[進階資料結構 for NCKU-ICPC Week 9]]></title>
    <url>%2Fcode%2Fncku-icpc-2020-week9-dlc%2F</url>
    <content type="text"><![CDATA[Week 9 DLC前言有些內容筆者本來想要放在這週的授課內容中不過一來是筆者的期中快要爆炸，沒有空做簡報另一方面由於授課內容偏難，放在影片中可能會讓影片長度暴增（像是變成三個小時）因此決定另外寫一篇文章來當作補充內容，並且發在自己的部落格 線段樹 Extra持久化老樣子開始前先看個題目 給定一個長度為 $N$ 的序列，並且有 $M$ 條指令，指令內容如下 修改其中一個元素的值 查詢查詢區間 $[l, r]$ 內的最大值 回復到第 k 次修改後的狀態 $N, M \le 10 ^ 5, k \le$ 當前修改次數, $0 \le l, r \lt N$ 1, 2 都還是基本的線段樹，那麼 3 呢 感覺可以每修改一次就開一顆新的線段樹，要回朔就複製回去 所以需要開到 $M$ 棵線段樹，所以要開 $4NM$ 的記憶體……先 MLE 了再看一下時間複雜度：$O(M(N + \log N))$ （先複製一遍 $O(N)$，再做單點修改 $O(\log N)$，最糟糕要執行 $M$ 次）從各種方面來看感覺都不會過 先觀察一下對於每次修改，會修改到的地方只有從根節點到要修改的點的路徑而已也就是說 其他節點沿用舊的資料也沒關係 這邊記得放結構圖 但是用陣列寫就要另外維護節點編號，從實作上來說是幾乎不可能達成的事看來我們需要換個想法 Hmmm，指標？沒錯，就是指標只要紀錄記憶體位置就好，不用把整個 node 都複製過去 所以現在線段樹要改成指標版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; node *l, *r; int value; node ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) &#123;&#125; inline void up ( void )&#123; value = -1; if ( l ) value = max ( value, l -&gt; value ); if ( r ) value = max ( value, r -&gt; value ); &#125;&#125; *seg = nullptr;void build ( int l, int r, node *&amp;o )&#123; o = new node ( 0 ); if ( l == r ) return; int mid = ( l + r ) &gt;&gt; 1; build ( l, mid, o -&gt; l ); build ( mid + 1, r, o -&gt; r ); o -&gt; up();&#125;void update ( int l, int r, int index, int value, node *&amp;o )&#123; if ( l == r ) o -&gt; value = value; else&#123; int mid = ( l + r ) &gt;&gt; 1; if ( index &lt;= mid ) update ( l, mid, index, value, o -&gt; l ); else update ( mid + 1, r, index, value, o -&gt; r ); o -&gt; up(); &#125;&#125;int query ( int l, int r, int nowL, int nowR, node *o )&#123; if ( l &lt;= nowR &amp;&amp; nowR &lt;= r ) return o -&gt; value; int mid = ( nowL + nowR ) &gt;&gt; 1; if ( r &lt;= mid ) return query ( l, r, nowL, mid, o -&gt; l ); if ( mid &lt; l ) return query ( l, r, mid + 1, nowR, o -&gt; r ); return max ( query ( l, r, nowL, mid, o -&gt; l ), query ( l, r, mid + 1, nowR, o -&gt; r ) );&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, l, r, in, type; cin &gt;&gt; n &gt;&gt; m; build ( 1, n, seg ); for ( int i = 1 ; i &lt;= n ; i++ )&#123; cin &gt;&gt; in; update ( 1, n, i, in, seg ); &#125; // type 1: 單點修改 // type 2: 區間查詢最大值 while ( m-- )&#123; cin &gt;&gt; type; if ( type == 1 )&#123; cin &gt;&gt; l &gt;&gt; in; update ( 1, n, l, in, seg ); &#125; else if ( type == 2 )&#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query ( l, r, 1, n, seg ) &lt;&lt; '\n'; &#125; &#125;&#125; 持久化因為要保留舊版本，所以對所有需要被修改的節點新開一個位置來並且把左右子結點的指標，指向原本左右子結點的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; node *l, *r; int value; node ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) &#123;&#125; // 新增一個建構子，可以直接複製原本的 l, r node ( node *o ): l ( o -&gt; l ), r ( o -&gt; r ), value ( o -&gt; value ) &#123;&#125; inline void up ( void )&#123; value = -1; if ( l ) value = max ( value, l -&gt; value ); if ( r ) value = max ( value, r -&gt; value ); &#125;&#125; *seg = nullptr;void build ( int l, int r, node *&amp;o )&#123; o = new node ( 0 ); if ( l == r ) return; int mid = ( l + r ) &gt;&gt; 1; build ( l, mid, o -&gt; l ); build ( mid + 1, r, o -&gt; r ); o -&gt; up();&#125;void update ( int l, int r, int index, int value, node *&amp;o )&#123; // 把需要修改的節點在修改前先開一個新位置出來 o = new node ( o ); if ( l == r ) o -&gt; value = value; else&#123; int mid = ( l + r ) &gt;&gt; 1; if ( index &lt;= mid ) update ( l, mid, index, value, o -&gt; l ); else update ( mid + 1, r, index, value, o -&gt; r ); o -&gt; up(); &#125;&#125;int query ( int l, int r, int nowL, int nowR, node *o )&#123; if ( l &lt;= nowR &amp;&amp; nowR &lt;= r ) return o -&gt; value; int mid = ( nowL + nowR ) &gt;&gt; 1; if ( r &lt;= mid ) return query ( l, r, nowL, mid, o -&gt; l ); if ( mid &lt; l ) return query ( l, r, mid + 1, nowR, o -&gt; r ); return max ( query ( l, r, nowL, mid, o -&gt; l ), query ( l, r, mid + 1, nowR, o -&gt; r ) );&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, l, r, in, type; // 紀錄版本用的 vector vector &lt; node* &gt; version; cin &gt;&gt; n &gt;&gt; m; build ( 1, n, seg ); for ( int i = 1 ; i &lt;= n ; i++ )&#123; cin &gt;&gt; in; update ( 1, n, i, in, seg ); &#125; // 記錄初始版本 version.push_back ( seg ); // type 1: 單點修改 // type 2: 區間查詢最大值 // type 3: 回朔到版本 k while ( m-- )&#123; cin &gt;&gt; type; if ( type == 1 )&#123; cin &gt;&gt; l &gt;&gt; in; update ( 1, n, l, in, seg ); // 修改完紀錄版本 version.push_back ( seg ); &#125; else if ( type == 2 )&#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query ( l, r, 1, n, seg ) &lt;&lt; '\n'; &#125; else&#123; // 回朔到版本 k cin &gt;&gt; in; seg = version[in]; &#125; &#125;&#125; 有修改過的地方 line 修改內容 12 新增一個建構子，可以直接複製原本的 l, r 36 在對節點修改前先開一個新的位置 69 記錄用的 vector 77, 88 修改完成後，記錄當前版本內容 94 新增一個操作，可回朔到版本 k 非簡單操作線段樹我們還是看個題目 現在給定一個長度為 $N$ 序列，以及 $M$ 筆操作，操作內容有 修改一個元素的值 查詢區間中最長的「好序列」長度 定義一個「好區間」為：每個元素都是前一個元素 + 1 這邊是一個題目叫大龍貓的濃縮版，完整版題目可以看 這邊 現在有點麻煩了，RMQ 我們會，但是這種該怎麼用線段樹實作 我們可以在 node 中紀錄目前最長的好序列長度，以及其開始位置以及結束位置每次合併兩個區間就取兩邊紀錄的最長好序列的最大值 Emmm，但是感覺好像怪怪的如果合併兩個區間後，交界處那邊形成一個更長的好序列，怎麼辦？ 尷尬，那我們只好在每個 node 也記錄從開頭處到結束處的好序列了 聽起來很複雜，但是其實一點也不 為了方便編寫，我們先定義一個 piece，還有如何辨識兩個 piece 是否相同 12345678910111213struct piece&#123; int l, r, sz; // 檢查兩個 piece 是否相同 bool operator == ( const piece b )&#123; return l == b.l &amp;&amp; r == b.r; &#125;&#125;;// 不想寫 operator（或是覺得太麻煩）可以這樣寫inline bool same ( piece a, piece b )&#123; return a.l == b.l &amp;&amp; a.r == b.r;&#125; $l, r$ 就是這個區間的左右界$sz$ 是大小，可有可無，只是寫 code 上方便 然後是 node 123struct node&#123; piece front, back, ma;&#125;; $front, back$ 分別為是記錄當前線段樹區間內，從左邊界開始的好序列長度，以及從右邊屆開始的好序列長度$ma$ 則是記錄當前線段樹區間內，最長的好序列長度 接著來寫合併兩個區間的函數吧，因為沒有內建的函數可以用，只能自己寫一下 1234567891011121314151617inline node merge ( node L, node R )&#123; node res; res.front = L.front, res.back = R.back, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma ); if ( basic[L.back.r] + 1 == basic[R.front.l] )&#123; piece swp = piece &#123; L.back.l, R.front.r, R.front.r - L.back.l + 1 &#125;; if ( L.front == L.back ) res.front = swp; if ( R.front == R.back ) res.back = swp; res.ma = ( swp.sz &gt; res.ma.sz ? swp : res.ma ); &#125; return res;&#125; 合併兩個區間後，要回傳的 res 內容如下 res 內的 piece 來源 front l.front back r.back ma l.ma, r.ma, l.back + r.back 這三者中的最長好序列 後記這篇文章寫的也挺久的，主要是文中的內容大部分都不常用到，在寫的時候還跑去翻了一些文章 正因如此，內容上可能有些錯誤，如有發現，請聯絡 筆者]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang心情隨筆 #1]]></title>
    <url>%2Fcode%2Fgd-1%2F</url>
    <content type="text"><![CDATA[我也有點忘記我最初為什麼會接觸 Golang 了應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她其中好像就有一本Golang的語法書雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了所以我就開始翻了起來起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱像是我可以在 C 裡面 #include 後，然後就直接用標頭檔裡面的函數不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( “%d”, &amp;n ) 之類的（嚴格來說應該是 fmt.Scanf ( “%d”, &amp;n )）但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww明明就只是要 print 個 Hello, World! 要寫 class ww . 最近比較有空，所以想說來複習一下 Golang 怎麼寫（？論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽或者是拿它來寫程設作業什麼？只能用 C 寫喔沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ 不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C語言中 char 字串轉換成數字]]></title>
    <url>%2Fcode%2FC-atoi%2F</url>
    <content type="text"><![CDATA[前言今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字 方法 使用內建函數atoi 自己寫 內建函數的用法可以去cpprefrence查到，所以這邊就不解說了只有講自己寫的做法 原理如果要在一個數字的尾端加上一位數，該如何操作？有一種方法：先把原數字 * 10，然後再把那一位數加上去所以就可以有下面這種code 123456789int translate ( char *c, int len )&#123; int i, res = 0; for ( i = 0 ; i &lt; len ; i++ )&#123; res *= 10; res += ( c[i] - '0' ); &#125; return res;&#125; 然後解說一下code中第五行char之間的相減就是ASCii code的值的差所以可以用這種方法把原本的數字還原出來]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[APCS] 2019年六月場實作題詳解]]></title>
    <url>%2Fcode%2FAPCS-19-06%2F</url>
    <content type="text"><![CDATA[前言因為想要拼5 + 5，於是又報名了這次的APCS至於成績如何那就晚點再說吧，算是個小伏筆（？ 即便考場在家附近，我還是提早出門了還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎趕快google一下才發現跑錯棚了，應該是在校區的另一邊所以我又趕快跑過去，差一點點遲到好險有提早出門（汗 problem 1題目給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節求出主場最終的輸贏 兩場全贏：勝 兩場全敗：敗 一勝一敗：平手 保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題 解法直接實作一下就好了 code1234567891011121314151617181920212223242526272829303132333435363738394041// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int a = 0, b = 0, ans = 0, swp; for ( int i = 0 ; i &lt; 4 ; i++ )&#123; cin &gt;&gt; swp; a += swp; &#125; for ( int i = 0 ; i &lt; 4 ; i++ )&#123; cin &gt;&gt; swp; b += swp; &#125; ans += ( a &gt; b ? 1 : -1 ); a = b = 0; for ( int i = 1 ; i &lt; 4 ; i++ )&#123; cin &gt;&gt; swp; a += swp; &#125; for ( int i = 1 ; i &lt; 4 ; i++ )&#123; cin &gt;&gt; swp; b += swp; &#125; ans += ( a &gt; b ? 1 : -1 ); if ( !ans ) cout &lt;&lt; "Draw"; else if ( ans &gt; 0 ) cout &lt;&lt; "Win"; else cout &lt;&lt; "Lose"; cout &lt;&lt; '\n';&#125; problem 2題目給定一張圖，起點為整張圖權重最小的點並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點然後路徑上點不能重複求出路徑的總權重 解法dfs裸題，UVa有類似的題目（題號我忘記了反正就是模擬一次就對了（也沒有其他解法啊(ry code12345678910111213141516171819202122232425262728293031323334353637383940414243444546// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;const int maxN = 105; // 大小我忘記了const int INF = 0x3f3f3f3f; // INF大於值域，又可直接memset，方便又實用typedef long long LL;int mp[maxN][maxN];LL dfs ( int x, int y, LL sum )&#123; // 先找出最低點 int mi = min ( min ( mp[x + 1][y], mp[x - 1][y] ), min ( mp[x][y + 1], mp[x][y - 1] ) ); sum += mp[x][y]; mp[x][y] = INF; if ( mi == INF ) return sum; if ( mp[x + 1][y] == mi ) return dfs ( x + 1, y, sum ); if ( mp[x - 1][y] == mi ) return dfs ( x - 1, y, sum ); if ( mp[x][y + 1] == mi ) return dfs ( x, y + 1, sum ); if ( mp[x][y - 1] == mi ) return dfs ( x, y - 1, sum );&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, x, y, mi = INF; memset ( mp, INF, sizeof mp ); cin &gt;&gt; n &gt;&gt; m; // 1 index，可以直接免去判斷邊界的麻煩 for ( int i = 1 ; i &lt;= n ; i++ ) for ( int j = 1 ; j &lt;= m ; j++ )&#123; cin &gt;&gt; mp[i][j]; if ( mi &gt; mp[i][j] ) mi = mp[i][j], x = i, y = j; &#125; cout &lt;&lt; dfs ( x, y, 0 ) &lt;&lt; '\n';&#125; problem 3題目給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始請求出每一對可以組成互補字串的數量且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列所以$AAB$與$AB$與$BA$都是相同的字串 定義一下互補字串假設字串$A$中的元素沒有出現在字串$B$中同時，字串$B$的元素也沒有出現在字串$A$中則稱$A \text&amp; B$為互補字串 解法解法一：硬幹說明之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的 code1234567891011121314151617181920212223242526272829303132333435363738394041// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;#define F first#define S secondusing namespace std;map &lt; string, int &gt; lib;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, ans = 0; string str, basic; char c = 'A'; cin &gt;&gt; n &gt;&gt; m; for ( int i = 0 ; i &lt; m ; i++, c++ ) basic += c; while ( n-- )&#123; cin &gt;&gt; str; // 這邊為了要把順序都統一，所以先做一下排序 sort ( str.begin(), str.end() ); // 這邊則是要把重複的字元壓掉 str.erase ( unique ( str.begin(), str.end() ), str.end() ); lib[str]++; &#125; for ( auto j: lib )&#123; str = basic; // 把出現過的直接刪掉 for ( auto i: j.F ) str.erase ( lower_bound ( str.begin(), str.end(), i ) ); ans += j.S * lib[str]; &#125; // 因為會重複計算到兩次 ans /= 2; cout &lt;&lt; ans &lt;&lt; '\n';&#125; 方法二：Xor說明因為原本的方法太智障了（？如果不是因為資料量小可以這樣做，資料量一大直接吃土 出來之後聽到有人是這樣做的，有點類似Hash的做法把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$然後為了方便運算會把這個二進位reverse 也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$然後再把二進位轉成十進位這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串 code12345678910111213141516171819202122232425262728293031323334353637383940414243// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;#define F first#define S secondusing namespace std;map &lt; int, int &gt; lib;inline int translate ( string str )&#123; int res = 0; for ( auto i: str ) res |= ( 1 &lt;&lt; ( i - 'A' ) ); return res;&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, ans = 0, ori = 0; string str; cin &gt;&gt; n &gt;&gt; m; for ( int i = 0 ; i &lt; m ; i++ ) ori |= ( 1 &lt;&lt; i ); while ( n-- )&#123; cin &gt;&gt; str; // 這邊為了要把順序都統一，所以先做一下排序 sort ( str.begin(), str.end() ); // 這邊則是要把重複的字元壓掉 str.erase ( unique ( str.begin(), str.end() ), str.end() ); lib[translate ( str )]++; &#125; for ( auto j: lib ) ans += ( j.S * lib[ori ^ j.F] ); // 因為會重複計算到兩次 ans &gt;&gt;= 1; cout &lt;&lt; ans &lt;&lt; '\n';&#125; 注意，這份code並沒有經過詳細測試，可能有誤 problem 4題目給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量 解法Slide Window裸題，不過關於實作又有兩種做法 方法一：固定Window大小把window大小固定為$M$，並且開一個set紀錄這個window的數字要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了 code1234567891011121314151617181920212223242526272829303132333435363738394041424344// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;const int maxN = 100005;int cnt[maxN];int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, ans = 0; cin &gt;&gt; n &gt;&gt; m; vector &lt; int &gt; data ( n ), lib; for ( auto &amp;i: data ) cin &gt;&gt; i; // 離散化 lib = data; sort ( lib.begin(), lib.end() ); lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() ); for ( auto &amp;i: data ) i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin(); queue &lt; int &gt; q; set &lt; int &gt; s; for ( int i = 0 ; i &lt; n ; i++ )&#123; q.push ( data[i] ); s.insert ( data[i] ); cnt[data[i]]++; if ( q.size() &gt;= m )&#123; cnt[q.front()]--; if ( !cnt[q.front()] ) s.erase ( q.front() ); q.pop(); &#125; if ( s.size() == m ) ans++; &#125; cout &lt;&lt; ans &lt;&lt; '\n';&#125; 方法二：不固定的window大小此方法由吳邦一教授提出（原文連結）由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止 code123456789101112131415161718192021222324252627282930313233343536373839404142// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;const int maxN = 100005;int cnt[maxN];int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, ans = 0; cin &gt;&gt; n &gt;&gt; m; vector &lt; int &gt; data ( n ), lib; for ( auto &amp;i: data ) cin &gt;&gt; i; // 離散化 lib = data; sort ( lib.begin(), lib.end() ); lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() ); for ( auto &amp;i: data ) i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin(); // 這邊的話就不用set了 queue &lt; int &gt; q; for ( int i = 0 ; i &lt; n ; i++ )&#123; // 不斷pop直到這個數字前面沒有出現過 while ( !q.empty() &amp;&amp; cnt[data[i]] )&#123; cnt[q.front()]--; q.pop(); &#125; q.push ( data[i] ); cnt[data[i]]++; if ( q.size() == m ) ans++; &#125; cout &lt;&lt; ans &lt;&lt; '\n';&#125; 後記其實我把所有題目寫完之後，大概才過41分鐘然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到也就是說，我在裡面燒機燒了一個半小時然後產量是零抓到，澪人桐是燒機大師早就知道出來玩手機算了 = = . 看到這邊多多少少都會對我的成績有點興趣吧（？（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛話不多說我直接上圖好了 差一題觀念5+5搞什麼 = = 以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼（欸，差不多是一年前的六月場欸OAO 雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜那麼今天就到這邊了，謝謝各位今天的閱讀如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我我的email可以在我的個人頁面找到p.s. 我今天寫好長的文章喔，到這邊已經430行了 本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行所以原本的文章看起來很很空還需要自己手動調整，有點小麻煩不過他可以即時顯示md的渲染結果，真的讓人難以抉擇 更新（2019/07/04 10:28）之前可以查詢成績好像是bug，官方是說今天早上十點才可以查剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看） 圖片出處 紅色鳥居：神奈川縣蘆之湖kaji_nori06 成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧 級距。。。啊就從成績單上截圖截下來的啊 = =]]></content>
      <tags>
        <tag>APCS</tag>
        <tag>Full Contest Solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Code Jam 2019 Qualification Round]]></title>
    <url>%2Fcode%2FGCJ-2019-QuR%2F</url>
    <content type="text"><![CDATA[前言我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了 只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了下一場是在這週六晚上九點～十一點半撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走 總之，過 Qualification Round 應該就算比去年好了去年在耍廢直接爆炸。。。 希望今年可以去 Round 2 先放上這次的題目連結 problem A題目現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$多筆測資 解法顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$一臉就是在跟你說開 string 存啊所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$然後把這兩個數字輸出注意不能有前導零 code123456789101112131415161718192021222324252627282930313233// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int t, mi; string n; cin &gt;&gt; t; for ( int tms = 1 ; tms &lt;= t ; tms++ )&#123; cout &lt;&lt; "Case #" &lt;&lt; tms &lt;&lt; ": "; cin &gt;&gt; n; mi = INF; for ( int i = 0 ; i &lt; n.size() ; i++ )&#123; if ( n[i] == '4' )&#123; mi = min ( mi, i ); cout &lt;&lt; '3'; &#125; else cout &lt;&lt; n[i]; &#125; cout &lt;&lt; ' '; for ( int i = mi ; i &lt; n.size() ; i++ ) cout &lt;&lt; ( n[i] == '4' ) cout &lt;&lt; '\n'; &#125;&#125; 後記我還沒有注意到這題有保證輸入有 $4$也沒有注意到這題要求輸出都要是正整數運氣真好，歪歪得正 problem B題目給定一張二維圖以及一條從左上到右下的路線求一條不重複的另外一條路線所謂的路線重複是指 $a \to b$ 這個邊同時出現在兩條路線中然後輸入都是SESE這樣，代表從起點開始他往哪些位置走並且保證只會往東（右）以及往南（下）走詳細請看這張圖 解法$O ( N ^ 2 )$垃圾如我，肯定只會寫 $N ^ 2$ 的解法簡單來說就是 dp我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點 不過這樣做有小地方需要注意一下理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ &amp; $dp[i][j - 1]$ 轉移過來所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來但是因為我懶得寫特判（明明就是自己懶）所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移啊如果還是都可以拿，那就真的隨便了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;#define F first#define S second#define mp make_pairtypedef pair &lt; short, char &gt; psc;bool lib[maxN][maxN];psc str[maxN][maxN];int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int t, n, x, y; string data; cin &gt;&gt; t; for ( int tms = 1 ; tms &lt;= t ; tms++ )&#123; cin &gt;&gt; n &gt;&gt; data; memset ( lib, 0, sizeof lib ); for ( int i = 0 ; i &lt;= n ; i++ )&#123; for ( int j = 0 ; j &lt;= n ; j++ )&#123; str[i][j] = mp ( 0, ' ' ); &#125; &#125; x = 1, y = 1; for ( auto i: data )&#123; lib[x][y] = true; i == 'S' ? x++ : y++; &#125; lib[x][y] = true; str[1][1] = mp ( 0, ' ' ); for ( int i = 2 ; i &lt;= n ; i++ )&#123; if ( lib[1][i] )&#123; if ( !lib[1][i - 1] )&#123; str[1][i] = str[1][i - 1]; str[1][i].F++; str[1][i].S = 'E'; &#125; &#125; else&#123; str[1][i] = str[1][i - 1]; str[1][i].F++; str[1][i].S = 'E'; &#125; &#125; for ( int i = 2 ; i &lt;= n ; i++ )&#123; if ( lib[i][1] )&#123; if ( !lib[i - 1][1] )&#123; str[i][1] = str[i - 1][1]; str[i][1].F++; str[i][1].S = 'S'; &#125; &#125; else&#123; str[i][1] = str[i - 1][1]; str[i][1].F++; str[i][1].S = 'S'; &#125; for ( int j = 2 ; j &lt;= n ; j++ )&#123; if ( lib[i][j] )&#123; if ( !lib[i][j - 1] )&#123; str[i][j] = str[i][j - 1]; str[i][j].F++; str[i][j].S = 'E'; &#125; else&#123; str[i][j] = str[i - 1][j]; str[i][j].F++; str[i][j].S = 'S'; &#125; &#125; else&#123; if ( str[i][j - 1].F &gt; str[i - 1][j].F )&#123; str[i][j] = str[i][j - 1]; str[i][j].S = 'E'; &#125; else&#123; str[i][j] = str[i - 1][j]; str[i][j].S = 'S'; &#125; str[i][j].F++; &#125; &#125; &#125; data = ""; x = y = n; while ( str[x][y].S != ' ' )&#123; data += str[x][y].S; str[x][y].S == 'S' ? x-- : y--; &#125; reverse ( data.begin(), data.end() ); cout &lt;&lt; "Case #" &lt;&lt; tms &lt;&lt; ": " &lt;&lt; data &lt;&lt; '\n'; &#125;&#125; $O ( N )$沒錯，$O ( N )$我後來才發現我TMD被哏到了只要把 S E 反轉就好啊讀到 S 輸出 E ，反之讀到 E 輸出 S這樣就會變成從左上到右下的對稱所以路線不會重複。。。 12345678910111213141516171819// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int t, n; string str; cin &gt;&gt; t; while ( t-- &amp;&amp; cin &gt;&gt; n &gt;&gt; str )&#123; for ( auto i: str ) cout &lt;&lt; ( i == 'S' ? 'E' : 'S' ); cout &lt;&lt; '\n'; &#125;&#125; problem C感謝 En-ming Huang 大大提供要 solution 請去找他 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;int input[maxN], l;char out[maxN][2], print[maxN];bool check ( int idx, char now )&#123; if ( idx == l )&#123; cout &lt;&lt; print &lt;&lt; '\n'; return true; &#125; for ( int i = 0 ; i &lt; 2 ; i++ )&#123; if ( out[idx][i] != now ) continue; print[idx] = out[idx][i]; if ( idx == l - 1 ) print[idx + 1] = out[idx][!i]; return check ( idx + 1, out[idx][!i] ); &#125; return false;&#125;int main() &#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int t, n, idx; set &lt; int &gt; prime; map &lt; int, char &gt; lib; cin &gt;&gt; t; for (int i = 1; i &lt;= t; i++)&#123; cin &gt;&gt; n &gt;&gt; l; memset ( print, 0, sizeof print ); prime.clear(); lib.clear(); cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; for ( int i = 0 ; i &lt; l ; i++ )&#123; cin &gt;&gt; input[i]; for ( int j = 2 ; j &lt;= n ; j++ )&#123; if ( input[i] % j == 0 )&#123; prime.insert ( j ); prime.insert ( input[i] / j ); break; &#125; &#125; &#125; idx = 0; for ( auto i: prime ) lib[i] = 'A' + idx++; for ( int i = 0 ; i &lt; l ; i++ ) for ( int j = 2 ; j &lt;= n ; j++ ) if ( input[i] % j == 0 )&#123; out[i][0] = lib[j]; out[i][1] = lib[input[i] / j]; break; &#125; for ( int i = 0 ; i &lt; 2 ; i++ ) if ( check ( 0, out[0][i] ) ) break; &#125; return 0;&#125; 後記這場打起來感覺好廢最近比較少寫演算法競賽的題目幾乎都是在讀新東西手感感覺不是很好教練，我想要拿 T-Shirtp.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打而且時間上來說是 CodeForces 的 usaul time中國人應該不少（汗1A 1B 1C 要有一場前 1500 名才能進去啊（遠望覺得有點難@@ 最後放個計分板截圖 寫完這篇文章，在本地端用 hexo 編譯預覽出來後發現圖片邊緣有白框。。。好樣的，我又要來修 css 配置了工作量 up up = =]]></content>
      <tags>
        <tag>Full Contest Solution</tag>
        <tag>GCJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TIOJ][1909] 勇者出征]]></title>
    <url>%2Fcode%2FTIOJ-1909%2F</url>
    <content type="text"><![CDATA[題目原題目連結據說是 2015TOI 三模的題目簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有： 從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個 假設 $D$ 可以連結到 $A$ 的話（$D的高度 \lt A$），那麼$A$也可以到 $D$ 求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號如果有多組解，輸出編號最小的 解法我們先來釐清一下什麼是簡單路徑好了所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑 建圖看到路徑，我第一個想到的是圖論我們先想一下，要怎麼把圖建出來 暴力 $O ( N^2 )$$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較12345678910111213141516171819202122232425#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )for ( int i = 0 ; i &lt; n ; i++ )&#123; int l = -1, r = n; for ( int j = i - 1 ; j &gt;= 0 ; j-- ) if ( data[j] &gt; data[i] )&#123; l = j; break; &#125; for ( int j = i + 1 ; j &lt; n ; j++ ) if ( data[j] &gt; data[i] )&#123; r = j; break; &#125; if ( l == -1 &amp;&amp; r == n ) continue; if ( l == -1 )&#123; UNI ( r, i, edges ); continue; &#125; if ( r == n )&#123; UNI ( l, i, edges ); continue; &#125; UNI ( ( data[l] &lt; data[r] ? l : r ), i, edges );&#125; 線段樹 $O ( NlogN )$然後我就想到線段樹了$index$ 是做離散化後的數字，$value$ 是編號然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值一開始右手邊的最小值線段樹，裡面有$N$個點每處理完一個點，就把這個點拔掉丟到左邊去code大概像這樣123456789101112131415161718192021222324252627282930313233343536#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )#define INF 0x3f3f3f3f// function// 線段樹1是紀錄最小值、右手邊的線段樹// 而線段數2是紀錄最大值、左手邊的線段樹int seg1[maxN &lt;&lt; 2], seg2[maxN &lt;&lt; 2];void update1 ( int l, int r, int index, int value, int n );int query1 ( int l, int r, int nowL, int nowR, int n );void update2 ( int l, int r, int index, int value, int n );int query2 ( int l, int r, int index, int value, int n );// lib是已經做完離散化的數列memset ( seg1, INF, sizeof seg1 );memset ( seg2, -1, sizeof seg2 )for ( int i = 0 ; i &lt; n ; i++ ) update1 ( 0, n, i, lib[i], 1 );for ( int i = 0 ; i &lt; n ; i++ )&#123; int l = query2 ( lib[i] + 1, n, 0, n, 1 ); int r = query1 ( lib[i] + 1, n, 0, n, 1 ); if ( l == -1 &amp;&amp; r == INF ) continue; if ( l == -1 )&#123; UNI ( i, r, edges ); continue; &#125; if ( r == INF )&#123; UNI ( i, l, edges ); continue; &#125; UNI ( i, ( data[l] &lt; data[r] ? l : r ), edges ); update1 ( 0, n, INF, lib[i], 1 ); update2 ( 0, n, i, lib[i], 1 );&#125; 單調列隊優化 $O ( N )$關於單調列隊優化的介紹可以看這份建中講義第二頁這邊 根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的 那麼假設要插入一個數字呢？假設現在這個數字比最後一個還要大，那麼我們就不斷的拔拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候接著把這些拔掉的數字與 $A$ 做連接 不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？因為他是說兩邊第一個比她大的數字的 min既然兩邊都比他大，那麼當然選小的啊 最後這個 deque 會保證遞減那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L’$ 做連結直到這個 deque 清空為止 不過因為只需要從後端做操作所以用 stack 就可以了 詳細的 code 請看這12345678910111213141516171819202122232425262728typedef pair &lt; int, int &gt; pii;#define F first#define S second#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )// data 是原數列stack &lt; pii, vector &lt; pii &gt; &gt; st;// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）pii swp;st.push ( pii ( data[0], 0 ) );for ( int i = 1 ; i &lt; n ; i++ )&#123; while ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123; swp = st.top(); st.pop(); if ( EMP ( st ) ) UNI ( swp.S, i, edges ); else UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges ); &#125; st.push ( pii ( data[i], i ) );&#125;swp = st.top();st.pop();while ( !st.empty() )&#123; UNI ( swp.S, st.top().S, edges ); swp = st.top(); st.pop();&#125; 是時候來處理路徑囉至於這個題目的另外一個部分：路徑又該怎麼處理呢？我們可以發現，這份資料轉換完之後保證是二元樹為什麼？因為他最多只會被兩個其他的點連結（左邊一個右邊一個）而自己只會連結到一個點那麼這不就是二元樹嗎？那麼，通過點 $u$ 的路徑會有三種： $u$ 的祖先到 $u$ 的子孫的路徑 $u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑 從 $u$ 開始（或結束）的路徑 我們先定義 dp[u] = u的子孫數目（包含 u ）因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）因此只要計算起點終點的組合數就好了 那麼 1. 就很好算啦 ( 總點數 - dp[n] - 1 )\times ( dp[n] - 1 )那麼 2. 呢？上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\times dp[n]$）就是答案了 呃，3. 應該就不用講了吧 = =就 總點數減一啊 = = 然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧） 綜合一二三，所以只需要dfs一次就好了 這部分的code我放這123456789101112131415161718192021222324#define maxN 1000005vector &lt; int &gt; edges[maxN];int cnt[maxN], dp[maxN], N;// N = 總點數 - 1void dfs ( int n, int p )&#123; int a = -1, b = -1; for ( auto i: edges[n] )&#123; if ( i == p ) continue; if ( a == -1 ) a = i; else b = i; dfs ( i, n ); dp[n] += dp[i]; &#125; cnt[n] += ( N - dp[n] ) * dp[n]; // 祖先到子孫 if ( deges[n].size() == 3 ) // 如果是有兩個子孫的話 cnt[n] += dp[a] * dp[b]; dp[n]++; // 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1 cnt[n] += N; cnt[n] &lt;&lt;= 1; // 記得乘二喔&#125; code綜合以上，我的code長這樣1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair &lt; int, int &gt; pii;#define pb push_back#define F first#define S second#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )#define maxN 1000005vector &lt; int &gt; edges[maxN];LL dp[maxN], N, cnt[maxN];void dfs ( int n, int p )&#123; int a = -1, b = -1; for ( auto i: edges[n] )&#123; if ( i == p ) continue; if ( a == -1 ) a = i; else b = i; dfs ( i, n ); dp[n] += dp[i]; &#125; cnt[n] += ( N - dp[n] ) * dp[n]; if ( edges[n].size() == 3 ) cnt[n] += dp[a] * dp[b]; dp[n]++; cnt[n] += N; cnt[n] &lt;&lt;= 1;&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, idx = -1; LL ma = -1; cin &gt;&gt; n; vector &lt; int &gt; data ( n ); for ( auto &amp;i: data ) cin &gt;&gt; i; stack &lt; pii, vector &lt; pii &gt; &gt; st; pii swp; st.push ( pii ( data[0], 0 ) ); for ( int i = 1 ; i &lt; n ; i++ )&#123; while ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123; swp = st.top(); st.pop(); if ( st.empty() ) UNI ( swp.S, i, edges ); else UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges ); &#125; st.push ( pii ( data[i], i ) ); &#125; swp = st.top(); st.pop(); while ( !st.empty() )&#123; UNI ( swp.S, st.top().S, edges ); swp = st.top(); st.pop(); &#125; N = n - 1; dfs ( 0, -1 ); for ( int i = 0 ; i &lt; n ; i++ )&#123; if ( cnt[i] &gt; ma ) ma = cnt[i], idx = i; &#125; cout &lt;&lt; ma &lt;&lt; ' ' &lt;&lt; idx + 1 &lt;&lt; '\n';&#125; 後記其實這題我寫了很久因為之前一段時間都在搞特選而且我怕特選爆掉沒學校念所以我都在讀學測最近特選出來了已經沒有後顧之憂可以好好搞 TOI 了 &lt;3才回來鍊也是因為剛回來鍊所以手感很糟 = =線段樹寫 query 還把查詢區間 &amp; 總區間寫反 = =還有忘了設定 ma = -1然後還想說為什麼 WA Orz這題也沒有看出來是單調列隊還傻傻花一個多小時寫線段樹 + debug結果單調隊列快狠準 = =我到底在幹嘛 = =不過好險還有三個月（吧 然後這篇文章也太長 = =這一行是第 326 行呃我是說在原始的 md 檔案上喔這邊已經 328 行了好多 = =至少可定下心來好好練習了]]></content>
      <tags>
        <tag>graph</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF]Round 521]]></title>
    <url>%2Fcode%2FCFR521%2F</url>
    <content type="text"><![CDATA[前言身為一個垃圾，當然要打的像垃圾一樣先是校內爆掉，現在換 div.3 爆掉。。。pC 沒開 long long 溢位被 hack 成智障的就是我坐等晚上 rating change沒意外應該會噴掉啦 先放上所有題目的連結 problem A題目大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正） 解法阿不就直接暴力就好算一下會往左次往右幾次，算一下就好 code1234567891011121314151617181920212223// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); #define int LL int t, k, a, b, swp, ans; cin &gt;&gt; t; while ( t-- )&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; k; swp = a - b; ans = swp * ( LL ) ( k / 2 ); if ( k &amp; 1 ) ans += a; cout &lt;&lt; ans &lt;&lt; '\n'; &#125;&#125; problem B題目給定一排房屋現在是否有開燈通常關燈了就是在睡覺了 題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈那麼那戶人家就會被干擾但是請注意，只有一邊的鄰居開燈並不會被干擾 現在想要讓所有在睡覺的人都不會被干擾求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數 解法因為只有一邊有開燈並不會被干擾也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了 那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算 code12345678910111213141516171819202122232425262728293031323334353637// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, ans = 0, m; cin &gt;&gt; n; vector &lt; int &gt; data ( n ), lib; for ( auto &amp;i: data ) cin &gt;&gt; i; for ( int i = 1 ; i &lt; n - 1 ; i++ )&#123; if ( !data[i] &amp;&amp; data[i - 1] &amp;&amp; data[i + 1] ) lib.push_back ( i ); &#125; m = lib.size(); while ( lib.size() &gt; 1 )&#123; if ( lib[1] - lib[0] == 2 )&#123; ans++; lib.erase ( lib.begin() ); lib.erase ( lib.begin() ); &#125; else&#123; ans++; lib.erase ( lib.begin() ); &#125; &#125; if ( !lib.empty() ) ans++; cout &lt;&lt; ans &lt;&lt; '\n';&#125; problem C就是這題，我沒有開 long long 然後就被 hack 了名次噴掉 1500 多名 題目給定一條長度為 $N$ 的序列我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的請列出數量，以及些解的位置 因為題目有點難懂，我放上其中一個例子好了那現在看另外一個序列 $[ 8, 3, 5, 2 ]$ 移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \to 5 = 3 + 2$ 移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \to 8 = 3 + 5$ 解法 計算原先序列的總和 每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉 把 $sum$ 為奇數則返回步驟2 尋找 $\frac{sum}{2}$ 是否出現於原序列中 檢查 $\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次 如果有出現過兩次，那麼 i 就是其中一個答案 返回步驟 2 有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數假設 $sum’ = sum - a[i]，sum’$ 代表除了 $a[i]$ 以外的元素和既然一個序列為好的序列，代表說這個序列會被切成兩部分而這兩部分的和會一樣既然都會被切成兩個一樣的東西了，為什麼 $sum’$ 會是奇數這就矛盾了，所以 $sum’$ 一定為偶數 code123456789101112131415161718192021222324252627282930313233343536373839404142434445// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define int LLmap &lt; int, int &gt; lib;#undef intint main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); #define int LL int n, sum = 0; cin &gt;&gt; n; vector &lt; int &gt; data ( n ), ans; for ( auto &amp;i: data )&#123; cin &gt;&gt; i; sum += i; lib[i]++; &#125; for ( int i = 0 ; i &lt; n ; i++ )&#123; sum -= data[i]; if ( sum &amp; 1 )&#123; sum += data[i]; continue; &#125; sum &gt;&gt;= 1; if ( ( lib[sum] == 1 &amp;&amp; sum != data[i] ) || lib[sum] &gt; 1 )&#123; ans.push_back ( i + 1 ); &#125; sum &lt;&lt;= 1; sum += data[i]; &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for ( auto i: data ) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n';&#125; problem D題目給定一大小為 $N$ 的可重複集合 $S$求找出一大小為 $K$ 的可重複集合 $S’ ( S’\subseteq S )$ 且 $S’$ 在 $S$ 中出現次數最多 元素可重複，這件事情非常重要 解法我先做離散化，反正數字跟解法沒有關係接著紀錄每個數字出現幾次我先二分搜最多那個集合最多可以出現幾次然後按照次數輸出，反正只要符合要求的都行 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define maxN 200005int cnt[maxN], m, k, ma;vector &lt; int &gt; lib;map &lt; int, vector &lt; int &gt; &gt; table;inline bool check ( int tms )&#123; int res = 0; for ( int i = tms ; i &lt; ma ; i++ ) for ( auto j: table[i] ) res += cnt[j] / tms; return res &gt;= k;&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); int n, l = 0, r = -1, mid; cin &gt;&gt; n &gt;&gt; k; vector &lt; int &gt; data ( n ); for ( auto &amp;i: data ) cin &gt;&gt; i; if ( n == k )&#123; for ( auto i: data ) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; return 0; &#125; lib = data; sort ( lib.begin(), lib.end() ); lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() ); m = lib.size(); for ( auto i: data )&#123; cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++; &#125; for ( int i = 0 ; i &lt; m ; i++ )&#123; r = max ( r, cnt[i] ); table[cnt[i]].push_back ( i ); &#125; ma = ++r; mid = ( l + r ) &gt;&gt; 1; while ( r - l &gt; 1 )&#123; if ( check ( mid ) ) l = mid; else r = mid; mid = ( l + r ) &gt;&gt; 1; &#125; l = k; for ( int i = 0 ; i &lt; m ; i++ )&#123; for ( int j = 0 ; j &lt; min ( cnt[i] / mid, l ) ; j++ ) cout &lt;&lt; lib[i] &lt;&lt; ' '; l -= min ( cnt[i] / mid, l ); if ( !l ) break; &#125; cout &lt;&lt; '\n';&#125; problem E這題我賽中只有想到喇賽解法，賽後才想到正解 題目給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）求最多可以使用多少題目注意！你應該要最大會題目數量，而非天數 解法每舉第一天的題數，然後暴力往後找用 lower_bound 去尋找是個不錯的選擇 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define maxN 200005LL cnt[maxN];int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); int n, m, ma, ans = -1, swp, idx, id; cin &gt;&gt; n; vector &lt; int &gt; data ( n ), lib; for ( auto &amp;i: data ) cin &gt;&gt; i; lib = data; sort ( lib.begin(), lib.end() ); lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() ); m = lib.size(); for ( auto i: data ) cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++; data.clear(); for ( int i = 0 ; i &lt; m ; i++ )&#123; data.push_back ( cnt[i] ); &#125; sort ( data.begin(), data.end() ); ma = data.back() + 1; for ( int i = 0 ; i &lt; ma ; i++ )&#123; swp = idx = 0; for ( int j = i ; j &lt; ma &amp;&amp; idx &lt; m ; j &lt;&lt;= 1 )&#123; id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin(); if ( id &lt; data.size() ) swp += j; idx = id + 1; &#125; ans = max ( ans, swp ); &#125; cout &lt;&lt; ans &lt;&lt; '\n';&#125; 後記老實說我這場有點慘pC 被 Hack，pE 賽中沒寫出來以我的實力來說不應該這樣子的因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@ 希望下一場可以好好發揮]]></content>
      <tags>
        <tag>Full Contest Solution</tag>
        <tag>CodeForces</tag>
        <tag>div.3</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TIOJ][1615] A! + B! problem]]></title>
    <url>%2Fcode%2FTIOJ-1615%2F</url>
    <content type="text"><![CDATA[前言好久沒有寫 code 發題解了最近因為一些事情沒有時間（也沒有心情）認真寫 code（因為上次 CodeForces 連續掉分我心情有點糟）（啊還有學科校內爆炸也是我心情糟的原因之一）（開始懷疑我到底這一年努力是為了什麼，之類的）然後今天想說寫個題目、發個題解刷一下存在感，之類的所以跑去 TIOJ 翻題目然後看到這題。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼 題目 &amp; 解法大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數原網址我放在這 很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數因為要加一，所以我想了很久感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）但是我真的沒有想法所以就寫了個 $O ( N^2 )$ 的解法。。。然後過了，wtf就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查就這樣。。。我一臉懵逼的坐在電腦前傻了一下才開始動手打這篇文章 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define maxN 1000000bitset &lt; maxN &gt; lib;vector &lt; LL &gt; prime;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); #define int LL lib[0] = lib[1] = true; for ( int i = 2 ; i &lt; maxN ; i++ )&#123; if ( !lib[i] )&#123; prime.push_back ( i ); for ( int j = i ; j &lt; maxN ; j += i ) lib[j] = true; &#125; &#125; int a, b, len = prime.size(); LL ans, stp; while ( cin &gt;&gt; a &gt;&gt; b )&#123; if ( a &gt; b ) swap ( a, b ); ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin(); stp = 1; for ( int i = a + 1 ; i &lt;= b ; i++ )&#123; stp *= i; &#125; stp++; for ( int i = 0 ; i &lt; ans ; i++ )&#123; while ( stp % prime[i] == 0 )&#123; stp /= prime[i]; &#125; &#125; for ( int i = ans ; i &lt; len ; i++ )&#123; if ( !( stp % prime[i] ) )&#123; ans++; while ( stp % prime[i] == 0 ) stp /= prime[i]; &#125; &#125; if ( stp &gt; maxN ) ans++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125;&#125; 後記最近特殊選才有點忙加上 CodeForces，校內賽的陰影我可能會暫時停筆一下啦XD沒有意外，等到特選告一段落會繼續。。。吧等等印象中好像有 CodeForces，啊不過有點晚會不會打還是未知數下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧在特選放榜前我應該不會繼續認真搞比賽了因為我不知道在放榜後我會何去何從（笑先讀點書好像比較保險 不過如果特選有好結果我還是會認真搞 TOI 入營考啦已經是最後一年了，能不能進去就聽由天命囉 然後，謝謝看到這邊的你（我這麼寫怎麼有點感傷啊XD）我已經很久沒有發文了，希望大家還有在看謝謝各位一直以來對我的支持 &lt;3]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ITSA] No.66 詳解]]></title>
    <url>%2Fcode%2Fitsa-66%2F</url>
    <content type="text"><![CDATA[前言簡單來說就是我特殊選才的資料不夠所以只好來打這東西，不然備審有夠空QQ problem 1題目這題就是給你一行整數（數量不定，但是保證 &lt; 11個）求該行出現率「超過」一半的整數 解法看到數量不定就會用 getline + stringstream，這很直觀然後因為他只有說「給整數」，並沒有限制數字大小所以我是用 map 做，而不是陣列（出現負數就尷尬了）雖然比較慢但是也比較無腦 為什麼我會在題目那把「超過」加上引號？。。。因為我在寫 code 的時候耍智障把判斷式寫成 &gt;=然後我就吃 WA 了我還跑去問如果有多組解怎麼辦結果超過一半的數字只會有一個QQ還有把 NO 打成 No就多吃兩個 penalty 了，虧爆抓到，澪人桐不會寫程式 code123456789101112131415161718192021222324252627282930313233343536// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;map &lt; int, int &gt; lib;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); string str; int in, cnt; bool ans; while ( getline ( cin, str ) )&#123; lib.clear(); cnt = 0; ans = false; stringstream ss ( str ); while ( ss &gt;&gt; in )&#123; lib[in]++; cnt++; &#125; for ( auto i: lib )&#123; if ( i.S &gt; cnt / 2 )&#123; cout &lt;&lt; i.F &lt;&lt; '\n'; ans = true; break; &#125; &#125; if ( !ans ) cout &lt;&lt; "NO\n"; &#125;&#125; problem 2題目給一個簡單的一元一次方程式保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除並保證所有運算元與運算子之間只都有空白隔開並且求出 $x$，無條件捨去到小數點第一位 解法要寫字串判斷很麻煩欸 = =pA寫爆了先來寫這題（？手速不知道為什麼爆快快到我自己也嚇到也沒出什麼 bug，很快就 AC 了 &lt;3 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_backstring str;vector &lt; int &gt; lib;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int opt, len, x, a, b, ans; bool flag; while ( getline ( cin, str ) )&#123; len = str.size(), x = 0, ans = 0; flag = false; lib.clear(); for ( int i = 0 ; i &lt; len ; i++ )&#123; if ( str[i] == '+' ) opt = 0; else if ( str[i] == '-' ) opt = 1; else if ( str[i] == '*' ) opt = 2; else if ( str[i] == '/' ) opt = 3; else&#123; if ( '0' &lt;= str[i] &amp;&amp; str[i] &lt;= '9' )&#123; x = x * 10 + int ( str[i] - '0' ); flag = true; &#125; else&#123; if ( flag ) lib.pb ( x ); x = 0, flag = false; &#125; &#125; &#125; if ( flag ) lib.pb ( x ); a = lib[0], b = lib[1]; if ( !opt ) ans = ( b - a ) * 10.0; else if ( opt == 1 ) ans = ( b + a ) * 10.0; else if ( opt == 2 ) ans = ( int ) ( ( double ) b / a * 10.0 ); else&#123; if ( str[0] == 'x' ) ans = ( int ) ( ( double ) b * a * 10.0 ); else ans = ( int ) ( ( double ) a / b * 10.0 ); &#125; cout &lt;&lt; ans / 10 &lt;&lt; '.' &lt;&lt; ans % 10 &lt;&lt; '\n'; &#125;&#125; problem 3題目給定 $N$ 組字串，請將字串以 $’:’ or ‘;’ or ‘,’$ 切割並輸出出所有字串 解法啊就水題水到爆啊，多開個 string 紀錄就好了這題沒有難度（蓋章 code123456789101112131415161718192021222324252627282930// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); string str, swp; int t; cin &gt;&gt; t; getline ( cin, str ); while ( t-- )&#123; getline ( cin, str ); cout &lt;&lt; "Tokens found:\n"; swp = ""; for ( auto i: str )&#123; if ( i == ':' || i == ',' || i == ';' )&#123; cout &lt;&lt; swp &lt;&lt; '\n'; swp = ""; &#125; else swp += i; &#125; if ( swp != "" ) cout &lt;&lt; swp &lt;&lt; '\n'; &#125;&#125; problem 4題目zj 上面的是羅馬數字轉阿拉伯數字這次 ITSA 出的是要把阿拉伯數字轉羅馬數字更水 = = 解法直接按照位數打表輸出就好。。。雖然這麼說，但是我還是出 bug 了我把4打成”IIII”，正確應該是”IX”垃圾是我QQ code1234567891011121314151617181920// by.MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;string lib0[10] = &#123; "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX" &#125;;string lib1[10] = &#123; "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC" &#125;;string lib2[10] = &#123; "", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM" &#125;;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int t, in; cin &gt;&gt; t; while ( t-- )&#123; cin &gt;&gt; in; cout &lt;&lt; lib2[in / 100] &lt;&lt; lib1[in % 100 / 10] &lt;&lt; lib0[in % 10] &lt;&lt; '\n'; &#125;&#125; problem 5題目給定兩個字串，求出這兩個字串所有的 LCS 解法本來只有丟任意解的 LCS然後就吃 WA 了，又多一個 penalty問官方官方一直沒有回應就想說先寫所有解的版本好了等到一回覆馬上 judge 然後這就是裸的 LCS 啊 = = code123456789101112131415161718192021222324252627282930313233343536373839404142434445// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;int dp[105][105], ma;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); string a, b, str; set &lt; string &gt; lib; while ( cin &gt;&gt; a &gt;&gt; b )&#123; int szA = a.size(), szB = b.size(); lib.clear(); memset ( dp, 0, sizeof dp ); ma = 0; for ( int i = 0 ; i &lt; szA ; i++ )&#123; for ( int j = 0 ; j &lt; szB ; j++ )&#123; if ( a[i] == b[j] )&#123; dp[i + 1][j + 1] = dp[i][j] + 1; ma = max ( ma, dp[i + 1][j + 1] ); &#125; &#125; &#125; if ( !ma )&#123; cout &lt;&lt; "No common sequence!\n"; continue; &#125; for ( int i = 0 ; i &lt; szA ; i++ )&#123; for ( int j = 0 ; j &lt; szB ; j++ )&#123; if ( dp[i + 1][j + 1] == ma )&#123; str = ""; for ( int k = i - ma + 1 ; k &lt;= i ; k++ ) str += a[k]; lib.insert ( str ); &#125; &#125; &#125; for ( auto i: lib ) cout &lt;&lt; i &lt;&lt; '\n'; &#125;&#125; 後記在第 37 分鐘的時候就破台了（那時候師大還沒有破台）那時候我跟師大的 penalty 差 67也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了。。。然後師大只吃 6680 抽抽不到術師匠的非洲酋長正常發揮QQ 下一次沒意外就會去打 PTC 了不過是英文題目我覺得我會扛不起來在此誠徵英文好的選手一名工作：只要幫我翻譯題目就好 然後這一篇的題解我居然寫了 330 行喔，這行就 331 了 = =雖然看起來很多不過大部分都是 code 就是了]]></content>
      <tags>
        <tag>Full Contest Solution</tag>
        <tag>ITSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Disjoint Set 並查集]]></title>
    <url>%2Fcode%2Fdsu%2F</url>
    <content type="text"><![CDATA[上一篇blog因為介紹並查集的地方太多了，文章太長所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了然後會在昨天文章上加入這篇的連結 disjoint set 並查集我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了 這個時候大概會寫出像這樣的 code 12345678910111213141516171819202122232425// disjoint set#include&lt;bits/stdc++.h&gt;using namespace std;#define maxN 10005int dis[maxN];inline void init ( void )&#123; for ( int i = 0 ; i &lt; maxN ; i++ ) dis[i] = i;&#125;inline int find ( int n )&#123; return dis[n] == n ? dis[n] : find ( dis[n] );&#125;inline void Union ( int a, int b )&#123; dis[a] = b;&#125;inline bool same ( int a, int b )&#123; return find ( a ) == find ( b );&#125; 路徑壓縮我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰下次就可以直接略過中間的點，直接到老大那了 find 函數會被改成這樣親民寫法：12345void find ( int n )&#123; if ( dis[n] == n ) return n; return dis[n] = find ( n );&#125; 然後就是會有人（例如我），會想要把它寫在一起所以就變成這樣了XD123void find ( int n )&#123; return dis[n] == n ? n : dis[n] = find ( dis[n] );&#125; 最後這個東西的複雜度會變成均攤 $O ( \log N )$，感覺還不錯 避免 Stack Overflow最最最後有個東西也挺重要的因為路徑壓縮還是要按照這個點的遍歷往上爬又是用遞迴實作所以有機會會戳到 Stack overflow然後你就吃 RE 了恭喜多一個 penalty重點是你不知道這樣會吃到 Stack overflow 然後就會多吃幾個w 雖然說現在很多 judge 都避免掉了啦會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大只是難免會戳到那種舊型 judge所以還是乖乖學一下怎麼避免 Stack overflow 吧 要壓縮遞迴深度，可以有兩種方法 方法一：random在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦 1234inline void Union ( int a, int b )&#123; dis[a] = b; find ( rand() % n );&#125; 方法二：Union by rank把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈理論上這樣應該不會爆炸，因為深度很平均 12345678int rk[maxN];inline void Union ( int a, int b )&#123; if ( rk[a] &lt; rk[b] ) swap ( a, b ); dis[b] = a; rk[b] = rk[a] + 1 ;&#125; 這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數至於那是啥我也不知道，只知道幾乎可以算是常數了 不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用 方法三：Union by size這也挺直觀的把大小比較小的並查集接在大的下面比較小，需要做改動的點就比較少，對吧 12345678int sz[maxN];inline void Union ( int a, int b )&#123; if ( sz[a] &gt; sz[b] ) swap ( a, b ); dis[a] = b; sz[b] += sz[a];&#125; 如果開優化還是爛了呢通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size再爛掉。。。這應該是叫你去寫啟發式合併吧據說那東西比並查集還要快不過我也沒有實作過，所以我並不清楚 確認是否屬於同一個並查集確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內 123inline bool same ( int a, int b )&#123; return find ( a ) == find ( b )&#125; 用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了 後記我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =現在看了一下，我光 dsu 就寫 171 行了@@覺得累]]></content>
      <tags>
        <tag>data structure</tag>
        <tag>dsu</tag>
        <tag>disjoint set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][420] C. 藏寶圖]]></title>
    <url>%2Fcode%2FTOJ-420%2F</url>
    <content type="text"><![CDATA[今天來講講自己出的題目好了這題是我在今年（2018）六月時排名賽出的題目搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ 題目先附上原題目網址 題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑MST 怎麼做？我這邊選用 Kruskal（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal） 先備知識在提 Kruskal 前，我們先講講 MST 到底是什麼吧 最小生成樹MST 的正式全名為「最小生成樹」所謂的生成樹就是把這張圖拔掉一些邊後，這張圖沒有環以及所有點都有聯通也就是說：假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有剛好一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹 而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T’$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹 樹直徑那麼樹直徑又是什麼呢？通常樹直徑就是一棵樹上的任意點對的最長距離 作法Kruskal我先講講Kruskal是什麼好了 按照MST的定義，有個很直觀的想法 先按照邊的權重對於所有邊由小到大排序過 依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中 至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)詳細內容可以看這篇 樹直徑樹直徑作法通常有兩個： dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑 先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案 作法1還挺好瞭解的，只是實作上可能會出包作法2有點費時間，但是很好寫 code總而言之，我的 code 長這樣是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;#define maxN 1000005typedef pair &lt; int, int &gt; pii;typedef long long LL;#define pb push_back#define F first#define S secondstruct node&#123; int u, v, w;&#125;;inline bool cmp ( node a, node b )&#123; return a.w &lt; b.w;&#125;int dis[maxN];LL dist[maxN];vector &lt; node &gt; edges;vector &lt; pii &gt; mst[maxN];inline void init ( void )&#123; for ( int i = 0 ; i &lt; maxN ; i++ ) dis[i] = i;&#125;int find ( int n )&#123; return dis[n] == n ? n : dis[n] = find ( dis[n] );&#125;inline void Union ( int a, int b )&#123; dis[find ( a )] = find ( b );&#125;inline bool same ( int a, int b )&#123; return find ( a ) == find ( b );&#125;inline void Kruskal ( void )&#123; sort ( edges.begin(), edges.end(), cmp ); for ( auto &amp;i: edges )&#123; if ( same ( i.u, i.v ) ) continue; Union ( i.u, i.v ); mst[i.u].pb ( pii ( i.v, i.w ) ); mst[i.v].pb ( pii ( i.u, i.w ) ); &#125;&#125;void dfs ( int n, int p )&#123; // 樹直徑 for ( auto i: mst[n] )&#123; if ( i.F == p ) continue; dist[i.F] = dist[n] + i.S; dfs ( i.F, n ); &#125;&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, u, v, w, t, idx, now; LL ma = -1; cin &gt;&gt; n &gt;&gt; m; init(); while ( m-- )&#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edges.pb ( node &#123; u, v, w &#125; ); &#125; Kruskal(); dfs ( 0, -1 ); for ( int i = 0 ; i &lt; n ; i++ ) if ( ma &lt; dist[i] ) ma = dist[i], idx = i; dist[idx] = 0; dfs ( idx, -1 ); ma = -1; for ( int i = 0 ; i &lt; n ; i++ ) ma = max ( ma, dist[i] ); cout &lt;&lt; ma &lt;&lt; '\n';&#125; 後記我這一篇文我有種我是在寫 disjoint set 教學的錯覺覺得累大半篇幅都是在教 disjoint set看來原始 md 檔要破 300 行了呢（倒地 然後還有那一堆數學式子，看到頭都在痛我個人還蠻喜歡寫那些東西的看起來很猛（就是中二啦 = =不過常常寫到一半會開始懷疑我沒事寫那麼難動幹嘛沒事虐待自己幹嘛話雖如此不過還是寫完了啦XD 更新(2019/03/06)雖然說不是最近的事了，不過我想我還是提一下好了因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了所以目前在 TOJ 上寫不到這題喔非常抱歉 &gt; &lt;]]></content>
      <tags>
        <tag>dfs</tag>
        <tag>TOJ</tag>
        <tag>dsu</tag>
        <tag>MST</tag>
        <tag>樹直徑</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][407] D. 警力配置]]></title>
    <url>%2Fcode%2FTOJ-407%2F</url>
    <content type="text"><![CDATA[又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =別再給我增加工作量啊垃圾我還要把舊站的文章搬過來改成 md 檔啊 = = 題目我先附上連結 題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長 注意：至少有一個 $\to$ 有兩個也沒關係 這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫（但是不小心撈到73分，我問號） 解法很顯然的要先轉成一張圖，這絕對是圖論 = =也就是說題意可以被化簡成這樣：給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到。。。啊不就匈牙利既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下這篇然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法 因為這題真的是裸題（？）所以我就直接附 code 了 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_back#define maxN 200005vector &lt; int &gt; edges[maxN];int match[maxN], visit[maxN], turn;inline bool dfs ( int n )&#123; visit[n] = turn; for ( auto i: edges[n] )&#123; if ( match[i] == -1 || ( visit[match[i]] != turn &amp;&amp; dfs ( match[i] ) ) )&#123; match[i] = n; match[n] = i; return true; &#125; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int t, m, u, v, p, q, ans; cin &gt;&gt; t; while ( t-- )&#123; ans = 0; memset ( match, -1, sizeof match ); for ( auto &amp;i: edges ) i.clear(); cin &gt;&gt; p &gt;&gt; q &gt;&gt; m; while ( m-- )&#123; cin &gt;&gt; u &gt;&gt; v; v += p; edges[u].pb ( v ); edges[v].pb ( u ); &#125; p += q; for ( int i = 0 ; i &lt;= p ; i++ )&#123; if ( match[i] == -1 )&#123; turn++; // 省去每次 dfs 都要 memset 一次 visit 陣列的時間 if ( dfs ( i ) ) ans++; // 如果可以找到新的配對就 ans++ &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125;&#125; tips然後這邊我有用到一個小技巧，可以避免 TLE通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）如果我們把這個陣列開成 int 陣列並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪這樣就不用浪費時間去 memset 了]]></content>
      <tags>
        <tag>graph</tag>
        <tag>TOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF][999E] E. REACHABILITY FROM THE CAPITAL]]></title>
    <url>%2Fcode%2FCF-999E%2F</url>
    <content type="text"><![CDATA[題目 + 解法這是 CodeForces Round 490 div.3 的題目最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人沒有意外下一場應該就會下來了吧先放上題目連結 會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打） 講一下題目大意好了首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ） 有個很直觀的想法如下，首先點會先被分成兩種類型： 這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過 沒有經過的點（從 $S$ 出發到達不了） 所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧） code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;#pragma GCC optimize ( "O3" )#pragma loop_opt ( on )using namespace std;#define maxN 5005vector &lt; int &gt; edges[maxN];int pa[maxN];bool used[maxN];void dfs ( int n, int p )&#123; used[n] = true; pa[n] = p; for ( auto i: edges[n] )&#123; if ( used[i] ) continue; dfs ( i, p ); &#125;&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, s, u, v; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; while ( m-- )&#123; cin &gt;&gt; u &gt;&gt; v; edges[u].push_back ( v ); &#125; dfs ( s, s ); for ( int i = 1 ; i &lt;= n ; i++ )&#123; if ( pa[i] == 0 )&#123; memset ( used, 0, sizeof used ); dfs ( i, i ); &#125; &#125; set &lt; int &gt; lib; for ( int i = 1 ; i &lt;= n ; i++ )&#123; if ( pa[i] != s ) lib.insert ( pa[i] ); &#125; cout &lt;&lt; lib.size() &lt;&lt; '\n';&#125; tips可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？ 是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？ 又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到所以即便 pa 被覆寫了也是沒有關係的]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>div.3</tag>
        <tag>graph</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][406] C. 軍隊部署]]></title>
    <url>%2Fcode%2FTOJ-406%2F</url>
    <content type="text"><![CDATA[題目老樣子先放連結TOJZJ這是去年（106年）全國學科能力競賽資訊科全國賽的pC分類上算是水題一枚（按照去年整體難度來說） 題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊 解法所以如果我們先不看種族，我們先看能力就好，可以看成： 第一位：是否對空，是為 $1$，否為 $0$ 第二位：是否範圍，是為 $1$，否為 $0$ 第三位：是否遠距，是為 $1$，否為 $0$ 所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$ 接著是種族，有三種族，所以代號為$1, 2, 3$ 那麼來做dp陣列的規劃吧$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能 然後要求是三種族、三功能都要有，所以那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族 呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想看 code 可能會比較好瞭解，我 code 放下面 code123456789101112131415161718192021222324252627// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;long long dp[5][10];int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); long long n, x, y, z, w, ans = 0; cin &gt;&gt; n; for ( int i = 0 ; i &lt; n ; i++ )&#123; cin &gt;&gt; w &gt;&gt; x &gt;&gt; y &gt;&gt; z; dp[w][x * 4 + y * 2 + z]++; &#125; for ( int i = 0 ; i &lt; 8 ; i++ ) for ( int j = 0 ; j &lt; 8 ; j++ ) for ( int k = 0 ; k &lt; 8 ; k++ ) if ( ( i | j | k ) == 7 ) ans += dp[1][i] * dp[2][j] * dp[3][k]; cout &lt;&lt; ans &lt;&lt; '\n';&#125;]]></content>
      <tags>
        <tag>dp</tag>
        <tag>TOJ</tag>
        <tag>ZJ</tag>
        <tag>全國賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF][920F] F. SUM AND REPLACE]]></title>
    <url>%2Fcode%2FCF-920F%2F</url>
    <content type="text"><![CDATA[前言好久沒有發題解了，今天心血來潮來寫一篇吧今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pFpF，感覺很難？其實還好， 因為這是 Education 題目不管，翻譯下題目好了，畢竟原題是英文的要原題連結的在這 給定一個長度為N的序列，並有兩種輸入要處理： 對區間 $l, r$ 做操作 $D$（等等寫在下面） 查詢區間和 操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 $\{1, 2, 3, 6\}$，共四個） 解法嗯。。。區間操作？區間和？怎麼看都是線段樹，但是問題是：操作因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\sqrt{N}$，證明我等等再打 好，我們先觀察一下： 只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變） 越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果 接著是最後一個問題：該如何處理區間操作對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）不過有種做法叫找收斂點（終止點） 剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\ge 2$ 的數字當作是否繼續進行操作的依據 到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看這篇 不過大概算了一下，這樣需要開到$8\times N$的記憶體，感覺會 MLE所以我先拿區間和開刀，如果當前區間和 $\ge 2\times range（區間大小）$ 再繼續進行操作。。。然後我就 WA 了，請想想如果當前區間內元素為 $\{ 1, 1, 1, 3 \}$ 的時候 有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\ge 2$ 本來不想要開第二顆線段樹，到頭來還不是開了 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define maxN 300005LL sum[maxN &lt;&lt; 2], dp[1000005];bool used[maxN &lt;&lt; 2];vector &lt; int &gt; prime;bitset &lt; 1005 &gt; lib;inline int D ( int n )&#123; if ( dp[n] != -1 ) return dp[n]; double www = sqrt ( n ); int ma = www, res = 0, maa = ma + 1; for ( int i = 1 ; i &lt; maa ; i++ ) n % i ? res : res++; return dp[n] = res * 2 - ( www == ma ? 1 : 0 );&#125;inline void build ( int l, int r, int n )&#123; if ( l == r )&#123; cin &gt;&gt; sum[n]; used[n] = ( sum[n] &gt; 2 ); &#125; else&#123; int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1; build ( l, mid, leftSon ); build ( mid + 1, r, rightSon ); sum[n] = sum[leftSon] + sum[rightSon]; used[n] = ( used[leftSon] || used[rightSon] ); &#125;&#125;inline LL query ( int l, int r, int nowL, int nowR, int n )&#123; if ( l &lt;= nowL &amp;&amp; nowR &lt;= r ) return sum[n]; int mid = ( nowL + nowR ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1; if ( r &lt;= mid ) return query ( l, r, nowL, mid, leftSon ); if ( mid &lt; l ) return query ( l, r, mid + 1, nowR, rightSon ); return query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + 1, nowR, rightSon );&#125;inline void modify ( int l, int r, int nowL, int nowR, int n )&#123; if ( !used[n] ) return; if ( nowL == nowR )&#123; sum[n] = D ( sum[n] ); used[n] = ( sum[n] &gt; 2 ); &#125; else&#123; int mid = ( nowL + nowR ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1; if ( r &lt;= mid ) modify ( l, r, nowL, mid, leftSon ); else if ( mid &lt; l ) modify ( l, r, mid + 1, nowR, rightSon ); else&#123; modify ( l, r, nowL, mid, leftSon ); modify ( l, r, mid + 1, nowR, rightSon ); &#125; sum[n] = sum[leftSon] + sum[rightSon]; used[n] = ( used[leftSon] || used[rightSon] ); &#125;&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); lib[0] = lib[1] = true; for ( int i = 2 ; i &lt; 1005 ; i++ )&#123; if ( !lib[i] )&#123; prime.push_back ( i ); for ( int j = i &lt;&lt; 1 ; j &lt; 1005 ; j += i ) lib[j] = true; &#125; &#125; memset ( dp, -1, sizeof dp ); int n, m, type, l, r, stop; cin &gt;&gt; n &gt;&gt; m; build ( 1, n, 1 ); while ( m-- )&#123; cin &gt;&gt; type &gt;&gt; l &gt;&gt; r; if ( type == 1 ) modify ( l, r, 1, n, 1 ); else cout &lt;&lt; query ( l, r, 1, n, 1 ) &lt;&lt; '\n'; &#125;&#125; 證明（？接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\sqrt{N}$ 的數字就好了假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數這樣代表說 $\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \frac{N}{i} \to i \times j = N$假設 $i\le j$ 帶入上面的式子，$i^2\le N\to i\le\sqrt{N}$故得證 。。。好啦，我感覺我寫的證明不是對的 &gt; &lt;以上證明僅供參考]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>Education Round</tag>
        <tag>segment tree</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][391] E. 模數 CANDY]]></title>
    <url>%2Fcode%2FTOJ-391%2F</url>
    <content type="text"><![CDATA[題目 &amp; 解法我先附上題目連結簡單來說，就是區間取餘數然後這東西可以用線段樹實作 然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法在寫區間開根號的時候，我們用的是區間最大值線段樹，是的，區間最大值 理由很簡單，因為開根號開到最後，一定會朝向$1$收斂所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧 同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數這應該算是一種剪枝（吧 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;#pragma GCC optimize ( "O3" )#pragma loop_opt ( on )using namespace std;#define maxN 200005int seg[maxN &lt;&lt; 2];void update ( int l, int r, int index, int value, int n )&#123; if ( l == r ) seg[n] += value; else&#123; int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1; if ( index &lt;= mid ) update ( l, mid, index, value, leftSon ); else update ( mid + 1, r, index, value, rightSon ); seg[n] = max ( seg[leftSon], seg[rightSon] ); &#125;&#125;void modify ( int l, int r, int nowL, int nowR, int value, int n )&#123; if ( seg[n] &lt; value ) return; if ( nowL == nowR ) seg[n] %= value; else&#123; int mid = ( nowL + nowR ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1; if ( r &lt;= mid ) modify ( l, r, nowL, mid, value, leftSon ); else if ( mid &lt; l ) modify ( l, r, mid + 1, nowR, value, rightSon ); else&#123; modify ( l, mid, nowL, mid, value, leftSon ); modify ( mid + 1, r, mid + 1, nowR, value, rightSon ); &#125; seg[n] = max ( seg[leftSon], seg[rightSon] ); &#125;&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, type, l, r, x, in; cin &gt;&gt; n; n--; for ( int i = 0 ; i &lt;= n ; i++ )&#123; cin &gt;&gt; in; update ( 0, n, i, in, 1 ); &#125; cin &gt;&gt; m; while ( m-- )&#123; cin &gt;&gt; type; if ( type == 1 )&#123; cin &gt;&gt; l &gt;&gt; r; update ( 0, n, r, l, 1 ); &#125; else if ( type == 2 )&#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify ( l, r, 0, n, x, 1 ); &#125; else cout &lt;&lt; seg[1] &lt;&lt; '\n'; &#125;&#125; 所以其實這題也不難嘛 為什麼不能打 Lazy Tag？ 。。。因為 mod 沒有疊加性啊 證明然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）所以總複雜度大約為 $O ( log ( max \lbrace a_i \rbrace ) )$ 左右（此部分感謝 jd3 學長提供）]]></content>
      <tags>
        <tag>segment tree</tag>
        <tag>TOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TIOJ][1795] 咕嚕咕嚕呱啦呱啦]]></title>
    <url>%2Fcode%2FTIOJ-1795%2F</url>
    <content type="text"><![CDATA[這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧 題目題目連結在這 給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$另外，任意一條邊的權重只有可能為 $0 or 1$ 解法只要做出最小生成樹以及最大生成樹就好了，證明如下假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則： ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\le k\e ub$ 的生成樹 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define maxN 100005struct bridge&#123; int u, v, w;&#125;;struct disjionSet&#123; int dis[maxN]; inline void Init ( void )&#123; for ( int i = 0 ; i &lt; maxN ; i++ ) dis[i] = i; &#125; inline int find ( int n )&#123; return dis[n] == n ? n : dis[n] = find ( dis[n] ); &#125; inline bool same ( int a, int b )&#123; return find ( a ) == find ( b ); &#125; inline void Union ( int a, int b )&#123; dis[find ( a )] = find ( b ); &#125;&#125;;vector &lt; bridge &gt; edges;inline bool cmp ( bridge a, bridge b )&#123; return a.w &lt; b.w;&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, k, u, v, w, ub = 0, lb = 0; disjionSet dis; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; while ( m-- )&#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edges.push_back ( bridge &#123; u, v, w &#125; ); &#125; sort ( edges.begin(), edges.end(), cmp ); dis.Init(); for ( auto i: edges )&#123; if ( dis.same ( i.u, i.v ) ) continue; dis.Union ( i.u, i.v ); lb += i.w; &#125; reverse ( edges.begin(), edges.end() ); dis.Init(); for ( auto i: edges )&#123; if ( dis.same ( i.u, i.v ) ) continue; dis.Union ( i.u, i.v ); ub += i.w; &#125; cout &lt;&lt; ( lb &lt;= k &amp;&amp; k &lt;= ub ? "TAK" : "NIE" ) &lt;&lt; '\n';&#125;]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVA][00459]GRAPH CONNECTIVITY]]></title>
    <url>%2Fcode%2Fuva00459%2F</url>
    <content type="text"><![CDATA[題目 &amp; 解法原題目網址 簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。 喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector） 最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\le 26$) 所以就直接用 set 了 後來發現。。。就算重複了也無仿啊 = = code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;#pragma GCC optimize ( "O3" )#pragma loop_opt ( on )using namespace std;typedef long long LL;// define tools#define REPP(i,f,s) for ( int i = f ; i &lt; s ; i++ )#define REPALL(i,n) for ( auto &amp;i: n )#define MEM(n,i) memset ( n, i, sizeof n )typedef set &lt; int &gt; si;#define CLR(n) n.clear()#define GL(n) getline ( cin, n )si edge[30];bool go[30];inline void dfs ( int n )&#123; go[n] = true; REPALL ( i, edge[n] ) if ( !go[i] ) dfs ( i );&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); string str; int n, u, v, ans, cnt = 0, t; cin &gt;&gt; t; t++; while ( t-- )&#123; GL ( str ); MEM ( go, 0 ); REPP ( i, 0, 30 ) CLR ( edge[i] ); n = str[0] - 'A'; ans = 0; while ( GL ( str ) )&#123; if ( EMP ( str ) ) break; u = str[0] - 'A', v = str[1] - 'A'; edge[u].insert ( v ); edge[v].insert ( u ); &#125; n++; REPP ( i, 0, n ) if ( !go[i] )&#123; ans++; dfs ( i ); &#125; if ( !cnt++ ) continue; if ( cnt++ &gt; 2 ) cout &lt;&lt; '\n'; cout &lt;&lt; ans &lt;&lt; "\n"; &#125;&#125;]]></content>
      <tags>
        <tag>graph</tag>
        <tag>dfs</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][365]G.大龍貓]]></title>
    <url>%2Fcode%2FTOJ-365%2F</url>
    <content type="text"><![CDATA[題目給定一個數列，為一群龍貓的『高度』定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群請實作出支援單點修改及區間查詢的 code題目原網址 解法先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便） 接著定義另外一種資料型態，用在線段樹上維護的 $node$$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個 在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$ 那麼，$stop.ma$ 呢？ $stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大 總結其實這題不難，只是 coding 有點複雜，query &amp; update 都與正常的線段樹差不多，只是 up 需要思考一下（？） code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;#define maxN 100005struct piece&#123; int f, s, sz;&#125;;inline bool same ( piece a, piece b )&#123; return a.f == b.f &amp;&amp; a.s == b.s;&#125;struct node&#123; piece fro, bck, ma;&#125; seg[maxN &lt;&lt; 2];int basic[maxN];inline node up ( node L, node R )&#123; node res; res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma ); if ( basic[L.bck.s] + 1 == basic[R.fro.f] )&#123; piece stop = piece &#123; L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 &#125;; if ( same ( L.fro, L.bck ) ) res.fro = stop; if ( same ( R.fro, R.bck ) ) res.bck = stop; res.ma = ( stop.sz &gt; res.ma.sz ? stop : res.ma ); &#125; return res;&#125;inline void build ( int l, int r, int n )&#123; if ( l == r ) seg[n].fro = seg[n].bck = seg[n].ma = piece &#123; l, r, 1 &#125;; else&#123; int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1; build ( l, mid, leftSon ); build ( mid + 1, r, rightSon ); seg[n] = up ( seg[leftSon], seg[rightSon] ); &#125;&#125;void update ( int l, int r, int Index, int n )&#123; if ( l == r ) return; int mid = ( l + r ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1; if ( Index &lt;= mid ) update ( l, mid, Index, leftSon ); else update ( mid + 1, r, Index, rightSon ); seg[n] = up ( seg[leftSon], seg[rightSon] );&#125;node query ( int l, int r, int nowL, int nowR, int n )&#123; if ( l &lt;= nowL &amp;&amp; nowR &lt;= r ) return seg[n]; int mid = ( nowL + nowR ) &gt;&gt; 1, leftSon = n &lt;&lt; 1, rightSon = leftSon | 1; if ( r &lt;= mid ) return query ( l, r, nowL, mid, leftSon ); if ( mid &lt; l ) return query ( l, r, mid + 1, nowR, rightSon ); return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );&#125;int main()&#123; ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, q, l, r, type; cin &gt;&gt; n; for ( int i = 1 ; i &lt;= n ; i++ ) cin &gt;&gt; basic[i]; build ( 1, n, 1 ); cin &gt;&gt; q; while ( q-- )&#123; cin &gt;&gt; type &gt;&gt; l &gt;&gt; r; if ( type == 1 )&#123; basic[l] = r; update ( 1, n, l, 1 ); &#125; else cout &lt;&lt; query ( l, r, 1, n, 1 ).ma.sz &lt;&lt; '\n'; &#125;&#125;]]></content>
      <tags>
        <tag>segment tree</tag>
        <tag>TOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TIOJ][1940]Nim]]></title>
    <url>%2Fcode%2FTIOJ-1940%2F</url>
    <content type="text"><![CDATA[題目這題目很哏，真得很哏哏到我都快不想寫了（結果還是用兩節課 AC 了）題目略過，要看原題的在這 解法我看完題目第一個想法就是 DP 。。。然後我就 TLE 了（廢話 因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP但是請看範圍：$1e9$，怎麼看都會 TLE所以只能想一下數學解法了 $k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏 接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項： 0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\frac{n}{2}$ 就好了 接著再分兩個case : $n$ 為奇術時 case 餘一：$\frac{n}{4}$ 的整數部分 $\to \lfloor \frac{n}{4} \rfloor$case 餘三：$f ( 2, \frac{n}{2} ) \to$直接對這個函數做遞迴就好 總結一下，函數大概長這樣 f ( k, n ) = \begin{cases} n, & \text{if $k$ is $1$} \\ \begin{cases} \frac{n}{2}, & \text{if $n$ is even} \\ \lfloor \frac{n}{4} \rfloor, & \text{if $n = 4\times k + 1 ( k \in \mathbb{R} )$ } \\ f ( 2, \frac{n}{2} ), & \text{if $n = 4\times k + 3 ( k \in \mathbb{R} )$ } \end{cases}, & \text{if $k$ is $2$ } \end{cases}因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法 code12345678910111213141516171819202122232425262728293031// by. MiohitoKiri5474#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;#define maxN 10005inline int count ( int n )&#123; switch ( n )&#123; case 3: case 1: return 1; case 5: case 2: return 0; default: switch ( n % 4 )&#123; case 2: case 0: return n / 2; case 1: return n / 4; case 3: return count ( n / 2 ); &#125; &#125; return 0;&#125;int main()&#123; int k, m; scanf ( "%d%d", &amp;k, &amp;m ); printf ( "%d\n", ( k == 1 ? m : count ( m ) ) );&#125; 後記(2019/03/23 00:29)為了能讓這篇文章的函數好看一些硬生生讓 hexo 支援 mathjax 了然後上面那個精美的函式，我把原始碼放這邊 1234567891011$$f ( k, n ) =\begin&#123;cases&#125;n, &amp; \text&#123;if $k$ is $1$&#125; \\\begin&#123;cases&#125;\frac&#123;n&#125;&#123;2&#125;, &amp; \text&#123;if $n$ is even&#125; \\\lfloor \frac&#123;n&#125;&#123;4&#125; \rfloor, &amp; \text&#123;if $n = 4\times k + 1 ( k \in \mathbb&#123;R&#125; )$ &#125; \\f ( 2, \frac&#123;n&#125;&#123;2&#125; ), &amp; \text&#123;if $n = 4\times k + 3 ( k \in \mathbb&#123;R&#125; )$ &#125;\end&#123;cases&#125;, &amp; \text&#123;if $k$ is $2$ &#125;\end&#123;cases&#125;$$]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
</search>
