---
title: '[APCS] 2019年十月場實作題詳解'
date: 2019-10-26 16:53:52
tags:
 - APCS
 - Full Contest Solution
---

## 前言

因為上次差一題觀念就5 + 5，加上為了以後家教做準備，所以還是去考了
成績unknow，這次是在考完當天就動筆寫了

<!--more-->

因為這次比較晚報名，所以我是在台南大學考的，不是成大
老樣子又assume考場沒換，等到了之後才發現換了 = =
所以又急急忙忙的跑過去
好險有趕到

**免責聲明：因為code都是出了考場後才寫的，手邊沒有測資，所以並不保證在rewrite的過程中沒有出bug**


## problem 1

### 題目

原題目太長，以下是濃縮版本

給定一序列，假設有任意 $|Arr[i]-Arr[i - 1]| > 5$ 則把 $Arr[i]$ 改成前三項的中位數（前三項不用改）

### 解法

我是暴力做一下啦，詳細可以看code

### code

```cpp
// by.MiohitoKiri5474
#include<bits/stdc++.h>

using namespace std;

#define pb push_back

int main(){
    ios::sync_with_stdio ( false );
    cin.tie ( 0 );
    cout.tie ( 0 );

    int n;
    cin >> n;
    vector < int > data ( n ), lib;
    for ( auto &i: data )
        cin >> i;
    for ( int i = 3 ; i < n ; i++ ){
        if ( abs ( data[i] - data[i - 1 ] ) > 5 )
            lib.clear();
            for ( int j = 0 ; j < 3 ; j++ )
                lib.pb ( data[i - j] );
            sort ( lib.begin(), lib.end() );
            data[i] = lib[1];
    }

    for ( auto i: data )
        cout << i << ' ';
    cout << '\n';
}
```

## problem 2

### 題目

給定一組牌，並定義以下幾種操作：

* option 1: 把序列換成 $S_1, S_{\frac{n}{2} + 1}, S_2, S_{\frac{n}{2} + 2} ...$
* option 2: 把序列換成 $S_1, S_3, S_5 ...S_2, S_4, S_6...$
* option 3: 把序列換成$S_{k + 1}, S_{k + 2} ...S_1, S_2 ... S_k$

給你操作後的序列 & 操作順序，求原序列

然後要注意的是，當option為 1, 2 時代表的是option編號，其餘則是代表option 3的數字k
也就是說，當option 大於 3 的時候，為第三種操作

### 解法

暴力模擬一下就好

### code

```cpp
// by.MiohitoKiri5474
#include<bits/stdc++.h>

using namespace std;

#define pb push_back

int main(){
    ios::sync_with_stdio ( false );
    cin.tie ( 0 );
    cout.tie ( 0 );

    int n, m;
    cin >> n >> m;
    vector < int > data ( n ), option ( m ), a, b;
    for ( auto &i: data )
        cin >> i;
    for ( auto &i: option )
        cin >> i;
    reverse ( option.begin(), option.end() );
    for ( auto op: option ){
        a.clear(), b.clear();
        if ( op == 1 ){
            for ( int i = 0 ; i < n ; i++ )
                if ( i & 1 )
                    b.pb ( data[i] );
                else
                    a.pb ( data[i] );
            data = a;
            for ( auto i: b )
                data.pb ( i );
        }
        else if ( op == 2 ){
            int aidx = 0, bidx = 0;
            for ( int i = 0 ; i < n / 2 ; i++ )
                a.pb ( data[i] );
            for ( int i = n / 2 ; i < n ; i++ )
                b.pb ( data[i] );
            data.clear();
            for ( int i = 0 ; i < n ; i++ )
                if ( i & 1 )
                    data.pb ( b[bidx++] );
                else
                    data.pb ( a[aidx++] );
        }
        else{
            for ( int i = 0 ; i < n - op ; i++ )
                a.pb ( data[i] );
            for ( int i = n - op ; i < n ; i++ )
                b.pb ( data[i] );
            data = b;
            for ( auto i: a )
                data.pb ( i );
        }
    }

    for ( auto i: data )
        cout << i << ' ';
    cout << '\n';
}
```


## problem 3

### 題目

有一個序列，有一隻皮卡丘站在0上，並且玩家可以操控他
按一次按鈕可以往左走$l$格或往右走$r$格，並且在移動後需要瞬移到$S(i)上$（序列S題目另外給），請問最都需要按下幾次按鈕才能到P點

註：不能超出邊界 ( 0, n - 1 )

### 解法

我本來是暴力dfs，不過後來又想到一個更精妙的作法

#### 暴力dfs

##### 說明

每舉往左走及往右走的最短路徑，並且做處理

##### code

```cpp
// by.MiohitoKiri5474
#include<bits/stdc++.h>

using namespace std;

#define pb push_back
#define maxN 1000005
#define INF 0x3f3f3f3f

int n, l, r, p;
vector < int > data;
bool visited[maxN];

int dfs ( int idx, int step, bool move ){
    if ( idx == p )
        return step;
    if ( idx >= n || idx < 0 || visited[idx] )
        return INF;
    if ( move )
        return dfs ( data[idx], step, 0 );
    visited[idx] = true;
    step++;
    return min ( dfs ( idx - l, step, 1 ), dfs ( idx + r, step, 1 ) );
}

int main(){
    ios::sync_with_stdio ( false );
    cin.tie ( 0 );
    cout.tie ( 0 );

    cin >> n >> p >> l >> r;
    data.resize ( n );
    for ( auto &i: data )
        cin >> i;
    cout << dfs ( 0, 0 ) << '\n';
}
```


#### 小孩子才暴力解，大人都最短路啦

##### 說明

沒錯！最短路！
我是用最短路寫的
（雖然也有聽到是用dp解，我想應該是定義 $dp[i]$ 為從 $i$ 點到 $p$ 的最短距離吧？
中間多了一個步驟，就是把每一個點 $i$ 連接到往左 & 往右的點的單向邊（當然都要在範圍內
然後就可以用最短路砸下去了（撒花

##### code

```cpp
// by.MiohitoKiri5474
#include<bits/stdc++.h>

using namespace std;

#define pb push_back
#define maxN 1000005
#define INF 0x3f3f3f3f

vector < int > edges[maxN];
int dis[maxN];
bool inQ[maxN];

int main(){
    ios::sync_with_stdio ( false );
    cin.tie ( 0 );
    cout.tie ( 0 );

    int n, p, l, r, now;
    cin >> n >> p >> l >> r;
    vector < int > data ( n );
    for ( auto &i: data )
        cin >> i;

    for ( int i = 0 ; i < n ; i++ ){
        if ( i - l >= 0 )
            edges[i].pb ( i - l );
        if ( i + r < n )
            edges[i].pb ( i + r );
    }

    queue < int > q;
    memset ( dis, INF, sizeof dis );
    q.push ( 0 );
    dis[0] = 0;
    inQ[0] = true;
    while ( !q.empty() ){
        inQ[now = q.front()] = false;
        q.pop();
        for ( auto i: edges[now] ){
            if ( dis[i] > dis[now] + 1 ){
                dis[i] = dis[now] + 1;
                if ( !inQ[i] ){
                    inQ[i] = true;
                    q.push ( i );
                }
                if ( dis[data[i]] > dis[i] ){
                    dis[data[i]] = dis[i];
                    if ( !inQ[data[i]] ){
                        inQ[data[i]] = true;
                        q.push ( data[i] );
                    }
                }
            }
        }
    }

    cout << dis[p] << '\n';
}
```


## problem 4

### 題目

給定一個只有$0\ and\ 1$、大小為 $ N \times M$ 的二維陣列，定義如果四個邊界（上下左右）整列/整行都相同則可以被移除
求最少需要更改幾個點才能移除整張圖

$N, M \le 25$

### 解法

我自己是暴力dfs + 剪枝，正解應該是dp（數字夠小應該可以）

### 我的暴力dfs

