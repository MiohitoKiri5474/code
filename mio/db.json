{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.jpg","path":"images/logo.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/LICENSE","path":"lib/reading_progress/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/README.md","path":"lib/reading_progress/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/package.json","path":"lib/reading_progress/package.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/reading_progress.js","path":"lib/reading_progress/reading_progress.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/reading_progress.min.js","path":"lib/reading_progress/reading_progress.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/LICENSE","path":"lib/canvas-nest/theme-next-canvas-nest/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/README.md","path":"lib/canvas-nest/theme-next-canvas-nest/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/theme-next-canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/images/Untitled.jpg","path":"images/Untitled.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/background.jpg","path":"images/background.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/background1.jpg","path":"images/background1.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ddc76d6b323d249e5610f811d26987a5989fb408","modified":1588503643022},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1588501643506},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1588501643526},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1588501643516},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1588501643507},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1588501643219},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1588501643505},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1588501643505},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1588501643526},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1588501643527},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1588501643135},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1588501643133},{"_id":"themes/next/_config.yml","hash":"ab90f5d60e71e863021034c3b035e3a635da965e","modified":1588504627705},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1588501643516},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1588501643506},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1588501643219},{"_id":"themes/next/package.json","hash":"7beb79af6c974bf0397de40b5e581ee8ecd2df34","modified":1588501643517},{"_id":"source/_posts/CF-999E.md","hash":"368ffa44a0ad17046e4b55a15ec79d6bfe6c4baa","modified":1588501643105},{"_id":"source/_posts/APCS-19-06.md","hash":"7d461d6718901c560c242162a18e5f116915c1c7","modified":1588501643093},{"_id":"source/_posts/C-atoi.md","hash":"eee5056041ec4408b3b3571a9bd5980aa55b7f71","modified":1588501643089},{"_id":"source/_posts/CF-920F.md","hash":"ce7b5477678b9c023cab23bc26db6548389568f4","modified":1588501643116},{"_id":"source/_posts/GCJ-2019-QuR.md","hash":"b9f2d8f11dd27508610dca6e991b373d56949ccb","modified":1588501643106},{"_id":"source/_posts/TIOJ-1615.md","hash":"fb5f45a2430374302062a8692c1bd6628e9c3f9c","modified":1588501643114},{"_id":"source/_posts/TIOJ-1795.md","hash":"2eaa4354b42a4fccf7ad4aa07ad3889903863ba9","modified":1588501643083},{"_id":"source/_posts/CFR521.md","hash":"d978ed45de6443f0a318da48d77608e600a96234","modified":1588501643078},{"_id":"source/_posts/TIOJ-1940.md","hash":"f503365db1d28499ba794a92e0fae92e5a5ba3a5","modified":1588501643079},{"_id":"source/_posts/TOJ-391.md","hash":"be8323f7e77d0a37f427e83dcb57fb5d81c0290f","modified":1588501643103},{"_id":"source/_posts/TIOJ-1909.md","hash":"4dcc983cda98a5bbf192f73a1724c0def71e2241","modified":1588501643119},{"_id":"source/_posts/TOJ-365.md","hash":"1fe0be97988c0a2d940606b0dbc9e39d6f8c380a","modified":1588501643099},{"_id":"source/_posts/TOJ-406.md","hash":"7583b73eb18a0c3ed5b0deb31a6a5cecf5e1d2ef","modified":1588501643122},{"_id":"source/_posts/TOJ-407.md","hash":"29d2ba2448171c7f1d37580a8f7d77cd19b79d34","modified":1588501643123},{"_id":"source/_posts/dsu.md","hash":"0fb0050ff84aaee626aac34aa5a42557487b2e8d","modified":1588501643101},{"_id":"source/_posts/TOJ-420.md","hash":"4fd8e2a68e863642742fd1fd94c3cedd39454f89","modified":1588501643073},{"_id":"source/_posts/ncku-icpc-2020-week9-dlc.md","hash":"80d2883bbe366b766d0530802b9458d3c917b6a6","modified":1588503755571},{"_id":"source/_posts/gd-1.md","hash":"b8e29aed865b3d0de9bbb2ac8c552a176d3e0098","modified":1588501643109},{"_id":"source/_posts/itsa-66.md","hash":"2b7e4673aeeacba24614348d8066dbd7a606b2ba","modified":1588501643112},{"_id":"source/_posts/uva00459.md","hash":"1cd92dd988bc3dc9738f131392dcaf18e7afad54","modified":1588501643092},{"_id":"source/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1588503648031},{"_id":"source/about/index.md","hash":"01abb2326a13c0f12ee5bf2d4af915be2262a407","modified":1588501643127},{"_id":"source/tags/index.md","hash":"e415423d44f3fdbb3ee95cde0e2611bda4bc86b7","modified":1588503640015},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1588501643511},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1588501643508},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1588501643512},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1588501643514},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1588501643510},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1588501643511},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1588501643513},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1588501643509},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1588501643512},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1588501643508},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1588501643510},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1588501643514},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1588501643515},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1588501643509},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1588501643513},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1588501643515},{"_id":"themes/next/layout/_layout.swig","hash":"00b5db80898efddb4ac316e2cadbc22464aeb0e7","modified":1588501643156},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1588501643185},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1588501643156},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1588501643165},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1588501643164},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1588501643164},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1588501643147},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1588501643146},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1588501643519},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1588501643518},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1588501643137},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1588501643138},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1588501643136},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643148},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643504},{"_id":"source/_posts/GCJ-2019-QuR/pB.jpg","hash":"6a31730b39a0daa043ef1e7c20890d81107660b4","modified":1588501643068},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1588501643149},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1588501643217},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1588501643217},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1588501643214},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1588501643216},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1588501643215},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1588501643213},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1588501643172},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1588501643177},{"_id":"themes/next/layout/_partials/head.swig","hash":"cea4a1d3e752e4e2f452e4a1b32e407295239e39","modified":1588501643179},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1588501643178},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1588501643180},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1588501643166},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1588501643172},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1588501643160},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1588501643162},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1588501643160},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1588501643199},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1588501643194},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1588501643195},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1588501643200},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1588501643202},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1588501643193},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1588501643194},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1588501643522},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1588501643520},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1588501643525},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1588501643523},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1588501643524},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1588501643524},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1588501643520},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1588501643522},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1588501643521},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1588501643313},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1588501643376},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1588501643380},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1588501643364},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1588501643403},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1588501643378},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1588501643365},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1588501643363},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1588501643398},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1588501643377},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1588501643399},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1588501643396},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1588501643394},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588501643379},{"_id":"themes/next/source/images/logo.jpg","hash":"cb281f7c50893405289386845c1a4a3ebc4d5f51","modified":1588501643395},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1588501643404},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588501643362},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1588501643378},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1588501643397},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1588501643374},{"_id":"source/_posts/APCS-19-06/per.png","hash":"e628aa6994da679d08a53ca74178b54ee021da85","modified":1588501643064},{"_id":"source/_posts/APCS-19-06/score.png","hash":"e8b8a2a474d33a3c3cd16b37ac71b87d910ec848","modified":1588501643063},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643158},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643159},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643355},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643360},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643353},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643312},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643299},{"_id":"themes/next/source/images/avatar.jpg","hash":"31c71e0c94c5616c9609d7a75e59f005499927cf","modified":1588501643393},{"_id":"source/_posts/GCJ-2019-QuR/scb.jpg","hash":"5d227f3bb095d5d1df070511cae7f7045d1b799f","modified":1588501643072},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1588501643170},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1588501643171},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1588501643169},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1588501643168},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1588501643168},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1588501643184},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1588501643182},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1588501643183},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1588501643183},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1588501643163},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1588501643158},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1588501643159},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1588501643207},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1588501643204},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1588501643207},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1588501643204},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1588501643211},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1588501643206},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1588501643203},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1588501643208},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1588501643210},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1588501643205},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1588501643209},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1588501643206},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1588501643202},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1588501643191},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1588501643187},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1588501643191},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1588501643187},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1588501643189},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1588501643190},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1588501643192},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1588501643188},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1588501643189},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1588501643196},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1588501643197},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1588501643196},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1588501643201},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"417dcf5f2bb6ee4a43f744d5ead88f086d7a9e2c","modified":1588501643222},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1588501643354},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1588501643356},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1588501643355},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1588501643302},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1588501643304},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1588501643311},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1588501643306},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1588501643420},{"_id":"themes/next/source/js/src/.affix.js.swp","hash":"acf51c1de7a4af58fca94b7bc7eb65f83a34d3b0","modified":1588501643412},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1588501643417},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1588501643413},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1588501643419},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1588501643409},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1588501643415},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1588501643418},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1588501643416},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1588501643415},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1588501643414},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1588501643418},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1588501643435},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"327241b60270e59cb10af8fc15dbbaa8f538603f","modified":1588501643462},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1588501643436},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1588501643424},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1588501643422},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1588501643423},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1588501643422},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1588501643487},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1588501643489},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1588501643485},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1588501643489},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1588501643487},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1588501643449},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1588501643478},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1588501643477},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1588501643477},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1588501643476},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1588501643478},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1588501643475},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1588501643431},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1588501643430},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1588501643429},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1588501643456},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1588501643454},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1588501643458},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1588501643453},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1588501643458},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1588501643457},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1588501643459},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1588501643452},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1588501643455},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1588501643455},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1588501643452},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1588501643459},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1588501643456},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1588501643451},{"_id":"themes/next/source/lib/reading_progress/.gitignore","hash":"09cde1060b4213a7eee528b54560777d2d3756e8","modified":1588501643502},{"_id":"themes/next/source/lib/reading_progress/.editorconfig","hash":"7d47ecd70ca58d26af4f69ff1b23034edcf4475e","modified":1588501643501},{"_id":"themes/next/source/lib/reading_progress/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1588501643500},{"_id":"themes/next/source/lib/reading_progress/README.md","hash":"9b00c4ce1a739c825df4e51977f7525d2c9f6b81","modified":1588501643502},{"_id":"themes/next/source/lib/reading_progress/package.json","hash":"7bcb3787978a0c445b1bd3dfeca6ae6016c98abc","modified":1588501643503},{"_id":"themes/next/source/lib/reading_progress/reading_progress.js","hash":"174678a8e2a24763e3fe8b9c25496fdf6ee0220b","modified":1588501643503},{"_id":"themes/next/source/lib/reading_progress/reading_progress.min.js","hash":"98af8d99819882904f9b1a9254bebf40602e1843","modified":1588501643501},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1588501643468},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1588501643472},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1588501643468},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1588501643465},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1588501643464},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1588501643463},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1588501643464},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1588501643465},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1588501643448},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1588501643198},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1588501643199},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1588501643263},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1588501643277},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1588501643264},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1588501643266},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1588501643236},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1588501643265},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1588501643276},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"e9eced3913a726945807cc7ad625e7d2caebbe43","modified":1588501643298},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1588501643230},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1588501643230},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1588501643233},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1588501643231},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1588501643234},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1588501643232},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1588501643328},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1588501643345},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1588501643349},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1588501643351},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1588501643352},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1588501643346},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1588501643350},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1588501643344},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1588501643321},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1588501643324},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1588501643325},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1588501643323},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1588501643322},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1588501643335},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1588501643331},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1588501643338},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1588501643330},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1588501643336},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1588501643332},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1588501643407},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1588501643484},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1588501643479},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1588501643460},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/README.md","hash":"bf7819cbb879bb82ec1097513d8f799df8835e0f","modified":1588501643461},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/canvas-nest.min.js","hash":"327241b60270e59cb10af8fc15dbbaa8f538603f","modified":1588501643461},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1588501643441},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1588501643443},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1588501643442},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1588501643440},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1588501643438},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1588501643441},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1588501643439},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1588501643437},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1588501643440},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1588501643426},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1588501643428},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1588501643485},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1588501643486},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1588501643486},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1588501643474},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1588501643474},{"_id":"source/_posts/APCS-19-06/img.jpg","hash":"4a9e925d48c6d56d71d9ed4c5327c51728e45e90","modified":1588501643061},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1588501643480},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1588501643481},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1588501643496},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1588501643494},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1588501643466},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1588501643247},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1588501643296},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1588501643297},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1588501643295},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1588501643294},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1588501643296},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1588501643262},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1588501643261},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1588501643261},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1588501643291},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1588501643292},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1588501643291},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1588501643290},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1588501643289},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1588501643256},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1588501643258},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1588501643257},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1588501643257},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1588501643259},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1588501643254},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1588501643251},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1588501643252},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1588501643249},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1588501643249},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1588501643254},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1588501643253},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1588501643255},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1588501643259},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1588501643250},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1588501643239},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1588501643243},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1588501643241},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1588501643240},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1588501643245},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1588501643242},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1588501643243},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1588501643245},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1588501643244},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1588501643242},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1588501643275},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1588501643269},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1588501643267},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1588501643274},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1588501643271},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1588501643273},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1588501643275},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1588501643269},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1588501643270},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1588501643286},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1588501643279},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1588501643279},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1588501643282},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1588501643278},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1588501643288},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1588501643280},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1588501643286},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1588501643287},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1588501643284},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1588501643342},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1588501643348},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1588501643320},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1588501643481},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1588501643482},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1588501643483},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1588501643483},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1588501643482},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1588501643444},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1588501643446},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1588501643447},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1588501643446},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1588501643444},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1588501643445},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1588501643493},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1588501643498},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1588501643496},{"_id":"themes/next/source/images/Untitled.jpg","hash":"476bb58e9d29819d8449945275ce8419a82cd9eb","modified":1588501643401},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1588501643433},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1588501643491},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1588501643470},{"_id":"themes/next/source/images/background.jpg","hash":"2f648abf68704046b0eaf479d0fad47747541458","modified":1588501643388},{"_id":"themes/next/source/css/_custom/bg.jpg","hash":"f5c48c6489c14c88436ca6732080bce3dc931788","modified":1588501643227},{"_id":"themes/next/source/images/background1.jpg","hash":"10ff46465606f1e410831e1e2e3e6831b2bbb8b8","modified":1588501643372},{"_id":"public/about/index.html","hash":"4c0a34b173c4c2c9e682741ea3914d4739348057","modified":1588504638992},{"_id":"public/tags/index.html","hash":"f03ea3ed457462f325fefe4b8d8125c27376d854","modified":1588504638992},{"_id":"public/archives/2017/index.html","hash":"f70ac16a951662aecc89682e0c8be4bca1f22d3d","modified":1588504638992},{"_id":"public/archives/2017/12/index.html","hash":"0c0ffd8da1fa4bb7d82e0d8370380a769761ecbb","modified":1588504638992},{"_id":"public/archives/2018/page/2/index.html","hash":"77d0faebb8e5a3695b4f444c98351fc14db2b309","modified":1588504638992},{"_id":"public/archives/2018/01/index.html","hash":"d81433c8c926fc7d9f63dba0fee5c5bb5ebc4eb7","modified":1588504638992},{"_id":"public/archives/2018/02/index.html","hash":"04b043cb05b97f59b198336119c8e8417d1a02d6","modified":1588504638992},{"_id":"public/archives/2018/04/index.html","hash":"93db5e8d844462f2db5ffc5f18b7e9c5e67102ea","modified":1588504638992},{"_id":"public/archives/2018/07/index.html","hash":"dbbe74e97dccfcf9c2365bce4801ff797e2f42a9","modified":1588504638992},{"_id":"public/archives/2018/08/index.html","hash":"2619e41e2a4e3d784f985969b35c1576c06583a9","modified":1588504638992},{"_id":"public/archives/2018/09/index.html","hash":"2e808d70177e457d8a34c196960427278991bc2a","modified":1588504638992},{"_id":"public/archives/2018/10/index.html","hash":"caaf059eef022f15c430021df58b814b7bb207f1","modified":1588504638992},{"_id":"public/archives/2018/11/index.html","hash":"2c884a746caf3f217a9f3b8c7f2a9d7bb29ea5d0","modified":1588504638992},{"_id":"public/archives/2019/01/index.html","hash":"72fb06dee1a67d63fce90237fd9f36e075acce79","modified":1588504638992},{"_id":"public/archives/2019/04/index.html","hash":"95083906724d950fd0880a44cfc2e9e710bbbae3","modified":1588504638992},{"_id":"public/archives/2019/06/index.html","hash":"d265de4529f9109dec9ab188730b849868dbb301","modified":1588504638992},{"_id":"public/archives/2019/09/index.html","hash":"811c443d1e91de60cf03f224b42ac337a1d318a9","modified":1588504638992},{"_id":"public/archives/2019/11/index.html","hash":"1158356f7fdbf61d924fd3b2f21893c4cdfcdbdd","modified":1588504638992},{"_id":"public/archives/2020/index.html","hash":"15ec359ad85ca1148e22f6fa1abeb0030b45ea6f","modified":1588504638992},{"_id":"public/archives/2020/05/index.html","hash":"8f864f90bbe76db4a83b9ac138e3a32506cc0daa","modified":1588504638992},{"_id":"public/tags/CodeForces/index.html","hash":"8d611ddde9cfd0d5f47b060356f98597169ccbf8","modified":1588504638992},{"_id":"public/tags/div-3/index.html","hash":"3223741b6a1186cbbae88db671fcc5204cb23189","modified":1588504638992},{"_id":"public/tags/graph/index.html","hash":"0b97c85ab3d27ff4b42a810bfc01f5b7394e092e","modified":1588504638992},{"_id":"public/tags/dfs/index.html","hash":"5c735d1ffc35523a9a8f8da1ae222446f1c51731","modified":1588504638992},{"_id":"public/tags/APCS/index.html","hash":"11fdac7ab851b2032ba7f9515fad1d972c692aca","modified":1588504638992},{"_id":"public/tags/Full-Contest-Solution/index.html","hash":"fd7d274c7f1cca7e0df0bcd07c05065674222845","modified":1588504638992},{"_id":"public/tags/C/index.html","hash":"831cad211a8c34d4d81afb6340bc4a34911e2c61","modified":1588504638992},{"_id":"public/tags/Education-Round/index.html","hash":"c175c254e586c88936ff00f4fcff483b21db98df","modified":1588504638992},{"_id":"public/tags/segment-tree/index.html","hash":"f53fe1694a62e13a8d6df75229ea00668672e681","modified":1588504638992},{"_id":"public/tags/data-structure/index.html","hash":"68b1064c799314c421804dd18fbc6353e2e15444","modified":1588504638992},{"_id":"public/tags/GCJ/index.html","hash":"0d688fd7a5505b473394dbe08945fd75688c2892","modified":1588504638992},{"_id":"public/tags/TIOJ/index.html","hash":"84c65f2ec4707d48c62ec611bd1f247061999b64","modified":1588504638992},{"_id":"public/tags/math/index.html","hash":"9bc1804889a73ce418c6ef640a152d3ec9ef680d","modified":1588504638992},{"_id":"public/tags/dp/index.html","hash":"c648a8d151b0b3feaae6fa8b363f38163d2d60ed","modified":1588504638992},{"_id":"public/tags/TOJ/index.html","hash":"ba32540cec4bf2c3b1a74488016d388673898962","modified":1588504638992},{"_id":"public/tags/ZJ/index.html","hash":"96baedb7dae2906a80750955ace2b14755b552d7","modified":1588504638992},{"_id":"public/tags/全國賽/index.html","hash":"a8e032167e1f0e5d828582de62afc86c2b42d77f","modified":1588504638992},{"_id":"public/tags/dsu/index.html","hash":"4eda02ad87c8acf7e2d5f374a5f01767d3013267","modified":1588504638992},{"_id":"public/tags/disjoint-set/index.html","hash":"7250cd19ab4665224002c88b6c079360c7187d73","modified":1588504638992},{"_id":"public/tags/MST/index.html","hash":"cfc87cc767b9a6fbb6d231885771028ec2d44994","modified":1588504638992},{"_id":"public/tags/樹直徑/index.html","hash":"52b7e957114cacc3515c714d2545f7c42c776885","modified":1588504638992},{"_id":"public/tags/Kruskal/index.html","hash":"2497260277b6905dcc9c084209dd221949bc85bd","modified":1588504638992},{"_id":"public/tags/Data-Structure/index.html","hash":"d5ff321fa4f3111b5842ffee9e5fba0633645a0c","modified":1588504638992},{"_id":"public/tags/Segment-Tree/index.html","hash":"a156ce712333ccecec268046fc489c89770eb837","modified":1588504638992},{"_id":"public/tags/Golang/index.html","hash":"7a2f3571ae4aa1c93699075fd8b5ad1135b17d28","modified":1588504638992},{"_id":"public/tags/ITSA/index.html","hash":"1b3b362fa2d75360629f0bbdea42cd913f8c8c67","modified":1588504638992},{"_id":"public/tags/UVa/index.html","hash":"53e997d9d753b6b70969373bd1ade3e18cd3e047","modified":1588504638992},{"_id":"public/ncku-icpc-2020-week9-dlc/index.html","hash":"0352a17e3fe24a643732bf36291a0a65658e9d2b","modified":1588504638992},{"_id":"public/gd-1/index.html","hash":"1da2ea6fb01d3ca8c8142a203ec021c852cf46c3","modified":1588504638992},{"_id":"public/C-atoi/index.html","hash":"2476cf40268cece96d15881943eb70bd7a59ca61","modified":1588504638992},{"_id":"public/APCS-19-06/index.html","hash":"e18d2546de2f35d84e21a84946f9e38199fe014d","modified":1588504638992},{"_id":"public/GCJ-2019-QuR/index.html","hash":"f47c7fc868f33411013ddad4768914df0fc249c8","modified":1588504638992},{"_id":"public/TIOJ-1909/index.html","hash":"889c3bef0a5dcd1f408ac19d2f4a5921980c8f21","modified":1588504638992},{"_id":"public/CFR521/index.html","hash":"5853970bb9c71ee8c1a6cf2eb78408200c82c2c0","modified":1588504638992},{"_id":"public/TIOJ-1615/index.html","hash":"af4b38e45284ada1cb81b5a2a8501336d8e44ede","modified":1588504638992},{"_id":"public/itsa-66/index.html","hash":"710e15d7bfb8409c5d80b496e1cf25c4c088a8dd","modified":1588504638992},{"_id":"public/dsu/index.html","hash":"292190b59d8dcef8412713675af3bfe4603387d3","modified":1588504638992},{"_id":"public/TOJ-420/index.html","hash":"cb9947433b8558a4ed69b075a44c970500fa52cd","modified":1588504638992},{"_id":"public/TOJ-407/index.html","hash":"42bd535348ca3e7cc2c315947f7abe753f3d2da6","modified":1588504638992},{"_id":"public/CF-999E/index.html","hash":"a9270889b83c899376429017e609e9982efb0ee7","modified":1588504638992},{"_id":"public/TOJ-406/index.html","hash":"3b3967a414ccc1a2013b3eb9d1b4019eebc228d1","modified":1588504638992},{"_id":"public/CF-920F/index.html","hash":"f896ec07cfdf14ea05d857ce57fb73a8af5b8b8d","modified":1588504638992},{"_id":"public/TOJ-391/index.html","hash":"53169d284eb4efa20c31125fd31c5cead8e2f7e2","modified":1588504638992},{"_id":"public/TIOJ-1795/index.html","hash":"67e9aa950089d342b8949192a11de5b1fb186c1b","modified":1588504638992},{"_id":"public/uva00459/index.html","hash":"b9187a4e574cd33b1e096c2ad053c6e6979cf18b","modified":1588504638992},{"_id":"public/TOJ-365/index.html","hash":"285fe94621944f44fb58b12c0768bc30bd5b80f0","modified":1588504638992},{"_id":"public/TIOJ-1940/index.html","hash":"cd364bfc53e1648afd5dd64ded7f6222a44acd6b","modified":1588504638992},{"_id":"public/archives/index.html","hash":"285b275ea6981997c4449d5e8ee437803f1761e9","modified":1588504638992},{"_id":"public/archives/page/2/index.html","hash":"96b49422cdf2781d8bf212d4d6c7256c4d828e1f","modified":1588504638992},{"_id":"public/archives/2018/index.html","hash":"d66abfee03d2b0be204936f2fe872433e67f3f65","modified":1588504638992},{"_id":"public/archives/2019/index.html","hash":"c69eb007e33a5535fe7c028b1a4de5f4b5752a74","modified":1588504638992},{"_id":"public/index.html","hash":"b6050c602294b3ceeba70ae915cbc3fa25470a63","modified":1588504638992},{"_id":"public/page/2/index.html","hash":"98d96e18c83c1b8b73fdb23f58fc04331bc95561","modified":1588504638992},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1588504638992},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1588504638992},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1588504638992},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1588504638992},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1588504638992},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1588504638992},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1588504638992},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1588504638992},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1588504638992},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1588504638992},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1588504638992},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1588504638992},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588504638992},{"_id":"public/images/logo.jpg","hash":"cb281f7c50893405289386845c1a4a3ebc4d5f51","modified":1588504638992},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1588504638992},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588504638992},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1588504638992},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1588504638992},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1588504638992},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1588504638992},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1588504638992},{"_id":"public/lib/reading_progress/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1588504638992},{"_id":"public/lib/canvas-nest/theme-next-canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1588504638992},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1588504638992},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1588504638992},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1588504638992},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1588504638992},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1588504638992},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1588504638992},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1588504638992},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1588504638992},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1588504638992},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1588504638992},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1588504638992},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1588504638992},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1588504638992},{"_id":"public/GCJ-2019-QuR/pB.jpg","hash":"6a31730b39a0daa043ef1e7c20890d81107660b4","modified":1588504638992},{"_id":"public/css/blog-encrypt.css","hash":"22e25b0d16ea053d25eb971e038c817a4c9cb584","modified":1588504638992},{"_id":"public/lib/blog-encrypt.js","hash":"91fda12d550323056762c5408623eb8a1d201ecc","modified":1588504638992},{"_id":"public/images/avatar.jpg","hash":"31c71e0c94c5616c9609d7a75e59f005499927cf","modified":1588504638992},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1588504638992},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1588504638992},{"_id":"public/APCS-19-06/per.png","hash":"e628aa6994da679d08a53ca74178b54ee021da85","modified":1588504638992},{"_id":"public/APCS-19-06/score.png","hash":"e8b8a2a474d33a3c3cd16b37ac71b87d910ec848","modified":1588504638992},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1588504638992},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1588504638992},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1588504638992},{"_id":"public/lib/reading_progress/package.json","hash":"e404a0bdf26df62eb89173c6fe5f5824345801c5","modified":1588504638992},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1588504638992},{"_id":"public/js/src/affix.js","hash":"a566ac01a6495a5b0f0a0df749ddd302d78b8cd3","modified":1588504638992},{"_id":"public/js/src/algolia-search.js","hash":"2d6d8b7a6f14257feabc958d0f9581463e4bd0bf","modified":1588504638992},{"_id":"public/js/src/bootstrap.js","hash":"de54dc65bc9f2cd010b490f184ceb6768f374553","modified":1588504638992},{"_id":"public/js/src/exturl.js","hash":"893a00f8f101868328cbcfc0daa1e9623795a3fd","modified":1588504638992},{"_id":"public/js/src/hook-duoshuo.js","hash":"087fd27802ee6bf67ee1726c8e4d29c4a8ee1cfd","modified":1588504638992},{"_id":"public/js/src/js.cookie.js","hash":"833401af430cf3dedc522c8ad5be8e9b7b93f5b3","modified":1588504638992},{"_id":"public/js/src/motion.js","hash":"dd27b305a4afc0842a4292e1cd953fe08b253570","modified":1588504638992},{"_id":"public/js/src/post-details.js","hash":"4be536f2641c50a046492848310f3a2a8fbcfacb","modified":1588504638992},{"_id":"public/js/src/scroll-cookie.js","hash":"8ecd74fccf04be180767a54bb1590866991fdab3","modified":1588504638992},{"_id":"public/js/src/scrollspy.js","hash":"c018f3e00b5e2dcaf12ff15e57234bf352f1a41d","modified":1588504638992},{"_id":"public/js/src/utils.js","hash":"e1b85be7e3a95de00ce029445c5ba990cd575415","modified":1588504638992},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1588504638992},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"b14d7a2903d9a4b067b52be7546767e5baeb45fe","modified":1588504638992},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"327241b60270e59cb10af8fc15dbbaa8f538603f","modified":1588504638992},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"aa88d8f0ea7dfc1ebcf362b5b1af1bbe9b00d37a","modified":1588504638992},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"821c6e459f3b5b1a66ffa6751ed5cb43ee860160","modified":1588504638992},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"4e7e86b602a16551c3c29cae2d1782d47a075ed8","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1588504638992},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1588504638992},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1588504638992},{"_id":"public/lib/reading_progress/reading_progress.js","hash":"c744d5950e019f3c26b7bde525b2ce870dd3a5c8","modified":1588504638992},{"_id":"public/lib/reading_progress/reading_progress.min.js","hash":"98af8d99819882904f9b1a9254bebf40602e1843","modified":1588504638992},{"_id":"public/lib/velocity/velocity.ui.js","hash":"4d473a78e1cd7c173f7db41386b0b4b51fcb7883","modified":1588504638992},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1588504638992},{"_id":"public/js/src/schemes/pisces.js","hash":"7df63d5dd00693eec061551de3a0338100e2289a","modified":1588504638992},{"_id":"public/lib/canvas-nest/theme-next-canvas-nest/canvas-nest.min.js","hash":"327241b60270e59cb10af8fc15dbbaa8f538603f","modified":1588504638992},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"2dfb374df617fca9c311d5e12ad195ac9f944c31","modified":1588504638992},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1588504638992},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1588504638992},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a3b15c9ccdbe8527f860604fd14504dd75cdefd9","modified":1588504638992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"bca0081462c24516d8df4a8438042800bd9534f7","modified":1588504638992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"5d73ab6f5d8b59050130c4a53f2e8a3c0619b117","modified":1588504638992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"90fbe9d2713d9ed677d0a96a9f258789e6d55527","modified":1588504638992},{"_id":"public/lib/fastclick/README.html","hash":"d1f3edc67c27983b2c9597737a86b4e83e93f722","modified":1588504638992},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"6748af31569d53de1fa842cc7f9c4c2a89cda375","modified":1588504638992},{"_id":"public/lib/jquery_lazyload/README.html","hash":"564ac61cf1b7e17717389bf2c0ddf8ce5296a47a","modified":1588504638992},{"_id":"public/lib/reading_progress/README.html","hash":"5e3f473b2f2874746b13dfd6cc0b649d4e722b78","modified":1588504638992},{"_id":"public/lib/canvas-nest/theme-next-canvas-nest/README.html","hash":"f65c8de337173f6bf625e13df348ad24ec94ddf5","modified":1588504638992},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1588504638992},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1588504638992},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1588504638992},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1588504638992},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1588504638992},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1588504638992},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1588504638992},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1588504638992},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"85f747f815c0323af1277c4463f12cd4aef312f7","modified":1588504638992},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1588504638992},{"_id":"public/lib/Han/dist/han.js","hash":"1bb1ae25e4d430304a0f1de8ca614583cadb3630","modified":1588504638992},{"_id":"public/lib/velocity/velocity.js","hash":"5ff0bd9134f8ea426603e886cea2715d4a7be436","modified":1588504638992},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1588504638992},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1588504638992},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1588504638992},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1588504638992},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1588504638992},{"_id":"public/GCJ-2019-QuR/scb.jpg","hash":"5d227f3bb095d5d1df070511cae7f7045d1b799f","modified":1588504638992},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588504638992},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"0bc8a5be3420f976eedc482759d74fb0d57776fc","modified":1588504638992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"2c764afd2b7c2b247451c7e2a7791a491636968e","modified":1588504638992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"f5d4f528bc7e0c559358fe699447e5fcdb84e43e","modified":1588504638992},{"_id":"public/css/main.css","hash":"0eee9e85d75c06571ca1b4a76f592809b050e6d2","modified":1588504638992},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c29d71b6d18bff5f9d25e3e4ad92e0ebacd56659","modified":1588504638992},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"daebf346b7028eb5cc8d9fcfe80c653dbc3fcb84","modified":1588504638992},{"_id":"public/lib/Han/dist/han.css","hash":"b7782e10fe9fef7b1fb9c0baafc0c86ae99a2098","modified":1588504638992},{"_id":"public/APCS-19-06/img.jpg","hash":"4a9e925d48c6d56d71d9ed4c5327c51728e45e90","modified":1588504638992},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1588504638992},{"_id":"public/images/Untitled.jpg","hash":"476bb58e9d29819d8449945275ce8419a82cd9eb","modified":1588504638992},{"_id":"public/images/background.jpg","hash":"2f648abf68704046b0eaf479d0fad47747541458","modified":1588504638992},{"_id":"public/images/background1.jpg","hash":"10ff46465606f1e410831e1e2e3e6831b2bbb8b8","modified":1588504638992}],"Category":[],"Data":[],"Page":[{"title":"MiohitoKiri547 - About Me","date":"2018-08-18T05:54:59.000Z","_content":"\n原高中資訊競賽選手（不過成績很爛）\n現任成大資工學生（不過快要被二一了）\n同時為成大競技程式設計的課程助教（不過快要爆肝寫不出講義了）\n\n開始淡出競賽圈，不過還是會偶爾寫一些競程相關的文章\n\n未來可能會開始慢慢增加其他方面的文章\n\n如果有需要聯絡的歡迎寫信到我的email: lltzpp@gmail.com","source":"about/index.md","raw":"---\ntitle: 'MiohitoKiri547 - About Me'\ndate: 2018-08-18 13:54:59\n---\n\n原高中資訊競賽選手（不過成績很爛）\n現任成大資工學生（不過快要被二一了）\n同時為成大競技程式設計的課程助教（不過快要爆肝寫不出講義了）\n\n開始淡出競賽圈，不過還是會偶爾寫一些競程相關的文章\n\n未來可能會開始慢慢增加其他方面的文章\n\n如果有需要聯絡的歡迎寫信到我的email: lltzpp@gmail.com","updated":"2020-05-03T10:27:23.127Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck9qyndpr0001f19p5cav0tjz","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>原高中資訊競賽選手（不過成績很爛）<br>現任成大資工學生（不過快要被二一了）<br>同時為成大競技程式設計的課程助教（不過快要爆肝寫不出講義了）</p><p>開始淡出競賽圈，不過還是會偶爾寫一些競程相關的文章</p><p>未來可能會開始慢慢增加其他方面的文章</p><p>如果有需要聯絡的歡迎寫信到我的email: <a href=\"mailto:lltzpp@gmail.com\">lltzpp@gmail.com</a></p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"","more":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>原高中資訊競賽選手（不過成績很爛）<br>現任成大資工學生（不過快要被二一了）<br>同時為成大競技程式設計的課程助教（不過快要爆肝寫不出講義了）</p><p>開始淡出競賽圈，不過還是會偶爾寫一些競程相關的文章</p><p>未來可能會開始慢慢增加其他方面的文章</p><p>如果有需要聯絡的歡迎寫信到我的email: <a href=\"mailto:lltzpp@gmail.com\">lltzpp@gmail.com</a></p><!-- rebuild by neat -->"},{"title":"tags","date":"2020-05-03T11:00:39.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-05-03 19:00:39\n---\n","updated":"2020-05-03T11:00:40.015Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck9qyndpz0003f19pcbm3e7o9","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"","more":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><!-- rebuild by neat -->"}],"Post":[{"title":"[CF][999E] E. REACHABILITY FROM THE CAPITAL","date":"2018-08-03T14:47:34.000Z","_content":"\n## 題目 + 解法\n\n這是 CodeForces Round 490 div.3 的題目\n最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人\n沒有意外下一場應該就會下來了吧\n先放上題目[連結](http://codeforces.com/problemset/problem/999/E)\n<!--more-->\n\n會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下\n今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）\n\n講一下題目大意好了\n首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$\n求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）\n\n有個很直觀的想法如下，首先點會先被分成兩種類型：\n1. 這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過\n2. 沒有經過的點（從 $S$ 出發到達不了）\n\n所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？\n（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\n#define maxN 5005\n\nvector < int > edges[maxN];\nint pa[maxN];\nbool used[maxN];\n\nvoid dfs ( int n, int p ){\n    used[n] = true;\n    pa[n] = p;\n    for ( auto i: edges[n] ){\n        if ( used[i] )\n            continue;\n        dfs ( i, p );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, s, u, v;\n    cin >> n >> m >> s;\n    while ( m-- ){\n        cin >> u >> v;\n        edges[u].push_back ( v );\n    }\n\n    dfs ( s, s );\n    for ( int i = 1 ; i <= n ; i++ ){\n        if ( pa[i] == 0 ){\n            memset ( used, 0, sizeof used );\n            dfs ( i, i );\n        }\n    }\n\n    set < int > lib;\n    for ( int i = 1 ; i <= n ; i++ ){\n        if ( pa[i] != s )\n            lib.insert ( pa[i] );\n    }\n\n    cout << lib.size() << '\\n';\n}\n```\n\n## tips\n\n可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？\n\n是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？\n\n又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到\n所以即便 pa 被覆寫了也是沒有關係的","source":"_posts/CF-999E.md","raw":"---\ntitle: '[CF][999E] E. REACHABILITY FROM THE CAPITAL'\ndate: 2018-08-03 22:47:34\ntags:\n - CodeForces\n - div.3\n - graph\n - dfs\n---\n\n## 題目 + 解法\n\n這是 CodeForces Round 490 div.3 的題目\n最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人\n沒有意外下一場應該就會下來了吧\n先放上題目[連結](http://codeforces.com/problemset/problem/999/E)\n<!--more-->\n\n會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下\n今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）\n\n講一下題目大意好了\n首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$\n求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）\n\n有個很直觀的想法如下，首先點會先被分成兩種類型：\n1. 這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過\n2. 沒有經過的點（從 $S$ 出發到達不了）\n\n所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？\n（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\n#define maxN 5005\n\nvector < int > edges[maxN];\nint pa[maxN];\nbool used[maxN];\n\nvoid dfs ( int n, int p ){\n    used[n] = true;\n    pa[n] = p;\n    for ( auto i: edges[n] ){\n        if ( used[i] )\n            continue;\n        dfs ( i, p );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, s, u, v;\n    cin >> n >> m >> s;\n    while ( m-- ){\n        cin >> u >> v;\n        edges[u].push_back ( v );\n    }\n\n    dfs ( s, s );\n    for ( int i = 1 ; i <= n ; i++ ){\n        if ( pa[i] == 0 ){\n            memset ( used, 0, sizeof used );\n            dfs ( i, i );\n        }\n    }\n\n    set < int > lib;\n    for ( int i = 1 ; i <= n ; i++ ){\n        if ( pa[i] != s )\n            lib.insert ( pa[i] );\n    }\n\n    cout << lib.size() << '\\n';\n}\n```\n\n## tips\n\n可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？\n\n是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？\n\n又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到\n所以即便 pa 被覆寫了也是沒有關係的","slug":"CF-999E","published":1,"updated":"2020-05-03T10:27:23.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndpk0000f19pe238gjai","content":"<!-- build time:Sun May 03 2020 19:17:22 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 + 解法</h2><p>這是 CodeForces Round 490 div.3 的題目<br>最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人<br>沒有意外下一場應該就會下來了吧<br>先放上題目<a href=\"http://codeforces.com/problemset/problem/999/E\" target=\"_blank\" rel=\"noopener\">連結</a></p><a id=\"more\"></a><p>會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下<br>今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）</p><p>講一下題目大意好了<br>首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$<br>求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）</p><p>有個很直觀的想法如下，首先點會先被分成兩種類型：</p><ol><li>這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過</li><li>沒有經過的點（從 $S$ 出發到達不了）</li></ol><p>所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？<br>（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 5005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> pa[maxN];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> used[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    used[n] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    pa[n] = p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( used[i] )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs ( i, p );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, s, u, v;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        edges[u].push_back ( v );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs ( s, s );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( pa[i] == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">memset</span> ( used, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> used );</span><br><span class=\"line\">            dfs ( i, i );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( pa[i] != s )</span><br><span class=\"line\">            lib.insert ( pa[i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; lib.size() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"tips\"><a class=\"header-anchor\" href=\"#tips\"></a>tips</h2><p>可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？</p><p>是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？</p><p>又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到<br>所以即便 pa 被覆寫了也是沒有關係的</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:22 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 + 解法</h2><p>這是 CodeForces Round 490 div.3 的題目<br>最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人<br>沒有意外下一場應該就會下來了吧<br>先放上題目<a href=\"http://codeforces.com/problemset/problem/999/E\" target=\"_blank\" rel=\"noopener\">連結</a></p>","more":"<p>會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下<br>今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）</p><p>講一下題目大意好了<br>首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$<br>求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）</p><p>有個很直觀的想法如下，首先點會先被分成兩種類型：</p><ol><li>這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過</li><li>沒有經過的點（從 $S$ 出發到達不了）</li></ol><p>所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？<br>（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 5005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> pa[maxN];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> used[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    used[n] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    pa[n] = p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( used[i] )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs ( i, p );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, s, u, v;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        edges[u].push_back ( v );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs ( s, s );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( pa[i] == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">memset</span> ( used, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> used );</span><br><span class=\"line\">            dfs ( i, i );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( pa[i] != s )</span><br><span class=\"line\">            lib.insert ( pa[i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; lib.size() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"tips\"><a class=\"header-anchor\" href=\"#tips\"></a>tips</h2><p>可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？</p><p>是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？</p><p>又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到<br>所以即便 pa 被覆寫了也是沒有關係的</p><!-- rebuild by neat -->"},{"title":"[APCS] 2019年六月場實作題詳解","date":"2019-06-24T09:44:23.000Z","_content":"\n## 前言\n\n因為想要拼5 + 5，於是又報名了這次的APCS\n至於成績如何那就晚點再說吧，算是個小伏筆（？\n\n<!--more-->\n\n即便考場在家附近，我還是提早出門了\n還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎\n趕快google一下才發現跑錯棚了，應該是在校區的另一邊\n所以我又趕快跑過去，差一點點遲到\n好險有提早出門（汗\n\n{% asset_img img.jpg \"因為不想要縮圖是我的成績單，所以我就放這張圖了\" %}\n\n## problem 1\n\n### 題目\n\n給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節\n求出主場最終的輸贏\n\n1.  兩場全贏：勝\n2.  兩場全敗：敗\n3.  一勝一敗：平手\n\n保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題\n\n### 解法\n\n直接實作一下就好了\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int a = 0, b = 0, ans = 0, swp;\n    for ( int i = 0 ; i < 4 ; i++ ){\n        cin >> swp;\n        a += swp;\n    }\n    for ( int i = 0 ; i < 4 ; i++ ){\n        cin >> swp;\n        b += swp;\n    }\n    ans += ( a > b ? 1 : -1 );\n\n\n    a = b = 0;\n    for ( int i = 1 ; i < 4 ; i++ ){\n        cin >> swp;\n        a += swp;\n    }\n    for ( int i = 1 ; i < 4 ; i++ ){\n        cin >> swp;\n        b += swp;\n    }\n    ans += ( a > b ? 1 : -1 );\n\n    if ( !ans )\n        cout << \"Draw\";\n    else if ( ans > 0 )\n        cout << \"Win\";\n    else\n        cout << \"Lose\";\n    cout << '\\n';\n}\n```\n\n## problem 2\n\n### 題目\n\n給定一張圖，起點為整張圖權重最小的點\n並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點\n然後路徑上點不能重複\n求出路徑的總權重\n\n### 解法\n\ndfs裸題，UVa有類似的題目（題號我忘記了\n反正就是模擬一次就對了（也沒有其他解法啊(ry\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 105; // 大小我忘記了\nconst int INF = 0x3f3f3f3f; // INF大於值域，又可直接memset，方便又實用\ntypedef long long LL;\n\nint mp[maxN][maxN];\n\nLL dfs ( int x, int y, LL sum ){\n    // 先找出最低點\n    int mi = min ( min ( mp[x + 1][y], mp[x - 1][y] ), min ( mp[x][y + 1], mp[x][y - 1] ) );\n    sum += mp[x][y];\n    mp[x][y] = INF;\n    if ( mi == INF )\n        return sum;\n    if ( mp[x + 1][y] == mi )\n        return dfs ( x + 1, y, sum );\n    if ( mp[x - 1][y] == mi )\n        return dfs ( x - 1, y, sum );\n    if ( mp[x][y + 1] == mi )\n        return dfs ( x, y + 1, sum );\n    if ( mp[x][y - 1] == mi )\n        return dfs ( x, y - 1, sum );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, x, y, mi = INF;\n    memset ( mp, INF, sizeof mp );\n    cin >> n >> m;\n    // 1 index，可以直接免去判斷邊界的麻煩\n    for ( int i = 1 ; i <= n ; i++ )\n        for ( int j = 1 ; j <= m ; j++ ){\n            cin >> mp[i][j];\n            if ( mi > mp[i][j] )\n                mi = mp[i][j], x = i, y = j;\n        }\n\n    cout << dfs ( x, y, 0 ) << '\\n';\n}\n```\n\n\n## problem 3\n\n### 題目\n\n給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始\n請求出每一對可以組成互補字串的數量\n且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列\n所以$AAB$與$AB$與$BA$都是相同的字串\n\n#### 定義一下互補字串\n\n假設字串$A$中的元素沒有出現在字串$B$中\n同時，字串$B$的元素也沒有出現在字串$A$中\n則稱$A \\text& B$為互補字串\n\n### 解法\n\n#### 解法一：硬幹\n\n##### 說明\n\n之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的\n\n##### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n#define F first\n#define S second\n\nusing namespace std;\n\nmap < string, int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    string str, basic;\n    char c = 'A';\n    cin >> n >> m;\n    for ( int i = 0 ; i < m ; i++, c++ )\n        basic += c;\n    while ( n-- ){\n        cin >> str;\n        // 這邊為了要把順序都統一，所以先做一下排序\n        sort ( str.begin(), str.end() );\n        // 這邊則是要把重複的字元壓掉\n        str.erase ( unique ( str.begin(), str.end() ), str.end() );\n        lib[str]++;\n    }\n\n    for ( auto j: lib ){\n        str = basic;\n        // 把出現過的直接刪掉\n        for ( auto i: j.F )\n            str.erase ( lower_bound ( str.begin(), str.end(), i ) );\n        ans += j.S * lib[str];\n    }\n\n    // 因為會重複計算到兩次    \n    ans /= 2;\n    cout << ans << '\\n';\n}\n```\n\n#### 方法二：Xor\n\n##### 說明\n\n因為原本的方法太智障了（？\n如果不是因為資料量小可以這樣做，資料量一大直接吃土\n\n出來之後聽到有人是這樣做的，有點類似Hash的做法\n把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$\n然後為了方便運算會把這個二進位reverse\n\n也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$\n然後再把二進位轉成十進位\n這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串\n\n##### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n#define F first\n#define S second\n\nusing namespace std;\n\nmap < int, int > lib;\n\ninline int translate ( string str ){\n    int res = 0;\n    for ( auto i: str )\n        res |= ( 1 << ( i - 'A' ) );\n\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0, ori = 0;\n    string str;\n    cin >> n >> m;\n    for ( int i = 0 ; i < m ; i++ )\n        ori |= ( 1 << i );\n    while ( n-- ){\n        cin >> str;\n        // 這邊為了要把順序都統一，所以先做一下排序\n        sort ( str.begin(), str.end() );\n        // 這邊則是要把重複的字元壓掉\n        str.erase ( unique ( str.begin(), str.end() ), str.end() );\n        lib[translate ( str )]++;\n    }\n\n    for ( auto j: lib )\n        ans += ( j.S * lib[ori ^ j.F] );\n\n    // 因為會重複計算到兩次    \n    ans >>= 1;\n    cout << ans << '\\n';\n}\n```\n**注意，這份code並沒有經過詳細測試，可能有誤**\n\n\n## problem 4\n\n### 題目\n\n給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量\n\n### 解法\n\nSlide Window裸題，不過關於實作又有兩種做法\n\n#### 方法一：固定Window大小\n\n把window大小固定為$M$，並且開一個set紀錄這個window的數字\n要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過\n然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了\n\n#### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 100005;\n\nint cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    cin >> n >> m;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    // 離散化\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    for ( auto &i: data )\n        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();\n\n    queue < int > q;\n    set < int > s;\n    for ( int i = 0 ; i < n ; i++ ){\n        q.push ( data[i] );\n        s.insert ( data[i] );\n        cnt[data[i]]++;\n        if ( q.size() >= m ){\n            cnt[q.front()]--;\n            if ( !cnt[q.front()] )\n                s.erase ( q.front() );\n            q.pop();\n        }\n        if ( s.size() == m )\n            ans++;\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n#### 方法二：不固定的window大小\n\n此方法由吳邦一教授提出（[原文連結](https://brian.su/r/APCS-2019-06-P4)）\n由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止\n\n#### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 100005;\n\nint cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    cin >> n >> m;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    // 離散化\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    for ( auto &i: data )\n        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();\n\n    // 這邊的話就不用set了    \n    queue < int > q;\n    for ( int i = 0 ; i < n ; i++ ){\n        // 不斷pop直到這個數字前面沒有出現過\n        while ( !q.empty() && cnt[data[i]] ){\n            cnt[q.front()]--;\n            q.pop();\n        }\n        q.push ( data[i] );\n        cnt[data[i]]++;\n        if ( q.size() == m )\n            ans++;\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n\n## 後記\n\n其實我把所有題目寫完之後，大概才過41分鐘\n然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug\n接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到\n也就是說，我在裡面燒機燒了一個半小時然後產量是零\n抓到，澪人桐是燒機大師\n早就知道出來玩手機算了 = =\n\n.\n\n看到這邊多多少少都會對我的成績有點興趣吧（？\n（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛\n話不多說我直接上圖好了\n\n![](score.png)\n\n差一題觀念5+5\n搞什麼 = =\n\n以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼\n（欸，差不多是一年前的六月場欸OAO\n\n雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜\n那麼今天就到這邊了，謝謝各位今天的閱讀\n如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我\n我的email可以在我的[個人頁面](https://miohitokiri5474.github.io/code/about/)找到\np.s. 我今天寫好長的文章喔，到這邊已經430行了\n\n本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行\n所以原本的文章看起來很很空\n還需要自己手動調整，有點小麻煩\n不過他可以即時顯示md的渲染結果，真的讓人難以抉擇\n\n## 更新（2019/07/04 10:28）\n\n之前可以查詢成績好像是bug，官方是說今天早上十點才可以查\n剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）\n\n{% asset_img per.png \"2019年六月場級距\" %}\n\n## 圖片出處\n1. 紅色鳥居：神奈川縣蘆之湖[kaji_nori06](https://www.instagram.com/kaji_nori06/)\n2. 成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧\n3. 級距。。。啊就從成績單上截圖截下來的啊 = =","source":"_posts/APCS-19-06.md","raw":"---\ntitle: '[APCS] 2019年六月場實作題詳解'\ndate: 2019-06-24 17:44:23\ntags:\n - APCS\n - Full Contest Solution\n---\n\n## 前言\n\n因為想要拼5 + 5，於是又報名了這次的APCS\n至於成績如何那就晚點再說吧，算是個小伏筆（？\n\n<!--more-->\n\n即便考場在家附近，我還是提早出門了\n還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎\n趕快google一下才發現跑錯棚了，應該是在校區的另一邊\n所以我又趕快跑過去，差一點點遲到\n好險有提早出門（汗\n\n{% asset_img img.jpg \"因為不想要縮圖是我的成績單，所以我就放這張圖了\" %}\n\n## problem 1\n\n### 題目\n\n給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節\n求出主場最終的輸贏\n\n1.  兩場全贏：勝\n2.  兩場全敗：敗\n3.  一勝一敗：平手\n\n保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題\n\n### 解法\n\n直接實作一下就好了\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int a = 0, b = 0, ans = 0, swp;\n    for ( int i = 0 ; i < 4 ; i++ ){\n        cin >> swp;\n        a += swp;\n    }\n    for ( int i = 0 ; i < 4 ; i++ ){\n        cin >> swp;\n        b += swp;\n    }\n    ans += ( a > b ? 1 : -1 );\n\n\n    a = b = 0;\n    for ( int i = 1 ; i < 4 ; i++ ){\n        cin >> swp;\n        a += swp;\n    }\n    for ( int i = 1 ; i < 4 ; i++ ){\n        cin >> swp;\n        b += swp;\n    }\n    ans += ( a > b ? 1 : -1 );\n\n    if ( !ans )\n        cout << \"Draw\";\n    else if ( ans > 0 )\n        cout << \"Win\";\n    else\n        cout << \"Lose\";\n    cout << '\\n';\n}\n```\n\n## problem 2\n\n### 題目\n\n給定一張圖，起點為整張圖權重最小的點\n並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點\n然後路徑上點不能重複\n求出路徑的總權重\n\n### 解法\n\ndfs裸題，UVa有類似的題目（題號我忘記了\n反正就是模擬一次就對了（也沒有其他解法啊(ry\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 105; // 大小我忘記了\nconst int INF = 0x3f3f3f3f; // INF大於值域，又可直接memset，方便又實用\ntypedef long long LL;\n\nint mp[maxN][maxN];\n\nLL dfs ( int x, int y, LL sum ){\n    // 先找出最低點\n    int mi = min ( min ( mp[x + 1][y], mp[x - 1][y] ), min ( mp[x][y + 1], mp[x][y - 1] ) );\n    sum += mp[x][y];\n    mp[x][y] = INF;\n    if ( mi == INF )\n        return sum;\n    if ( mp[x + 1][y] == mi )\n        return dfs ( x + 1, y, sum );\n    if ( mp[x - 1][y] == mi )\n        return dfs ( x - 1, y, sum );\n    if ( mp[x][y + 1] == mi )\n        return dfs ( x, y + 1, sum );\n    if ( mp[x][y - 1] == mi )\n        return dfs ( x, y - 1, sum );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, x, y, mi = INF;\n    memset ( mp, INF, sizeof mp );\n    cin >> n >> m;\n    // 1 index，可以直接免去判斷邊界的麻煩\n    for ( int i = 1 ; i <= n ; i++ )\n        for ( int j = 1 ; j <= m ; j++ ){\n            cin >> mp[i][j];\n            if ( mi > mp[i][j] )\n                mi = mp[i][j], x = i, y = j;\n        }\n\n    cout << dfs ( x, y, 0 ) << '\\n';\n}\n```\n\n\n## problem 3\n\n### 題目\n\n給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始\n請求出每一對可以組成互補字串的數量\n且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列\n所以$AAB$與$AB$與$BA$都是相同的字串\n\n#### 定義一下互補字串\n\n假設字串$A$中的元素沒有出現在字串$B$中\n同時，字串$B$的元素也沒有出現在字串$A$中\n則稱$A \\text& B$為互補字串\n\n### 解法\n\n#### 解法一：硬幹\n\n##### 說明\n\n之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的\n\n##### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n#define F first\n#define S second\n\nusing namespace std;\n\nmap < string, int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    string str, basic;\n    char c = 'A';\n    cin >> n >> m;\n    for ( int i = 0 ; i < m ; i++, c++ )\n        basic += c;\n    while ( n-- ){\n        cin >> str;\n        // 這邊為了要把順序都統一，所以先做一下排序\n        sort ( str.begin(), str.end() );\n        // 這邊則是要把重複的字元壓掉\n        str.erase ( unique ( str.begin(), str.end() ), str.end() );\n        lib[str]++;\n    }\n\n    for ( auto j: lib ){\n        str = basic;\n        // 把出現過的直接刪掉\n        for ( auto i: j.F )\n            str.erase ( lower_bound ( str.begin(), str.end(), i ) );\n        ans += j.S * lib[str];\n    }\n\n    // 因為會重複計算到兩次    \n    ans /= 2;\n    cout << ans << '\\n';\n}\n```\n\n#### 方法二：Xor\n\n##### 說明\n\n因為原本的方法太智障了（？\n如果不是因為資料量小可以這樣做，資料量一大直接吃土\n\n出來之後聽到有人是這樣做的，有點類似Hash的做法\n把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$\n然後為了方便運算會把這個二進位reverse\n\n也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$\n然後再把二進位轉成十進位\n這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串\n\n##### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n#define F first\n#define S second\n\nusing namespace std;\n\nmap < int, int > lib;\n\ninline int translate ( string str ){\n    int res = 0;\n    for ( auto i: str )\n        res |= ( 1 << ( i - 'A' ) );\n\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0, ori = 0;\n    string str;\n    cin >> n >> m;\n    for ( int i = 0 ; i < m ; i++ )\n        ori |= ( 1 << i );\n    while ( n-- ){\n        cin >> str;\n        // 這邊為了要把順序都統一，所以先做一下排序\n        sort ( str.begin(), str.end() );\n        // 這邊則是要把重複的字元壓掉\n        str.erase ( unique ( str.begin(), str.end() ), str.end() );\n        lib[translate ( str )]++;\n    }\n\n    for ( auto j: lib )\n        ans += ( j.S * lib[ori ^ j.F] );\n\n    // 因為會重複計算到兩次    \n    ans >>= 1;\n    cout << ans << '\\n';\n}\n```\n**注意，這份code並沒有經過詳細測試，可能有誤**\n\n\n## problem 4\n\n### 題目\n\n給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量\n\n### 解法\n\nSlide Window裸題，不過關於實作又有兩種做法\n\n#### 方法一：固定Window大小\n\n把window大小固定為$M$，並且開一個set紀錄這個window的數字\n要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過\n然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了\n\n#### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 100005;\n\nint cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    cin >> n >> m;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    // 離散化\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    for ( auto &i: data )\n        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();\n\n    queue < int > q;\n    set < int > s;\n    for ( int i = 0 ; i < n ; i++ ){\n        q.push ( data[i] );\n        s.insert ( data[i] );\n        cnt[data[i]]++;\n        if ( q.size() >= m ){\n            cnt[q.front()]--;\n            if ( !cnt[q.front()] )\n                s.erase ( q.front() );\n            q.pop();\n        }\n        if ( s.size() == m )\n            ans++;\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n#### 方法二：不固定的window大小\n\n此方法由吳邦一教授提出（[原文連結](https://brian.su/r/APCS-2019-06-P4)）\n由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止\n\n#### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 100005;\n\nint cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    cin >> n >> m;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    // 離散化\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    for ( auto &i: data )\n        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();\n\n    // 這邊的話就不用set了    \n    queue < int > q;\n    for ( int i = 0 ; i < n ; i++ ){\n        // 不斷pop直到這個數字前面沒有出現過\n        while ( !q.empty() && cnt[data[i]] ){\n            cnt[q.front()]--;\n            q.pop();\n        }\n        q.push ( data[i] );\n        cnt[data[i]]++;\n        if ( q.size() == m )\n            ans++;\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n\n## 後記\n\n其實我把所有題目寫完之後，大概才過41分鐘\n然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug\n接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到\n也就是說，我在裡面燒機燒了一個半小時然後產量是零\n抓到，澪人桐是燒機大師\n早就知道出來玩手機算了 = =\n\n.\n\n看到這邊多多少少都會對我的成績有點興趣吧（？\n（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛\n話不多說我直接上圖好了\n\n![](score.png)\n\n差一題觀念5+5\n搞什麼 = =\n\n以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼\n（欸，差不多是一年前的六月場欸OAO\n\n雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜\n那麼今天就到這邊了，謝謝各位今天的閱讀\n如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我\n我的email可以在我的[個人頁面](https://miohitokiri5474.github.io/code/about/)找到\np.s. 我今天寫好長的文章喔，到這邊已經430行了\n\n本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行\n所以原本的文章看起來很很空\n還需要自己手動調整，有點小麻煩\n不過他可以即時顯示md的渲染結果，真的讓人難以抉擇\n\n## 更新（2019/07/04 10:28）\n\n之前可以查詢成績好像是bug，官方是說今天早上十點才可以查\n剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）\n\n{% asset_img per.png \"2019年六月場級距\" %}\n\n## 圖片出處\n1. 紅色鳥居：神奈川縣蘆之湖[kaji_nori06](https://www.instagram.com/kaji_nori06/)\n2. 成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧\n3. 級距。。。啊就從成績單上截圖截下來的啊 = =","slug":"APCS-19-06","published":1,"updated":"2020-05-03T10:27:23.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndpx0002f19p0jsj5rry","content":"<!-- build time:Sun May 03 2020 19:17:22 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>因為想要拼5 + 5，於是又報名了這次的APCS<br>至於成績如何那就晚點再說吧，算是個小伏筆（？</p><a id=\"more\"></a><p>即便考場在家附近，我還是提早出門了<br>還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎<br>趕快google一下才發現跑錯棚了，應該是在校區的另一邊<br>所以我又趕快跑過去，差一點點遲到<br>好險有提早出門（汗</p><img src=\"/code/APCS-19-06/img.jpg\" title=\"因為不想要縮圖是我的成績單，所以我就放這張圖了\"><h2 id=\"problem-1\"><a class=\"header-anchor\" href=\"#problem-1\"></a>problem 1</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節<br>求出主場最終的輸贏</p><ol><li>兩場全贏：勝</li><li>兩場全敗：敗</li><li>一勝一敗：平手</li></ol><p>保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>直接實作一下就好了</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>, swp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        a += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        b += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans += ( a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        a += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        b += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans += ( a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !ans )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Draw\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( ans &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Win\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lose\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-2\"><a class=\"header-anchor\" href=\"#problem-2\"></a>problem 2</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一張圖，起點為整張圖權重最小的點<br>並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點<br>然後路徑上點不能重複<br>求出路徑的總權重</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>dfs裸題，UVa有類似的題目（題號我忘記了<br>反正就是模擬一次就對了（也沒有其他解法啊(ry</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">105</span>; <span class=\"comment\">// 大小我忘記了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>; <span class=\"comment\">// INF大於值域，又可直接memset，方便又實用</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> mp[maxN][maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, LL sum )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先找出最低點</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mi = min ( min ( mp[x + <span class=\"number\">1</span>][y], mp[x - <span class=\"number\">1</span>][y] ), min ( mp[x][y + <span class=\"number\">1</span>], mp[x][y - <span class=\"number\">1</span>] ) );</span><br><span class=\"line\">    sum += mp[x][y];</span><br><span class=\"line\">    mp[x][y] = INF;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mi == INF )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x + <span class=\"number\">1</span>][y] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x + <span class=\"number\">1</span>, y, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x - <span class=\"number\">1</span>][y] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x - <span class=\"number\">1</span>, y, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x][y + <span class=\"number\">1</span>] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x, y + <span class=\"number\">1</span>, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x][y - <span class=\"number\">1</span>] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x, y - <span class=\"number\">1</span>, sum );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, x, y, mi = INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span> ( mp, INF, <span class=\"keyword\">sizeof</span> mp );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"comment\">// 1 index，可以直接免去判斷邊界的麻煩</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">1</span> ; j &lt;= m ; j++ )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; mp[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( mi &gt; mp[i][j] )</span><br><span class=\"line\">                mi = mp[i][j], x = i, y = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; dfs ( x, y, <span class=\"number\">0</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-3\"><a class=\"header-anchor\" href=\"#problem-3\"></a>problem 3</h2><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始<br>請求出每一對可以組成互補字串的數量<br>且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列<br>所以$AAB$與$AB$與$BA$都是相同的字串</p><h4 id=\"定義一下互補字串\"><a class=\"header-anchor\" href=\"#定義一下互補字串\"></a>定義一下互補字串</h4><p>假設字串$A$中的元素沒有出現在字串$B$中<br>同時，字串$B$的元素也沒有出現在字串$A$中<br>則稱$A \\text&amp; B$為互補字串</p><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><h4 id=\"解法一：硬幹\"><a class=\"header-anchor\" href=\"#解法一：硬幹\"></a>解法一：硬幹</h4><h5 id=\"說明\"><a class=\"header-anchor\" href=\"#說明\"></a>說明</h5><p>之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的</p><h5 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"built_in\">string</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str, basic;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++, c++ )</span><br><span class=\"line\">        basic += c;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( n-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"comment\">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class=\"line\">        sort ( str.begin(), str.end() );</span><br><span class=\"line\">        <span class=\"comment\">// 這邊則是要把重複的字元壓掉</span></span><br><span class=\"line\">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class=\"line\">        lib[str]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: lib )&#123;</span><br><span class=\"line\">        str = basic;</span><br><span class=\"line\">        <span class=\"comment\">// 把出現過的直接刪掉</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: j.F )</span><br><span class=\"line\">            str.erase ( lower_bound ( str.begin(), str.end(), i ) );</span><br><span class=\"line\">        ans += j.S * lib[str];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因為會重複計算到兩次    </span></span><br><span class=\"line\">    ans /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：Xor\"><a class=\"header-anchor\" href=\"#方法二：Xor\"></a>方法二：Xor</h4><h5 id=\"說明-v2\"><a class=\"header-anchor\" href=\"#說明-v2\"></a>說明</h5><p>因為原本的方法太智障了（？<br>如果不是因為資料量小可以這樣做，資料量一大直接吃土</p><p>出來之後聽到有人是這樣做的，有點類似Hash的做法<br>把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$<br>然後為了方便運算會把這個二進位reverse</p><p>也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$<br>然後再把二進位轉成十進位<br>這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串</p><h5 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">translate</span> <span class=\"params\">( <span class=\"built_in\">string</span> str )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )</span><br><span class=\"line\">        res |= ( <span class=\"number\">1</span> &lt;&lt; ( i - <span class=\"string\">'A'</span> ) );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>, ori = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )</span><br><span class=\"line\">        ori |= ( <span class=\"number\">1</span> &lt;&lt; i );</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( n-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"comment\">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class=\"line\">        sort ( str.begin(), str.end() );</span><br><span class=\"line\">        <span class=\"comment\">// 這邊則是要把重複的字元壓掉</span></span><br><span class=\"line\">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class=\"line\">        lib[translate ( str )]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: lib )</span><br><span class=\"line\">        ans += ( j.S * lib[ori ^ j.F] );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因為會重複計算到兩次    </span></span><br><span class=\"line\">    ans &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，這份code並沒有經過詳細測試，可能有誤</strong></p><h2 id=\"problem-4\"><a class=\"header-anchor\" href=\"#problem-4\"></a>problem 4</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量</p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>Slide Window裸題，不過關於實作又有兩種做法</p><h4 id=\"方法一：固定Window大小\"><a class=\"header-anchor\" href=\"#方法一：固定Window大小\"></a>方法一：固定Window大小</h4><p>把window大小固定為$M$，並且開一個set紀錄這個window的數字<br>要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過<br>然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了</p><h4 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"comment\">// 離散化</span></span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> &lt; <span class=\"keyword\">int</span> &gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        q.push ( data[i] );</span><br><span class=\"line\">        s.insert ( data[i] );</span><br><span class=\"line\">        cnt[data[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( q.size() &gt;= m )&#123;</span><br><span class=\"line\">            cnt[q.front()]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !cnt[q.front()] )</span><br><span class=\"line\">                s.erase ( q.front() );</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( s.size() == m )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：不固定的window大小\"><a class=\"header-anchor\" href=\"#方法二：不固定的window大小\"></a>方法二：不固定的window大小</h4><p>此方法由吳邦一教授提出（<a href=\"https://brian.su/r/APCS-2019-06-P4\" target=\"_blank\" rel=\"noopener\">原文連結</a>）<br>由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止</p><h4 id=\"code-v6\"><a class=\"header-anchor\" href=\"#code-v6\"></a>code</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"comment\">// 離散化</span></span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 這邊的話就不用set了    </span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> &lt; <span class=\"keyword\">int</span> &gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不斷pop直到這個數字前面沒有出現過</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( !q.empty() &amp;&amp; cnt[data[i]] )&#123;</span><br><span class=\"line\">            cnt[q.front()]--;</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.push ( data[i] );</span><br><span class=\"line\">        cnt[data[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( q.size() == m )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>其實我把所有題目寫完之後，大概才過41分鐘<br>然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug<br>接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到<br>也就是說，我在裡面燒機燒了一個半小時然後產量是零<br>抓到，澪人桐是燒機大師<br>早就知道出來玩手機算了 = =</p><p>.</p><p>看到這邊多多少少都會對我的成績有點興趣吧（？<br>（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛<br>話不多說我直接上圖好了</p><p><img src=\"score.png\" alt=\"\"></p><p>差一題觀念5+5<br>搞什麼 = =</p><p>以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼<br>（欸，差不多是一年前的六月場欸OAO</p><p>雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜<br>那麼今天就到這邊了，謝謝各位今天的閱讀<br>如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我<br>我的email可以在我的<a href=\"https://miohitokiri5474.github.io/code/about/\">個人頁面</a>找到<br>p.s. 我今天寫好長的文章喔，到這邊已經430行了</p><p>本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行<br>所以原本的文章看起來很很空<br>還需要自己手動調整，有點小麻煩<br>不過他可以即時顯示md的渲染結果，真的讓人難以抉擇</p><h2 id=\"更新（2019-07-04-10-28）\"><a class=\"header-anchor\" href=\"#更新（2019-07-04-10-28）\"></a>更新（2019/07/04 10:28）</h2><p>之前可以查詢成績好像是bug，官方是說今天早上十點才可以查<br>剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）</p><img src=\"/code/APCS-19-06/per.png\" title=\"2019年六月場級距\"><h2 id=\"圖片出處\"><a class=\"header-anchor\" href=\"#圖片出處\"></a>圖片出處</h2><ol><li>紅色鳥居：神奈川縣蘆之湖<a href=\"https://www.instagram.com/kaji_nori06/\" target=\"_blank\" rel=\"noopener\">kaji_nori06</a></li><li>成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧</li><li>級距。。。啊就從成績單上截圖截下來的啊 = =</li></ol><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:22 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>因為想要拼5 + 5，於是又報名了這次的APCS<br>至於成績如何那就晚點再說吧，算是個小伏筆（？</p>","more":"<p>即便考場在家附近，我還是提早出門了<br>還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎<br>趕快google一下才發現跑錯棚了，應該是在校區的另一邊<br>所以我又趕快跑過去，差一點點遲到<br>好險有提早出門（汗</p><img src=\"/code/APCS-19-06/img.jpg\" title=\"因為不想要縮圖是我的成績單，所以我就放這張圖了\"><h2 id=\"problem-1\"><a class=\"header-anchor\" href=\"#problem-1\"></a>problem 1</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節<br>求出主場最終的輸贏</p><ol><li>兩場全贏：勝</li><li>兩場全敗：敗</li><li>一勝一敗：平手</li></ol><p>保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>直接實作一下就好了</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>, swp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        a += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        b += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans += ( a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        a += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        b += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans += ( a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !ans )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Draw\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( ans &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Win\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lose\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-2\"><a class=\"header-anchor\" href=\"#problem-2\"></a>problem 2</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一張圖，起點為整張圖權重最小的點<br>並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點<br>然後路徑上點不能重複<br>求出路徑的總權重</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>dfs裸題，UVa有類似的題目（題號我忘記了<br>反正就是模擬一次就對了（也沒有其他解法啊(ry</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">105</span>; <span class=\"comment\">// 大小我忘記了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>; <span class=\"comment\">// INF大於值域，又可直接memset，方便又實用</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> mp[maxN][maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, LL sum )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先找出最低點</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mi = min ( min ( mp[x + <span class=\"number\">1</span>][y], mp[x - <span class=\"number\">1</span>][y] ), min ( mp[x][y + <span class=\"number\">1</span>], mp[x][y - <span class=\"number\">1</span>] ) );</span><br><span class=\"line\">    sum += mp[x][y];</span><br><span class=\"line\">    mp[x][y] = INF;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mi == INF )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x + <span class=\"number\">1</span>][y] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x + <span class=\"number\">1</span>, y, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x - <span class=\"number\">1</span>][y] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x - <span class=\"number\">1</span>, y, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x][y + <span class=\"number\">1</span>] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x, y + <span class=\"number\">1</span>, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x][y - <span class=\"number\">1</span>] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x, y - <span class=\"number\">1</span>, sum );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, x, y, mi = INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span> ( mp, INF, <span class=\"keyword\">sizeof</span> mp );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"comment\">// 1 index，可以直接免去判斷邊界的麻煩</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">1</span> ; j &lt;= m ; j++ )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; mp[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( mi &gt; mp[i][j] )</span><br><span class=\"line\">                mi = mp[i][j], x = i, y = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; dfs ( x, y, <span class=\"number\">0</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-3\"><a class=\"header-anchor\" href=\"#problem-3\"></a>problem 3</h2><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始<br>請求出每一對可以組成互補字串的數量<br>且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列<br>所以$AAB$與$AB$與$BA$都是相同的字串</p><h4 id=\"定義一下互補字串\"><a class=\"header-anchor\" href=\"#定義一下互補字串\"></a>定義一下互補字串</h4><p>假設字串$A$中的元素沒有出現在字串$B$中<br>同時，字串$B$的元素也沒有出現在字串$A$中<br>則稱$A \\text&amp; B$為互補字串</p><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><h4 id=\"解法一：硬幹\"><a class=\"header-anchor\" href=\"#解法一：硬幹\"></a>解法一：硬幹</h4><h5 id=\"說明\"><a class=\"header-anchor\" href=\"#說明\"></a>說明</h5><p>之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的</p><h5 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"built_in\">string</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str, basic;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++, c++ )</span><br><span class=\"line\">        basic += c;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( n-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"comment\">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class=\"line\">        sort ( str.begin(), str.end() );</span><br><span class=\"line\">        <span class=\"comment\">// 這邊則是要把重複的字元壓掉</span></span><br><span class=\"line\">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class=\"line\">        lib[str]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: lib )&#123;</span><br><span class=\"line\">        str = basic;</span><br><span class=\"line\">        <span class=\"comment\">// 把出現過的直接刪掉</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: j.F )</span><br><span class=\"line\">            str.erase ( lower_bound ( str.begin(), str.end(), i ) );</span><br><span class=\"line\">        ans += j.S * lib[str];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因為會重複計算到兩次    </span></span><br><span class=\"line\">    ans /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：Xor\"><a class=\"header-anchor\" href=\"#方法二：Xor\"></a>方法二：Xor</h4><h5 id=\"說明-v2\"><a class=\"header-anchor\" href=\"#說明-v2\"></a>說明</h5><p>因為原本的方法太智障了（？<br>如果不是因為資料量小可以這樣做，資料量一大直接吃土</p><p>出來之後聽到有人是這樣做的，有點類似Hash的做法<br>把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$<br>然後為了方便運算會把這個二進位reverse</p><p>也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$<br>然後再把二進位轉成十進位<br>這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串</p><h5 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">translate</span> <span class=\"params\">( <span class=\"built_in\">string</span> str )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )</span><br><span class=\"line\">        res |= ( <span class=\"number\">1</span> &lt;&lt; ( i - <span class=\"string\">'A'</span> ) );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>, ori = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )</span><br><span class=\"line\">        ori |= ( <span class=\"number\">1</span> &lt;&lt; i );</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( n-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"comment\">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class=\"line\">        sort ( str.begin(), str.end() );</span><br><span class=\"line\">        <span class=\"comment\">// 這邊則是要把重複的字元壓掉</span></span><br><span class=\"line\">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class=\"line\">        lib[translate ( str )]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: lib )</span><br><span class=\"line\">        ans += ( j.S * lib[ori ^ j.F] );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因為會重複計算到兩次    </span></span><br><span class=\"line\">    ans &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，這份code並沒有經過詳細測試，可能有誤</strong></p><h2 id=\"problem-4\"><a class=\"header-anchor\" href=\"#problem-4\"></a>problem 4</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量</p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>Slide Window裸題，不過關於實作又有兩種做法</p><h4 id=\"方法一：固定Window大小\"><a class=\"header-anchor\" href=\"#方法一：固定Window大小\"></a>方法一：固定Window大小</h4><p>把window大小固定為$M$，並且開一個set紀錄這個window的數字<br>要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過<br>然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了</p><h4 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"comment\">// 離散化</span></span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> &lt; <span class=\"keyword\">int</span> &gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        q.push ( data[i] );</span><br><span class=\"line\">        s.insert ( data[i] );</span><br><span class=\"line\">        cnt[data[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( q.size() &gt;= m )&#123;</span><br><span class=\"line\">            cnt[q.front()]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !cnt[q.front()] )</span><br><span class=\"line\">                s.erase ( q.front() );</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( s.size() == m )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：不固定的window大小\"><a class=\"header-anchor\" href=\"#方法二：不固定的window大小\"></a>方法二：不固定的window大小</h4><p>此方法由吳邦一教授提出（<a href=\"https://brian.su/r/APCS-2019-06-P4\" target=\"_blank\" rel=\"noopener\">原文連結</a>）<br>由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止</p><h4 id=\"code-v6\"><a class=\"header-anchor\" href=\"#code-v6\"></a>code</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"comment\">// 離散化</span></span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 這邊的話就不用set了    </span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> &lt; <span class=\"keyword\">int</span> &gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不斷pop直到這個數字前面沒有出現過</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( !q.empty() &amp;&amp; cnt[data[i]] )&#123;</span><br><span class=\"line\">            cnt[q.front()]--;</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.push ( data[i] );</span><br><span class=\"line\">        cnt[data[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( q.size() == m )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>其實我把所有題目寫完之後，大概才過41分鐘<br>然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug<br>接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到<br>也就是說，我在裡面燒機燒了一個半小時然後產量是零<br>抓到，澪人桐是燒機大師<br>早就知道出來玩手機算了 = =</p><p>.</p><p>看到這邊多多少少都會對我的成績有點興趣吧（？<br>（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛<br>話不多說我直接上圖好了</p><p><img src=\"score.png\" alt=\"\"></p><p>差一題觀念5+5<br>搞什麼 = =</p><p>以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼<br>（欸，差不多是一年前的六月場欸OAO</p><p>雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜<br>那麼今天就到這邊了，謝謝各位今天的閱讀<br>如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我<br>我的email可以在我的<a href=\"https://miohitokiri5474.github.io/code/about/\">個人頁面</a>找到<br>p.s. 我今天寫好長的文章喔，到這邊已經430行了</p><p>本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行<br>所以原本的文章看起來很很空<br>還需要自己手動調整，有點小麻煩<br>不過他可以即時顯示md的渲染結果，真的讓人難以抉擇</p><h2 id=\"更新（2019-07-04-10-28）\"><a class=\"header-anchor\" href=\"#更新（2019-07-04-10-28）\"></a>更新（2019/07/04 10:28）</h2><p>之前可以查詢成績好像是bug，官方是說今天早上十點才可以查<br>剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）</p><img src=\"/code/APCS-19-06/per.png\" title=\"2019年六月場級距\"><h2 id=\"圖片出處\"><a class=\"header-anchor\" href=\"#圖片出處\"></a>圖片出處</h2><ol><li>紅色鳥居：神奈川縣蘆之湖<a href=\"https://www.instagram.com/kaji_nori06/\" target=\"_blank\" rel=\"noopener\">kaji_nori06</a></li><li>成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧</li><li>級距。。。啊就從成績單上截圖截下來的啊 = =</li></ol><!-- rebuild by neat -->"},{"title":"C語言中 char 字串轉換成數字","date":"2019-09-17T16:46:41.000Z","_content":"\n## 前言\n\n今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字\n<!--more-->\n\n## 方法\n\n1. 使用內建函數atoi\n2. 自己寫\n\n內建函數的用法可以去cpprefrence查到，所以這邊就不解說了\n只有講自己寫的做法\n\n## 原理\n\n如果要在一個數字的尾端加上一位數，該如何操作？\n有一種方法：先把原數字 * 10，然後再把那一位數加上去\n所以就可以有下面這種code\n\n```cpp\nint translate ( char *c, int len ){\n\tint i, res = 0;\n\tfor ( i = 0 ; i < len ; i++ ){\n\t\tres *= 10;\n\t\tres += ( c[i] - '0' );\n\t}\n\n\treturn res;\n}\n```\n\n然後解說一下code中第五行\nchar之間的相減就是ASCii code的值的差\n所以可以用這種方法把原本的數字還原出來","source":"_posts/C-atoi.md","raw":"---\ntitle: \"C語言中 char 字串轉換成數字\"\ndate: 2019-09-18 00:46:41\ntags:\n - C\n---\n\n## 前言\n\n今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字\n<!--more-->\n\n## 方法\n\n1. 使用內建函數atoi\n2. 自己寫\n\n內建函數的用法可以去cpprefrence查到，所以這邊就不解說了\n只有講自己寫的做法\n\n## 原理\n\n如果要在一個數字的尾端加上一位數，該如何操作？\n有一種方法：先把原數字 * 10，然後再把那一位數加上去\n所以就可以有下面這種code\n\n```cpp\nint translate ( char *c, int len ){\n\tint i, res = 0;\n\tfor ( i = 0 ; i < len ; i++ ){\n\t\tres *= 10;\n\t\tres += ( c[i] - '0' );\n\t}\n\n\treturn res;\n}\n```\n\n然後解說一下code中第五行\nchar之間的相減就是ASCii code的值的差\n所以可以用這種方法把原本的數字還原出來","slug":"C-atoi","published":1,"updated":"2020-05-03T10:27:23.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndq20005f19patj4164a","content":"<!-- build time:Sun May 03 2020 19:17:22 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字</p><a id=\"more\"></a><h2 id=\"方法\"><a class=\"header-anchor\" href=\"#方法\"></a>方法</h2><ol><li>使用內建函數atoi</li><li>自己寫</li></ol><p>內建函數的用法可以去cpprefrence查到，所以這邊就不解說了<br>只有講自己寫的做法</p><h2 id=\"原理\"><a class=\"header-anchor\" href=\"#原理\"></a>原理</h2><p>如果要在一個數字的尾端加上一位數，該如何操作？<br>有一種方法：先把原數字 * 10，然後再把那一位數加上去<br>所以就可以有下面這種code</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">translate</span> <span class=\"params\">( <span class=\"keyword\">char</span> *c, <span class=\"keyword\">int</span> len )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">\t\tres *= <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tres += ( c[i] - <span class=\"string\">'0'</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然後解說一下code中第五行<br>char之間的相減就是ASCii code的值的差<br>所以可以用這種方法把原本的數字還原出來</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:22 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字</p>","more":"<h2 id=\"方法\"><a class=\"header-anchor\" href=\"#方法\"></a>方法</h2><ol><li>使用內建函數atoi</li><li>自己寫</li></ol><p>內建函數的用法可以去cpprefrence查到，所以這邊就不解說了<br>只有講自己寫的做法</p><h2 id=\"原理\"><a class=\"header-anchor\" href=\"#原理\"></a>原理</h2><p>如果要在一個數字的尾端加上一位數，該如何操作？<br>有一種方法：先把原數字 * 10，然後再把那一位數加上去<br>所以就可以有下面這種code</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">translate</span> <span class=\"params\">( <span class=\"keyword\">char</span> *c, <span class=\"keyword\">int</span> len )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">\t\tres *= <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tres += ( c[i] - <span class=\"string\">'0'</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然後解說一下code中第五行<br>char之間的相減就是ASCii code的值的差<br>所以可以用這種方法把原本的數字還原出來</p><!-- rebuild by neat -->"},{"title":"[CF][920F] F. SUM AND REPLACE","date":"2018-04-03T03:25:31.000Z","_content":"\n## 前言\n\n好久沒有發題解了，今天心血來潮來寫一篇吧\n今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF\npF，感覺很難？其實還好， 因為這是 Education\n<!--more-->\n\n## 題目\n\n不管，翻譯下題目好了，畢竟原題是英文的\n要原題連結的[在這](http://codeforces.com/problemset/problem/920/F)\n\n給定一個長度為N的序列，並有兩種輸入要處理：\n1. 對區間 $l, r$ 做操作 $D$（等等寫在下面）\n2. 查詢區間和\n\n操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 $\\{1, 2, 3, 6\\}$，共四個）\n\n\n## 解法\n\n嗯。。。區間操作？區間和？\n怎麼看都是線段樹，但是問題是：操作\n因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\\sqrt{N}$，證明我等等再打\n\n好，我們先觀察一下：\n1. 只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）\n2. 越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果\n\n接著是最後一個問題：該如何處理區間操作\n對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）\n不過有種做法叫**找收斂點（終止點）**\n\n剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\\ge 2$ 的數字當作是否繼續進行操作的依據\n\n到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看[這篇](https://miohitokiri.github.io/code/TOJ-391/)\n\n不過大概算了一下，這樣需要開到$8\\times N$的記憶體，感覺會 MLE\n所以我先拿區間和開刀，如果當前區間和 $\\ge 2\\times range（區間大小）$ 再繼續進行操作\n。。。然後我就 WA 了，請想想如果當前區間內元素為 $\\{ 1, 1, 1, 3 \\}$ 的時候\n\n有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字\n所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\\ge 2$\n\n本來不想要開第二顆線段樹，到頭來還不是開了\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 300005\n\nLL sum[maxN << 2], dp[1000005];\nbool used[maxN << 2];\nvector < int > prime;\nbitset < 1005 > lib;\n\ninline int D ( int n ){\n    if ( dp[n] != -1 )\n        return dp[n];\n    double www = sqrt ( n );\n    int ma = www, res = 0, maa = ma + 1;\n    for ( int i = 1 ; i < maa ; i++ )\n        n % i ? res : res++;\n\n    return dp[n] = res * 2 - ( www == ma ? 1 : 0 );\n}\n\ninline void build ( int l, int r, int n ){\n    if ( l == r ){\n        cin >> sum[n];\n        used[n] = ( sum[n] > 2 );\n    }\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        build ( l, mid, leftSon );\n        build ( mid + 1, r, rightSon );\n\n        sum[n] = sum[leftSon] + sum[rightSon];\n        used[n] = ( used[leftSon] || used[rightSon] );\n    }\n}\n\ninline LL query ( int l, int r, int nowL, int nowR, int n ){\n    if ( l <= nowL && nowR <= r )\n        return sum[n];\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( r <= mid )\n        return query ( l, r, nowL, mid, leftSon );\n    if ( mid < l )\n        return query ( l, r, mid + 1, nowR, rightSon );\n    return query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + 1, nowR, rightSon );\n}\n\ninline void modify ( int l, int r, int nowL, int nowR, int n ){\n    if ( !used[n] )\n        return;\n    if ( nowL == nowR ){\n        sum[n] = D ( sum[n] );\n        used[n] = ( sum[n] > 2 );\n    }\n    else{\n        int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( r <= mid )\n            modify ( l, r, nowL, mid, leftSon );\n        else if ( mid < l )\n            modify ( l, r, mid + 1, nowR, rightSon );\n        else{\n            modify ( l, r, nowL, mid, leftSon );\n            modify ( l, r, mid + 1, nowR, rightSon );\n        }\n\n        sum[n] = sum[leftSon] + sum[rightSon];\n        used[n] = ( used[leftSon] || used[rightSon] );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    lib[0] = lib[1] = true;\n    for ( int i = 2 ; i < 1005 ; i++ ){\n        if ( !lib[i] ){\n            prime.push_back ( i );\n            for ( int j = i << 1 ; j < 1005 ; j += i )\n                lib[j] = true;\n        }\n    }\n\n    memset ( dp, -1, sizeof dp );\n    int n, m, type, l, r, stop;\n    cin >> n >> m;\n    build ( 1, n, 1 );\n\n    while ( m-- ){\n        cin >> type >> l >> r;\n        if ( type == 1 )\n            modify ( l, r, 1, n, 1 );\n        else\n            cout << query ( l, r, 1, n, 1 ) << '\\n';\n    }\n}\n```\n\n## 證明（？\n\n接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\\sqrt{N}$ 的數字就好了\n假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數\n這樣代表說 $\\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \\frac{N}{i}  \\to i \\times j = N$\n假設 $i\\le j$ 帶入上面的式子，$i^2\\le N\\to i\\le\\sqrt{N}$\n故得證\n\n。。。好啦，我感覺我寫的證明不是對的 > <\n以上證明僅供參考","source":"_posts/CF-920F.md","raw":"---\ntitle: '[CF][920F] F. SUM AND REPLACE'\ndate: 2018-04-03 11:25:31\ntags:\n - CodeForces\n - Education Round\n - segment tree\n - data structure\n---\n\n## 前言\n\n好久沒有發題解了，今天心血來潮來寫一篇吧\n今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF\npF，感覺很難？其實還好， 因為這是 Education\n<!--more-->\n\n## 題目\n\n不管，翻譯下題目好了，畢竟原題是英文的\n要原題連結的[在這](http://codeforces.com/problemset/problem/920/F)\n\n給定一個長度為N的序列，並有兩種輸入要處理：\n1. 對區間 $l, r$ 做操作 $D$（等等寫在下面）\n2. 查詢區間和\n\n操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 $\\{1, 2, 3, 6\\}$，共四個）\n\n\n## 解法\n\n嗯。。。區間操作？區間和？\n怎麼看都是線段樹，但是問題是：操作\n因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\\sqrt{N}$，證明我等等再打\n\n好，我們先觀察一下：\n1. 只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）\n2. 越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果\n\n接著是最後一個問題：該如何處理區間操作\n對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）\n不過有種做法叫**找收斂點（終止點）**\n\n剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\\ge 2$ 的數字當作是否繼續進行操作的依據\n\n到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看[這篇](https://miohitokiri.github.io/code/TOJ-391/)\n\n不過大概算了一下，這樣需要開到$8\\times N$的記憶體，感覺會 MLE\n所以我先拿區間和開刀，如果當前區間和 $\\ge 2\\times range（區間大小）$ 再繼續進行操作\n。。。然後我就 WA 了，請想想如果當前區間內元素為 $\\{ 1, 1, 1, 3 \\}$ 的時候\n\n有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字\n所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\\ge 2$\n\n本來不想要開第二顆線段樹，到頭來還不是開了\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 300005\n\nLL sum[maxN << 2], dp[1000005];\nbool used[maxN << 2];\nvector < int > prime;\nbitset < 1005 > lib;\n\ninline int D ( int n ){\n    if ( dp[n] != -1 )\n        return dp[n];\n    double www = sqrt ( n );\n    int ma = www, res = 0, maa = ma + 1;\n    for ( int i = 1 ; i < maa ; i++ )\n        n % i ? res : res++;\n\n    return dp[n] = res * 2 - ( www == ma ? 1 : 0 );\n}\n\ninline void build ( int l, int r, int n ){\n    if ( l == r ){\n        cin >> sum[n];\n        used[n] = ( sum[n] > 2 );\n    }\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        build ( l, mid, leftSon );\n        build ( mid + 1, r, rightSon );\n\n        sum[n] = sum[leftSon] + sum[rightSon];\n        used[n] = ( used[leftSon] || used[rightSon] );\n    }\n}\n\ninline LL query ( int l, int r, int nowL, int nowR, int n ){\n    if ( l <= nowL && nowR <= r )\n        return sum[n];\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( r <= mid )\n        return query ( l, r, nowL, mid, leftSon );\n    if ( mid < l )\n        return query ( l, r, mid + 1, nowR, rightSon );\n    return query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + 1, nowR, rightSon );\n}\n\ninline void modify ( int l, int r, int nowL, int nowR, int n ){\n    if ( !used[n] )\n        return;\n    if ( nowL == nowR ){\n        sum[n] = D ( sum[n] );\n        used[n] = ( sum[n] > 2 );\n    }\n    else{\n        int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( r <= mid )\n            modify ( l, r, nowL, mid, leftSon );\n        else if ( mid < l )\n            modify ( l, r, mid + 1, nowR, rightSon );\n        else{\n            modify ( l, r, nowL, mid, leftSon );\n            modify ( l, r, mid + 1, nowR, rightSon );\n        }\n\n        sum[n] = sum[leftSon] + sum[rightSon];\n        used[n] = ( used[leftSon] || used[rightSon] );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    lib[0] = lib[1] = true;\n    for ( int i = 2 ; i < 1005 ; i++ ){\n        if ( !lib[i] ){\n            prime.push_back ( i );\n            for ( int j = i << 1 ; j < 1005 ; j += i )\n                lib[j] = true;\n        }\n    }\n\n    memset ( dp, -1, sizeof dp );\n    int n, m, type, l, r, stop;\n    cin >> n >> m;\n    build ( 1, n, 1 );\n\n    while ( m-- ){\n        cin >> type >> l >> r;\n        if ( type == 1 )\n            modify ( l, r, 1, n, 1 );\n        else\n            cout << query ( l, r, 1, n, 1 ) << '\\n';\n    }\n}\n```\n\n## 證明（？\n\n接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\\sqrt{N}$ 的數字就好了\n假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數\n這樣代表說 $\\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \\frac{N}{i}  \\to i \\times j = N$\n假設 $i\\le j$ 帶入上面的式子，$i^2\\le N\\to i\\le\\sqrt{N}$\n故得證\n\n。。。好啦，我感覺我寫的證明不是對的 > <\n以上證明僅供參考","slug":"CF-920F","published":1,"updated":"2020-05-03T10:27:23.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndq40006f19pdaur866r","content":"<!-- build time:Sun May 03 2020 19:17:22 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>好久沒有發題解了，今天心血來潮來寫一篇吧<br>今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF<br>pF，感覺很難？其實還好， 因為這是 Education</p><a id=\"more\"></a><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>不管，翻譯下題目好了，畢竟原題是英文的<br>要原題連結的<a href=\"http://codeforces.com/problemset/problem/920/F\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>給定一個長度為N的序列，並有兩種輸入要處理：</p><ol><li>對區間 $l, r$ 做操作 $D$（等等寫在下面）</li><li>查詢區間和</li></ol><p>操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 ${1, 2, 3, 6}$，共四個）</p><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>嗯。。。區間操作？區間和？<br>怎麼看都是線段樹，但是問題是：操作<br>因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\\sqrt{N}$，證明我等等再打</p><p>好，我們先觀察一下：</p><ol><li>只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）</li><li>越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果</li></ol><p>接著是最後一個問題：該如何處理區間操作<br>對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）<br>不過有種做法叫<strong>找收斂點（終止點）</strong></p><p>剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\\ge 2$ 的數字當作是否繼續進行操作的依據</p><p>到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看<a href=\"https://miohitokiri.github.io/code/TOJ-391/\" target=\"_blank\" rel=\"noopener\">這篇</a></p><p>不過大概算了一下，這樣需要開到$8\\times N$的記憶體，感覺會 MLE<br>所以我先拿區間和開刀，如果當前區間和 $\\ge 2\\times range（區間大小）$ 再繼續進行操作<br>。。。然後我就 WA 了，請想想如果當前區間內元素為 ${ 1, 1, 1, 3 }$ 的時候</p><p>有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字<br>所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\\ge 2$</p><p>本來不想要開第二顆線段樹，到頭來還不是開了</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 300005</span></span><br><span class=\"line\"></span><br><span class=\"line\">LL sum[maxN &lt;&lt; <span class=\"number\">2</span>], dp[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> used[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; prime;</span><br><span class=\"line\"><span class=\"built_in\">bitset</span> &lt; 1005 &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">D</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( dp[n] != <span class=\"number\">-1</span> )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> www = <span class=\"built_in\">sqrt</span> ( n );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ma = www, res = <span class=\"number\">0</span>, maa = ma + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; maa ; i++ )</span><br><span class=\"line\">        n % i ? res : res++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n] = res * <span class=\"number\">2</span> - ( www == ma ? <span class=\"number\">1</span> : <span class=\"number\">0</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; sum[n];</span><br><span class=\"line\">        used[n] = ( sum[n] &gt; <span class=\"number\">2</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        build ( l, mid, leftSon );</span><br><span class=\"line\">        build ( mid + <span class=\"number\">1</span>, r, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class=\"line\">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> LL <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">modify</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !used[n] )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( nowL == nowR )&#123;</span><br><span class=\"line\">        sum[n] = D ( sum[n] );</span><br><span class=\"line\">        used[n] = ( sum[n] &gt; <span class=\"number\">2</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">            modify ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            modify ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class=\"line\">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    lib[<span class=\"number\">0</span>] = lib[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt; <span class=\"number\">1005</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !lib[i] )&#123;</span><br><span class=\"line\">            prime.push_back ( i );</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i &lt;&lt; <span class=\"number\">1</span> ; j &lt; <span class=\"number\">1005</span> ; j += i )</span><br><span class=\"line\">                lib[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span> ( dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> dp );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, type, l, r, stop;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    build ( <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )</span><br><span class=\"line\">            modify ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"證明（？\"><a class=\"header-anchor\" href=\"#證明（？\"></a>證明（？</h2><p>接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\\sqrt{N}$ 的數字就好了<br>假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數<br>這樣代表說 $\\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \\frac{N}{i} \\to i \\times j = N$<br>假設 $i\\le j$ 帶入上面的式子，$i^2\\le N\\to i\\le\\sqrt{N}$<br>故得證</p><p>。。。好啦，我感覺我寫的證明不是對的 &gt; &lt;<br>以上證明僅供參考</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:22 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>好久沒有發題解了，今天心血來潮來寫一篇吧<br>今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF<br>pF，感覺很難？其實還好， 因為這是 Education</p>","more":"<h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>不管，翻譯下題目好了，畢竟原題是英文的<br>要原題連結的<a href=\"http://codeforces.com/problemset/problem/920/F\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>給定一個長度為N的序列，並有兩種輸入要處理：</p><ol><li>對區間 $l, r$ 做操作 $D$（等等寫在下面）</li><li>查詢區間和</li></ol><p>操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 ${1, 2, 3, 6}$，共四個）</p><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>嗯。。。區間操作？區間和？<br>怎麼看都是線段樹，但是問題是：操作<br>因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\\sqrt{N}$，證明我等等再打</p><p>好，我們先觀察一下：</p><ol><li>只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）</li><li>越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果</li></ol><p>接著是最後一個問題：該如何處理區間操作<br>對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）<br>不過有種做法叫<strong>找收斂點（終止點）</strong></p><p>剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\\ge 2$ 的數字當作是否繼續進行操作的依據</p><p>到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看<a href=\"https://miohitokiri.github.io/code/TOJ-391/\" target=\"_blank\" rel=\"noopener\">這篇</a></p><p>不過大概算了一下，這樣需要開到$8\\times N$的記憶體，感覺會 MLE<br>所以我先拿區間和開刀，如果當前區間和 $\\ge 2\\times range（區間大小）$ 再繼續進行操作<br>。。。然後我就 WA 了，請想想如果當前區間內元素為 ${ 1, 1, 1, 3 }$ 的時候</p><p>有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字<br>所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\\ge 2$</p><p>本來不想要開第二顆線段樹，到頭來還不是開了</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 300005</span></span><br><span class=\"line\"></span><br><span class=\"line\">LL sum[maxN &lt;&lt; <span class=\"number\">2</span>], dp[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> used[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; prime;</span><br><span class=\"line\"><span class=\"built_in\">bitset</span> &lt; 1005 &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">D</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( dp[n] != <span class=\"number\">-1</span> )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> www = <span class=\"built_in\">sqrt</span> ( n );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ma = www, res = <span class=\"number\">0</span>, maa = ma + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; maa ; i++ )</span><br><span class=\"line\">        n % i ? res : res++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n] = res * <span class=\"number\">2</span> - ( www == ma ? <span class=\"number\">1</span> : <span class=\"number\">0</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; sum[n];</span><br><span class=\"line\">        used[n] = ( sum[n] &gt; <span class=\"number\">2</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        build ( l, mid, leftSon );</span><br><span class=\"line\">        build ( mid + <span class=\"number\">1</span>, r, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class=\"line\">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> LL <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">modify</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !used[n] )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( nowL == nowR )&#123;</span><br><span class=\"line\">        sum[n] = D ( sum[n] );</span><br><span class=\"line\">        used[n] = ( sum[n] &gt; <span class=\"number\">2</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">            modify ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            modify ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class=\"line\">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    lib[<span class=\"number\">0</span>] = lib[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt; <span class=\"number\">1005</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !lib[i] )&#123;</span><br><span class=\"line\">            prime.push_back ( i );</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i &lt;&lt; <span class=\"number\">1</span> ; j &lt; <span class=\"number\">1005</span> ; j += i )</span><br><span class=\"line\">                lib[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span> ( dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> dp );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, type, l, r, stop;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    build ( <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )</span><br><span class=\"line\">            modify ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"證明（？\"><a class=\"header-anchor\" href=\"#證明（？\"></a>證明（？</h2><p>接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\\sqrt{N}$ 的數字就好了<br>假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數<br>這樣代表說 $\\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \\frac{N}{i} \\to i \\times j = N$<br>假設 $i\\le j$ 帶入上面的式子，$i^2\\le N\\to i\\le\\sqrt{N}$<br>故得證</p><p>。。。好啦，我感覺我寫的證明不是對的 &gt; &lt;<br>以上證明僅供參考</p><!-- rebuild by neat -->"},{"title":"Google Code Jam 2019 Qualification Round","date":"2019-04-09T07:21:21.000Z","_content":"\n## 前言\n\n我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）\n然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了\n\n只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了\n<!--more-->\n下一場是在這週六晚上九點～十一點半\n撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走\n\n總之，過 Qualification Round 應該就算比去年好了\n去年在耍廢直接爆炸。。。\n\n希望今年可以去 Round 2\n\n先放上這次的[題目連結](https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705)\n\n## problem A\n\n### 題目\n\n現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了\n然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$\n**多筆測資**\n\n### 解法\n\n顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$\n一臉就是在跟你說開 string 存啊\n所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$\n然後把這兩個數字輸出\n**注意不能有前導零**\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, mi;\n    string n;\n    cin >> t;\n    for ( int tms = 1 ; tms <= t ; tms++ ){\n        cout << \"Case #\" << tms << \": \";\n        cin >> n;\n        mi = INF;\n        for ( int i = 0 ; i < n.size() ; i++ ){\n            if ( n[i] == '4' ){\n                mi = min ( mi, i );\n                cout << '3';\n            }\n            else\n                cout << n[i];\n        }\n\n        cout << ' ';\n\n        for ( int i = mi ; i < n.size() ; i++ )\n            cout << ( n[i] == '4' )\n        cout << '\\n';\n    }\n}\n```\n\n### 後記\n我還沒有注意到這題有保證輸入有 $4$\n也沒有注意到這題要求輸出都要是正整數\n運氣真好，歪歪得正\n\n\n## problem B\n\n### 題目\n\n給定一張二維圖以及一條從左上到右下的路線\n求一條不重複的另外一條路線\n所謂的路線重複是指 $a \\to b$ 這個邊同時出現在兩條路線中\n然後輸入都是SESE這樣，代表從起點開始他往哪些位置走\n並且保證只會往東（右）以及往南（下）走\n詳細請看這張圖\n![](pB.jpg)\n\n### 解法\n\n#### $O ( N ^ 2 )$\n\n垃圾如我，肯定只會寫 $N ^ 2$ 的解法\n簡單來說就是 dp\n我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存\n然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）\n接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）\n所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點\n\n不過這樣做有小地方需要注意一下\n理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ & $dp[i][j - 1]$ 轉移過來\n所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上\n如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來\n但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）\n因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移\n啊如果還是都可以拿，那就真的隨便了\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define mp make_pair\ntypedef pair < short, char > psc;\n\nbool lib[maxN][maxN];\npsc str[maxN][maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n, x, y;\n    string data;\n    cin >> t;\n    for ( int tms = 1 ; tms <= t ; tms++ ){\n        cin >> n >> data;\n        memset ( lib, 0, sizeof lib );\n        for ( int i = 0 ; i <= n ; i++ ){\n            for ( int j = 0 ; j <= n ; j++ ){\n                str[i][j] = mp ( 0, ' ' );\n            }\n        }\n        x = 1, y = 1;\n        for ( auto i: data ){\n            lib[x][y] = true;\n            i == 'S' ? x++ : y++;\n        }\n        lib[x][y] = true;\n        str[1][1] = mp ( 0, ' ' );\n\n        for ( int i = 2 ; i <= n ; i++ ){\n            if ( lib[1][i] ){\n                if ( !lib[1][i - 1] ){\n                    str[1][i] = str[1][i - 1];\n                    str[1][i].F++;\n                    str[1][i].S = 'E';\n                }\n            }\n            else{\n                str[1][i] = str[1][i - 1];\n                str[1][i].F++;\n                str[1][i].S = 'E';\n            }\n        }\n\n        for ( int i = 2 ; i <= n ; i++ ){\n            if ( lib[i][1] ){\n                if ( !lib[i - 1][1] ){\n                    str[i][1] = str[i - 1][1];\n                    str[i][1].F++;\n                    str[i][1].S = 'S';\n                }\n            }\n            else{\n                str[i][1] = str[i - 1][1];\n                str[i][1].F++;\n                str[i][1].S = 'S';\n            }\n            for ( int j = 2 ; j <= n ; j++ ){\n                if ( lib[i][j] ){\n                    if ( !lib[i][j - 1] ){\n                        str[i][j] = str[i][j - 1];\n                        str[i][j].F++;\n                        str[i][j].S = 'E';\n                    }\n                    else{\n                        str[i][j] = str[i - 1][j];\n                        str[i][j].F++;\n                        str[i][j].S = 'S';\n                    }\n                }\n                else{\n                    if ( str[i][j - 1].F > str[i - 1][j].F ){\n                        str[i][j] = str[i][j - 1];\n                        str[i][j].S = 'E';\n                    }\n                    else{\n                        str[i][j] = str[i - 1][j];\n                        str[i][j].S = 'S';\n                    }\n                    str[i][j].F++;\n                }\n            }\n        }\n\n        data = \"\";\n        x = y = n;\n        while ( str[x][y].S != ' ' ){\n            data += str[x][y].S;\n            str[x][y].S == 'S' ? x-- : y--;\n        }\n        reverse ( data.begin(), data.end() );\n        cout << \"Case #\" << tms << \": \" << data << '\\n';\n    }\n}\n```\n\n#### $O ( N )$\n\n沒錯，$O ( N )$\n我後來才發現我TMD被哏到了\n只要把 S E 反轉就好啊\n讀到 S 輸出 E ，反之讀到 E 輸出 S\n這樣就會變成從左上到右下的對稱\n所以路線不會重複。。。\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n;\n    string str;\n    cin >> t;\n    while ( t-- && cin >> n >> str ){\n        for ( auto i: str )\n            cout << ( i == 'S' ? 'E' : 'S' );\n        cout << '\\n';\n    }\n}\n```\n\n## problem C\n\n感謝 [En-ming Huang](https://www.facebook.com/enminghuang1) 大大提供\n要 solution 請去找他\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint input[maxN], l;\nchar out[maxN][2], print[maxN];\n\nbool check ( int idx, char now ){\n    if ( idx == l ){\n        cout << print << '\\n';\n        return true;\n    }\n    for ( int i = 0 ; i < 2 ; i++ ){\n        if ( out[idx][i] != now )\n            continue;\n        print[idx] = out[idx][i];\n        if ( idx == l - 1 )\n            print[idx + 1] = out[idx][!i];\n        return check ( idx + 1, out[idx][!i] );\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n, idx;\n    set < int > prime;\n    map < int, char > lib;\n    cin >> t;\n    for (int i = 1; i <= t; i++){\n        cin >> n >> l;\n        memset ( print, 0, sizeof print );\n        prime.clear();\n        lib.clear();\n        cout << \"Case #\" << i << \": \";\n        for ( int i = 0 ; i < l ; i++ ){\n            cin >> input[i];\n            for ( int j = 2 ; j <= n ; j++ ){\n                if ( input[i] % j == 0 ){\n                    prime.insert ( j );\n                    prime.insert ( input[i] / j );\n                    break;\n                }\n            }\n        }\n\n        idx = 0;\n        for ( auto i: prime )\n            lib[i] = 'A' + idx++;\n        for ( int i = 0 ; i < l ; i++ )\n            for ( int j = 2 ; j <= n ; j++ )\n                if ( input[i] % j == 0 ){\n                    out[i][0] = lib[j];\n                    out[i][1] = lib[input[i] / j];\n                    break;\n                }\n        for ( int i = 0 ; i < 2 ; i++ )\n            if ( check ( 0, out[0][i] ) )\n                break;\n    }\n    return 0;\n}\n```\n\n## 後記\n\n這場打起來感覺好廢\n最近比較少寫演算法競賽的題目\n幾乎都是在讀新東西\n手感感覺不是很好\n教練，我想要拿 T-Shirt\np.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！\n下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打\n而且時間上來說是 CodeForces 的 usaul time\n中國人應該不少（汗\n1A 1B 1C 要有一場前 1500 名才能進去啊（遠望\n覺得有點難@@\n\n最後放個計分板截圖\n![](scb.jpg)\n\n寫完這篇文章，在本地端用 hexo 編譯預覽出來後\n發現圖片邊緣有白框\n。。。\n好樣的，我又要來修 css 配置了\n工作量 up up\n = =","source":"_posts/GCJ-2019-QuR.md","raw":"---\ntitle: 'Google Code Jam 2019 Qualification Round'\ndate: 2019-04-09 15:21:21\ntags:\n - GCJ\n - Full Contest Solution\n---\n\n## 前言\n\n我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）\n然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了\n\n只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了\n<!--more-->\n下一場是在這週六晚上九點～十一點半\n撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走\n\n總之，過 Qualification Round 應該就算比去年好了\n去年在耍廢直接爆炸。。。\n\n希望今年可以去 Round 2\n\n先放上這次的[題目連結](https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705)\n\n## problem A\n\n### 題目\n\n現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了\n然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$\n**多筆測資**\n\n### 解法\n\n顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$\n一臉就是在跟你說開 string 存啊\n所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$\n然後把這兩個數字輸出\n**注意不能有前導零**\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, mi;\n    string n;\n    cin >> t;\n    for ( int tms = 1 ; tms <= t ; tms++ ){\n        cout << \"Case #\" << tms << \": \";\n        cin >> n;\n        mi = INF;\n        for ( int i = 0 ; i < n.size() ; i++ ){\n            if ( n[i] == '4' ){\n                mi = min ( mi, i );\n                cout << '3';\n            }\n            else\n                cout << n[i];\n        }\n\n        cout << ' ';\n\n        for ( int i = mi ; i < n.size() ; i++ )\n            cout << ( n[i] == '4' )\n        cout << '\\n';\n    }\n}\n```\n\n### 後記\n我還沒有注意到這題有保證輸入有 $4$\n也沒有注意到這題要求輸出都要是正整數\n運氣真好，歪歪得正\n\n\n## problem B\n\n### 題目\n\n給定一張二維圖以及一條從左上到右下的路線\n求一條不重複的另外一條路線\n所謂的路線重複是指 $a \\to b$ 這個邊同時出現在兩條路線中\n然後輸入都是SESE這樣，代表從起點開始他往哪些位置走\n並且保證只會往東（右）以及往南（下）走\n詳細請看這張圖\n![](pB.jpg)\n\n### 解法\n\n#### $O ( N ^ 2 )$\n\n垃圾如我，肯定只會寫 $N ^ 2$ 的解法\n簡單來說就是 dp\n我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存\n然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）\n接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）\n所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點\n\n不過這樣做有小地方需要注意一下\n理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ & $dp[i][j - 1]$ 轉移過來\n所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上\n如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來\n但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）\n因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移\n啊如果還是都可以拿，那就真的隨便了\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define mp make_pair\ntypedef pair < short, char > psc;\n\nbool lib[maxN][maxN];\npsc str[maxN][maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n, x, y;\n    string data;\n    cin >> t;\n    for ( int tms = 1 ; tms <= t ; tms++ ){\n        cin >> n >> data;\n        memset ( lib, 0, sizeof lib );\n        for ( int i = 0 ; i <= n ; i++ ){\n            for ( int j = 0 ; j <= n ; j++ ){\n                str[i][j] = mp ( 0, ' ' );\n            }\n        }\n        x = 1, y = 1;\n        for ( auto i: data ){\n            lib[x][y] = true;\n            i == 'S' ? x++ : y++;\n        }\n        lib[x][y] = true;\n        str[1][1] = mp ( 0, ' ' );\n\n        for ( int i = 2 ; i <= n ; i++ ){\n            if ( lib[1][i] ){\n                if ( !lib[1][i - 1] ){\n                    str[1][i] = str[1][i - 1];\n                    str[1][i].F++;\n                    str[1][i].S = 'E';\n                }\n            }\n            else{\n                str[1][i] = str[1][i - 1];\n                str[1][i].F++;\n                str[1][i].S = 'E';\n            }\n        }\n\n        for ( int i = 2 ; i <= n ; i++ ){\n            if ( lib[i][1] ){\n                if ( !lib[i - 1][1] ){\n                    str[i][1] = str[i - 1][1];\n                    str[i][1].F++;\n                    str[i][1].S = 'S';\n                }\n            }\n            else{\n                str[i][1] = str[i - 1][1];\n                str[i][1].F++;\n                str[i][1].S = 'S';\n            }\n            for ( int j = 2 ; j <= n ; j++ ){\n                if ( lib[i][j] ){\n                    if ( !lib[i][j - 1] ){\n                        str[i][j] = str[i][j - 1];\n                        str[i][j].F++;\n                        str[i][j].S = 'E';\n                    }\n                    else{\n                        str[i][j] = str[i - 1][j];\n                        str[i][j].F++;\n                        str[i][j].S = 'S';\n                    }\n                }\n                else{\n                    if ( str[i][j - 1].F > str[i - 1][j].F ){\n                        str[i][j] = str[i][j - 1];\n                        str[i][j].S = 'E';\n                    }\n                    else{\n                        str[i][j] = str[i - 1][j];\n                        str[i][j].S = 'S';\n                    }\n                    str[i][j].F++;\n                }\n            }\n        }\n\n        data = \"\";\n        x = y = n;\n        while ( str[x][y].S != ' ' ){\n            data += str[x][y].S;\n            str[x][y].S == 'S' ? x-- : y--;\n        }\n        reverse ( data.begin(), data.end() );\n        cout << \"Case #\" << tms << \": \" << data << '\\n';\n    }\n}\n```\n\n#### $O ( N )$\n\n沒錯，$O ( N )$\n我後來才發現我TMD被哏到了\n只要把 S E 反轉就好啊\n讀到 S 輸出 E ，反之讀到 E 輸出 S\n這樣就會變成從左上到右下的對稱\n所以路線不會重複。。。\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n;\n    string str;\n    cin >> t;\n    while ( t-- && cin >> n >> str ){\n        for ( auto i: str )\n            cout << ( i == 'S' ? 'E' : 'S' );\n        cout << '\\n';\n    }\n}\n```\n\n## problem C\n\n感謝 [En-ming Huang](https://www.facebook.com/enminghuang1) 大大提供\n要 solution 請去找他\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint input[maxN], l;\nchar out[maxN][2], print[maxN];\n\nbool check ( int idx, char now ){\n    if ( idx == l ){\n        cout << print << '\\n';\n        return true;\n    }\n    for ( int i = 0 ; i < 2 ; i++ ){\n        if ( out[idx][i] != now )\n            continue;\n        print[idx] = out[idx][i];\n        if ( idx == l - 1 )\n            print[idx + 1] = out[idx][!i];\n        return check ( idx + 1, out[idx][!i] );\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n, idx;\n    set < int > prime;\n    map < int, char > lib;\n    cin >> t;\n    for (int i = 1; i <= t; i++){\n        cin >> n >> l;\n        memset ( print, 0, sizeof print );\n        prime.clear();\n        lib.clear();\n        cout << \"Case #\" << i << \": \";\n        for ( int i = 0 ; i < l ; i++ ){\n            cin >> input[i];\n            for ( int j = 2 ; j <= n ; j++ ){\n                if ( input[i] % j == 0 ){\n                    prime.insert ( j );\n                    prime.insert ( input[i] / j );\n                    break;\n                }\n            }\n        }\n\n        idx = 0;\n        for ( auto i: prime )\n            lib[i] = 'A' + idx++;\n        for ( int i = 0 ; i < l ; i++ )\n            for ( int j = 2 ; j <= n ; j++ )\n                if ( input[i] % j == 0 ){\n                    out[i][0] = lib[j];\n                    out[i][1] = lib[input[i] / j];\n                    break;\n                }\n        for ( int i = 0 ; i < 2 ; i++ )\n            if ( check ( 0, out[0][i] ) )\n                break;\n    }\n    return 0;\n}\n```\n\n## 後記\n\n這場打起來感覺好廢\n最近比較少寫演算法競賽的題目\n幾乎都是在讀新東西\n手感感覺不是很好\n教練，我想要拿 T-Shirt\np.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！\n下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打\n而且時間上來說是 CodeForces 的 usaul time\n中國人應該不少（汗\n1A 1B 1C 要有一場前 1500 名才能進去啊（遠望\n覺得有點難@@\n\n最後放個計分板截圖\n![](scb.jpg)\n\n寫完這篇文章，在本地端用 hexo 編譯預覽出來後\n發現圖片邊緣有白框\n。。。\n好樣的，我又要來修 css 配置了\n工作量 up up\n = =","slug":"GCJ-2019-QuR","published":1,"updated":"2020-05-03T10:27:23.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndq50007f19p7paw14jr","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）<br>然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了</p><p>只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了</p><a id=\"more\"></a><p>下一場是在這週六晚上九點～十一點半<br>撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走</p><p>總之，過 Qualification Round 應該就算比去年好了<br>去年在耍廢直接爆炸。。。</p><p>希望今年可以去 Round 2</p><p>先放上這次的<a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705\" target=\"_blank\" rel=\"noopener\">題目連結</a></p><h2 id=\"problem-A\"><a class=\"header-anchor\" href=\"#problem-A\"></a>problem A</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了<br>然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$<br><strong>多筆測資</strong></p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$<br>一臉就是在跟你說開 string 存啊<br>所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$<br>然後把這兩個數字輸出<br><strong>注意不能有前導零</strong></p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, mi;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> tms = <span class=\"number\">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; tms &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">        mi = INF;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n.size() ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( n[i] == <span class=\"string\">'4'</span> )&#123;</span><br><span class=\"line\">                mi = min ( mi, i );</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'3'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; n[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = mi ; i &lt; n.size() ; i++ )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ( n[i] == <span class=\"string\">'4'</span> )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h3><p>我還沒有注意到這題有保證輸入有 $4$<br>也沒有注意到這題要求輸出都要是正整數<br>運氣真好，歪歪得正</p><h2 id=\"problem-B\"><a class=\"header-anchor\" href=\"#problem-B\"></a>problem B</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一張二維圖以及一條從左上到右下的路線<br>求一條不重複的另外一條路線<br>所謂的路線重複是指 $a \\to b$ 這個邊同時出現在兩條路線中<br>然後輸入都是SESE這樣，代表從起點開始他往哪些位置走<br>並且保證只會往東（右）以及往南（下）走<br>詳細請看這張圖<br><img src=\"pB.jpg\" alt=\"\"></p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><h4 id=\"O-N-2\"><a class=\"header-anchor\" href=\"#O-N-2\"></a>$O ( N ^ 2 )$</h4><p>垃圾如我，肯定只會寫 $N ^ 2$ 的解法<br>簡單來說就是 dp<br>我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存<br>然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）<br>接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）<br>所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點</p><p>不過這樣做有小地方需要注意一下<br>理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ &amp; $dp[i][j - 1]$ 轉移過來<br>所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上<br>如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來<br>但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）<br>因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移<br>啊如果還是都可以拿，那就真的隨便了</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mp make_pair</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; short, <span class=\"keyword\">char</span> &gt; psc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lib[maxN][maxN];</span><br><span class=\"line\">psc str[maxN][maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n, x, y;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> data;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> tms = <span class=\"number\">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; data;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( lib, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> lib );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                str[i][j] = mp ( <span class=\"number\">0</span>, <span class=\"string\">' '</span> );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x = <span class=\"number\">1</span>, y = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )&#123;</span><br><span class=\"line\">            lib[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            i == <span class=\"string\">'S'</span> ? x++ : y++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lib[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        str[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = mp ( <span class=\"number\">0</span>, <span class=\"string\">' '</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( lib[<span class=\"number\">1</span>][i] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( !lib[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i] = str[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i].F++;</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i] = str[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i].F++;</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( lib[i][<span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( !lib[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>] = str[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>].F++;</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>] = str[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>].F++;</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( lib[i][j] )&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( !lib[i][j - <span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                        str[i][j] = str[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                        str[i][j].F++;</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        str[i][j] = str[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                        str[i][j].F++;</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( str[i][j - <span class=\"number\">1</span>].F &gt; str[i - <span class=\"number\">1</span>][j].F )&#123;</span><br><span class=\"line\">                        str[i][j] = str[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        str[i][j] = str[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    str[i][j].F++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        x = y = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( str[x][y].S != <span class=\"string\">' '</span> )&#123;</span><br><span class=\"line\">            data += str[x][y].S;</span><br><span class=\"line\">            str[x][y].S == <span class=\"string\">'S'</span> ? x-- : y--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse ( data.begin(), data.end() );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; tms &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; data &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"O-N\"><a class=\"header-anchor\" href=\"#O-N\"></a>$O ( N )$</h4><p>沒錯，$O ( N )$<br>我後來才發現我TMD被哏到了<br>只要把 S E 反轉就好啊<br>讀到 S 輸出 E ，反之讀到 E 輸出 S<br>這樣就會變成從左上到右下的對稱<br>所以路線不會重複。。。</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- &amp;&amp; <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; str )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ( i == <span class=\"string\">'S'</span> ? <span class=\"string\">'E'</span> : <span class=\"string\">'S'</span> );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-C\"><a class=\"header-anchor\" href=\"#problem-C\"></a>problem C</h2><p>感謝 <a href=\"https://www.facebook.com/enminghuang1\" target=\"_blank\" rel=\"noopener\">En-ming Huang</a> 大大提供<br>要 solution 請去找他</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> input[maxN], l;</span><br><span class=\"line\"><span class=\"keyword\">char</span> out[maxN][<span class=\"number\">2</span>], print[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span> <span class=\"params\">( <span class=\"keyword\">int</span> idx, <span class=\"keyword\">char</span> now )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( idx == l )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; print &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( out[idx][i] != now )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        print[idx] = out[idx][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( idx == l - <span class=\"number\">1</span> )</span><br><span class=\"line\">            print[idx + <span class=\"number\">1</span>] = out[idx][!i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check ( idx + <span class=\"number\">1</span>, out[idx][!i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n, idx;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; prime;</span><br><span class=\"line\">    <span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= t; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( print, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> print );</span><br><span class=\"line\">        prime.clear();</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; l ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; input[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( input[i] % j == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                    prime.insert ( j );</span><br><span class=\"line\">                    prime.insert ( input[i] / j );</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: prime )</span><br><span class=\"line\">            lib[i] = <span class=\"string\">'A'</span> + idx++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; l ; i++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( input[i] % j == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                    out[i][<span class=\"number\">0</span>] = lib[j];</span><br><span class=\"line\">                    out[i][<span class=\"number\">1</span>] = lib[input[i] / j];</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++ )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( check ( <span class=\"number\">0</span>, out[<span class=\"number\">0</span>][i] ) )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記-v2\"><a class=\"header-anchor\" href=\"#後記-v2\"></a>後記</h2><p>這場打起來感覺好廢<br>最近比較少寫演算法競賽的題目<br>幾乎都是在讀新東西<br>手感感覺不是很好<br>教練，我想要拿 T-Shirt<br>p.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！<br>下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打<br>而且時間上來說是 CodeForces 的 usaul time<br>中國人應該不少（汗<br>1A 1B 1C 要有一場前 1500 名才能進去啊（遠望<br>覺得有點難@@</p><p>最後放個計分板截圖<br><img src=\"scb.jpg\" alt=\"\"></p><p>寫完這篇文章，在本地端用 hexo 編譯預覽出來後<br>發現圖片邊緣有白框<br>。。。<br>好樣的，我又要來修 css 配置了<br>工作量 up up<br>= =</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）<br>然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了</p><p>只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了</p>","more":"<p>下一場是在這週六晚上九點～十一點半<br>撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走</p><p>總之，過 Qualification Round 應該就算比去年好了<br>去年在耍廢直接爆炸。。。</p><p>希望今年可以去 Round 2</p><p>先放上這次的<a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705\" target=\"_blank\" rel=\"noopener\">題目連結</a></p><h2 id=\"problem-A\"><a class=\"header-anchor\" href=\"#problem-A\"></a>problem A</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了<br>然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$<br><strong>多筆測資</strong></p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$<br>一臉就是在跟你說開 string 存啊<br>所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$<br>然後把這兩個數字輸出<br><strong>注意不能有前導零</strong></p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, mi;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> tms = <span class=\"number\">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; tms &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">        mi = INF;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n.size() ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( n[i] == <span class=\"string\">'4'</span> )&#123;</span><br><span class=\"line\">                mi = min ( mi, i );</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'3'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; n[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = mi ; i &lt; n.size() ; i++ )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ( n[i] == <span class=\"string\">'4'</span> )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h3><p>我還沒有注意到這題有保證輸入有 $4$<br>也沒有注意到這題要求輸出都要是正整數<br>運氣真好，歪歪得正</p><h2 id=\"problem-B\"><a class=\"header-anchor\" href=\"#problem-B\"></a>problem B</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一張二維圖以及一條從左上到右下的路線<br>求一條不重複的另外一條路線<br>所謂的路線重複是指 $a \\to b$ 這個邊同時出現在兩條路線中<br>然後輸入都是SESE這樣，代表從起點開始他往哪些位置走<br>並且保證只會往東（右）以及往南（下）走<br>詳細請看這張圖<br><img src=\"pB.jpg\" alt=\"\"></p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><h4 id=\"O-N-2\"><a class=\"header-anchor\" href=\"#O-N-2\"></a>$O ( N ^ 2 )$</h4><p>垃圾如我，肯定只會寫 $N ^ 2$ 的解法<br>簡單來說就是 dp<br>我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存<br>然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）<br>接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）<br>所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點</p><p>不過這樣做有小地方需要注意一下<br>理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ &amp; $dp[i][j - 1]$ 轉移過來<br>所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上<br>如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來<br>但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）<br>因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移<br>啊如果還是都可以拿，那就真的隨便了</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mp make_pair</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; short, <span class=\"keyword\">char</span> &gt; psc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lib[maxN][maxN];</span><br><span class=\"line\">psc str[maxN][maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n, x, y;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> data;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> tms = <span class=\"number\">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; data;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( lib, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> lib );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                str[i][j] = mp ( <span class=\"number\">0</span>, <span class=\"string\">' '</span> );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x = <span class=\"number\">1</span>, y = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )&#123;</span><br><span class=\"line\">            lib[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            i == <span class=\"string\">'S'</span> ? x++ : y++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lib[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        str[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = mp ( <span class=\"number\">0</span>, <span class=\"string\">' '</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( lib[<span class=\"number\">1</span>][i] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( !lib[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i] = str[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i].F++;</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i] = str[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i].F++;</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( lib[i][<span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( !lib[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>] = str[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>].F++;</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>] = str[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>].F++;</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( lib[i][j] )&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( !lib[i][j - <span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                        str[i][j] = str[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                        str[i][j].F++;</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        str[i][j] = str[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                        str[i][j].F++;</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( str[i][j - <span class=\"number\">1</span>].F &gt; str[i - <span class=\"number\">1</span>][j].F )&#123;</span><br><span class=\"line\">                        str[i][j] = str[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        str[i][j] = str[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    str[i][j].F++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        x = y = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( str[x][y].S != <span class=\"string\">' '</span> )&#123;</span><br><span class=\"line\">            data += str[x][y].S;</span><br><span class=\"line\">            str[x][y].S == <span class=\"string\">'S'</span> ? x-- : y--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse ( data.begin(), data.end() );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; tms &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; data &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"O-N\"><a class=\"header-anchor\" href=\"#O-N\"></a>$O ( N )$</h4><p>沒錯，$O ( N )$<br>我後來才發現我TMD被哏到了<br>只要把 S E 反轉就好啊<br>讀到 S 輸出 E ，反之讀到 E 輸出 S<br>這樣就會變成從左上到右下的對稱<br>所以路線不會重複。。。</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- &amp;&amp; <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; str )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ( i == <span class=\"string\">'S'</span> ? <span class=\"string\">'E'</span> : <span class=\"string\">'S'</span> );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-C\"><a class=\"header-anchor\" href=\"#problem-C\"></a>problem C</h2><p>感謝 <a href=\"https://www.facebook.com/enminghuang1\" target=\"_blank\" rel=\"noopener\">En-ming Huang</a> 大大提供<br>要 solution 請去找他</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> input[maxN], l;</span><br><span class=\"line\"><span class=\"keyword\">char</span> out[maxN][<span class=\"number\">2</span>], print[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span> <span class=\"params\">( <span class=\"keyword\">int</span> idx, <span class=\"keyword\">char</span> now )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( idx == l )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; print &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( out[idx][i] != now )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        print[idx] = out[idx][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( idx == l - <span class=\"number\">1</span> )</span><br><span class=\"line\">            print[idx + <span class=\"number\">1</span>] = out[idx][!i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check ( idx + <span class=\"number\">1</span>, out[idx][!i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n, idx;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; prime;</span><br><span class=\"line\">    <span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= t; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( print, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> print );</span><br><span class=\"line\">        prime.clear();</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; l ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; input[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( input[i] % j == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                    prime.insert ( j );</span><br><span class=\"line\">                    prime.insert ( input[i] / j );</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: prime )</span><br><span class=\"line\">            lib[i] = <span class=\"string\">'A'</span> + idx++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; l ; i++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( input[i] % j == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                    out[i][<span class=\"number\">0</span>] = lib[j];</span><br><span class=\"line\">                    out[i][<span class=\"number\">1</span>] = lib[input[i] / j];</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++ )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( check ( <span class=\"number\">0</span>, out[<span class=\"number\">0</span>][i] ) )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記-v2\"><a class=\"header-anchor\" href=\"#後記-v2\"></a>後記</h2><p>這場打起來感覺好廢<br>最近比較少寫演算法競賽的題目<br>幾乎都是在讀新東西<br>手感感覺不是很好<br>教練，我想要拿 T-Shirt<br>p.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！<br>下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打<br>而且時間上來說是 CodeForces 的 usaul time<br>中國人應該不少（汗<br>1A 1B 1C 要有一場前 1500 名才能進去啊（遠望<br>覺得有點難@@</p><p>最後放個計分板截圖<br><img src=\"scb.jpg\" alt=\"\"></p><p>寫完這篇文章，在本地端用 hexo 編譯預覽出來後<br>發現圖片邊緣有白框<br>。。。<br>好樣的，我又要來修 css 配置了<br>工作量 up up<br>= =</p><!-- rebuild by neat -->"},{"title":"[TIOJ][1615] A! + B! problem","date":"2018-10-28T12:13:43.000Z","_content":"\n## 前言\n\n好久沒有寫 code 發題解了\n最近因為一些事情沒有時間（也沒有心情）認真寫 code\n（因為上次 CodeForces 連續掉分我心情有點糟）\n（啊還有學科校內爆炸也是我心情糟的原因之一）\n（開始懷疑我到底這一年努力是為了什麼，之類的）\n<!--more-->\n然後今天想說寫個題目、發個題解刷一下存在感，之類的\n所以跑去 TIOJ 翻題目\n然後看到這題\n。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼\n\n## 題目 & 解法\n\n大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數\n原網址我放[在這](https://tioj.ck.tp.edu.tw/problems/1615)\n\n很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做\n所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數\n因為要加一，所以我想了很久\n感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）\n但是我真的沒有想法\n所以就寫了個 $O ( N^2 )$ 的解法\n。。。然後過了，wtf\n就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查\n就這樣。。。\n我一臉懵逼的坐在電腦前傻了一下\n才開始動手打這篇文章\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 1000000\n\nbitset < maxN > lib;\nvector < LL > prime;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n    #define int LL\n\n    lib[0] = lib[1] = true;\n    for ( int i = 2 ; i < maxN ; i++ ){\n        if ( !lib[i] ){\n            prime.push_back ( i );\n            for ( int j = i ; j < maxN ; j += i )\n                lib[j] = true;\n        }\n    }\n\n    int a, b, len = prime.size();\n    LL ans, stp;\n    while ( cin >> a >> b ){\n        if ( a > b )\n            swap ( a, b );\n        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();\n        stp = 1;\n        for ( int i = a + 1 ; i <= b ; i++ ){\n            stp *= i;\n        }\n        stp++;\n        for ( int i = 0 ; i < ans ; i++ ){\n            while ( stp % prime[i] == 0 ){\n                stp /= prime[i];\n            }\n        }\n\n        for ( int i = ans ; i < len ; i++ ){\n            if ( !( stp % prime[i] ) ){\n                ans++;\n                while ( stp % prime[i] == 0 )\n                    stp /= prime[i];\n            }\n        }\n\n        if ( stp > maxN )\n            ans++;\n\n        cout << ans << '\\n';\n    }\n}\n```\n\n## 後記\n\n最近特殊選才有點忙\n加上 CodeForces，校內賽的陰影\n我可能會暫時停筆一下啦XD\n沒有意外，等到特選告一段落會繼續。。。吧\n等等印象中好像有 CodeForces，啊不過有點晚\n會不會打還是未知數\n下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧\n在特選放榜前我應該不會繼續認真搞比賽了\n因為我不知道在放榜後我會何去何從（笑\n先讀點書好像比較保險\n\n不過如果特選有好結果我還是會認真搞 TOI 入營考啦\n已經是最後一年了，能不能進去就聽由天命囉\n\n然後，謝謝看到這邊的你\n（我這麼寫怎麼有點感傷啊XD）\n我已經很久沒有發文了，希望大家還有在看\n謝謝各位一直以來對我的支持 <3","source":"_posts/TIOJ-1615.md","raw":"---\ntitle: '[TIOJ][1615] A! + B! problem'\ndate: 2018-10-28 20:13:43\ntags:\n - TIOJ\n - math\n---\n\n## 前言\n\n好久沒有寫 code 發題解了\n最近因為一些事情沒有時間（也沒有心情）認真寫 code\n（因為上次 CodeForces 連續掉分我心情有點糟）\n（啊還有學科校內爆炸也是我心情糟的原因之一）\n（開始懷疑我到底這一年努力是為了什麼，之類的）\n<!--more-->\n然後今天想說寫個題目、發個題解刷一下存在感，之類的\n所以跑去 TIOJ 翻題目\n然後看到這題\n。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼\n\n## 題目 & 解法\n\n大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數\n原網址我放[在這](https://tioj.ck.tp.edu.tw/problems/1615)\n\n很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做\n所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數\n因為要加一，所以我想了很久\n感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）\n但是我真的沒有想法\n所以就寫了個 $O ( N^2 )$ 的解法\n。。。然後過了，wtf\n就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查\n就這樣。。。\n我一臉懵逼的坐在電腦前傻了一下\n才開始動手打這篇文章\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 1000000\n\nbitset < maxN > lib;\nvector < LL > prime;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n    #define int LL\n\n    lib[0] = lib[1] = true;\n    for ( int i = 2 ; i < maxN ; i++ ){\n        if ( !lib[i] ){\n            prime.push_back ( i );\n            for ( int j = i ; j < maxN ; j += i )\n                lib[j] = true;\n        }\n    }\n\n    int a, b, len = prime.size();\n    LL ans, stp;\n    while ( cin >> a >> b ){\n        if ( a > b )\n            swap ( a, b );\n        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();\n        stp = 1;\n        for ( int i = a + 1 ; i <= b ; i++ ){\n            stp *= i;\n        }\n        stp++;\n        for ( int i = 0 ; i < ans ; i++ ){\n            while ( stp % prime[i] == 0 ){\n                stp /= prime[i];\n            }\n        }\n\n        for ( int i = ans ; i < len ; i++ ){\n            if ( !( stp % prime[i] ) ){\n                ans++;\n                while ( stp % prime[i] == 0 )\n                    stp /= prime[i];\n            }\n        }\n\n        if ( stp > maxN )\n            ans++;\n\n        cout << ans << '\\n';\n    }\n}\n```\n\n## 後記\n\n最近特殊選才有點忙\n加上 CodeForces，校內賽的陰影\n我可能會暫時停筆一下啦XD\n沒有意外，等到特選告一段落會繼續。。。吧\n等等印象中好像有 CodeForces，啊不過有點晚\n會不會打還是未知數\n下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧\n在特選放榜前我應該不會繼續認真搞比賽了\n因為我不知道在放榜後我會何去何從（笑\n先讀點書好像比較保險\n\n不過如果特選有好結果我還是會認真搞 TOI 入營考啦\n已經是最後一年了，能不能進去就聽由天命囉\n\n然後，謝謝看到這邊的你\n（我這麼寫怎麼有點感傷啊XD）\n我已經很久沒有發文了，希望大家還有在看\n謝謝各位一直以來對我的支持 <3","slug":"TIOJ-1615","published":1,"updated":"2020-05-03T10:27:23.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndq70009f19pec401d4i","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>好久沒有寫 code 發題解了<br>最近因為一些事情沒有時間（也沒有心情）認真寫 code<br>（因為上次 CodeForces 連續掉分我心情有點糟）<br>（啊還有學科校內爆炸也是我心情糟的原因之一）<br>（開始懷疑我到底這一年努力是為了什麼，之類的）</p><a id=\"more\"></a><p>然後今天想說寫個題目、發個題解刷一下存在感，之類的<br>所以跑去 TIOJ 翻題目<br>然後看到這題<br>。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼</p><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p>大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數<br>原網址我放<a href=\"https://tioj.ck.tp.edu.tw/problems/1615\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做<br>所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數<br>因為要加一，所以我想了很久<br>感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）<br>但是我真的沒有想法<br>所以就寫了個 $O ( N^2 )$ 的解法<br>。。。然後過了，wtf<br>就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查<br>就這樣。。。<br>我一臉懵逼的坐在電腦前傻了一下<br>才開始動手打這篇文章</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bitset</span> &lt; maxN &gt; lib;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; LL &gt; prime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    lib[<span class=\"number\">0</span>] = lib[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt; maxN ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !lib[i] )&#123;</span><br><span class=\"line\">            prime.push_back ( i );</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i ; j &lt; maxN ; j += i )</span><br><span class=\"line\">                lib[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, len = prime.size();</span><br><span class=\"line\">    LL ans, stp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a &gt; b )</span><br><span class=\"line\">            swap ( a, b );</span><br><span class=\"line\">        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();</span><br><span class=\"line\">        stp = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = a + <span class=\"number\">1</span> ; i &lt;= b ; i++ )&#123;</span><br><span class=\"line\">            stp *= i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stp++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; ans ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ( stp % prime[i] == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                stp /= prime[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = ans ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !( stp % prime[i] ) )&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ( stp % prime[i] == <span class=\"number\">0</span> )</span><br><span class=\"line\">                    stp /= prime[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( stp &gt; maxN )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>最近特殊選才有點忙<br>加上 CodeForces，校內賽的陰影<br>我可能會暫時停筆一下啦XD<br>沒有意外，等到特選告一段落會繼續。。。吧<br>等等印象中好像有 CodeForces，啊不過有點晚<br>會不會打還是未知數<br>下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧<br>在特選放榜前我應該不會繼續認真搞比賽了<br>因為我不知道在放榜後我會何去何從（笑<br>先讀點書好像比較保險</p><p>不過如果特選有好結果我還是會認真搞 TOI 入營考啦<br>已經是最後一年了，能不能進去就聽由天命囉</p><p>然後，謝謝看到這邊的你<br>（我這麼寫怎麼有點感傷啊XD）<br>我已經很久沒有發文了，希望大家還有在看<br>謝謝各位一直以來對我的支持 &lt;3</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>好久沒有寫 code 發題解了<br>最近因為一些事情沒有時間（也沒有心情）認真寫 code<br>（因為上次 CodeForces 連續掉分我心情有點糟）<br>（啊還有學科校內爆炸也是我心情糟的原因之一）<br>（開始懷疑我到底這一年努力是為了什麼，之類的）</p>","more":"<p>然後今天想說寫個題目、發個題解刷一下存在感，之類的<br>所以跑去 TIOJ 翻題目<br>然後看到這題<br>。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼</p><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p>大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數<br>原網址我放<a href=\"https://tioj.ck.tp.edu.tw/problems/1615\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做<br>所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數<br>因為要加一，所以我想了很久<br>感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）<br>但是我真的沒有想法<br>所以就寫了個 $O ( N^2 )$ 的解法<br>。。。然後過了，wtf<br>就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查<br>就這樣。。。<br>我一臉懵逼的坐在電腦前傻了一下<br>才開始動手打這篇文章</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bitset</span> &lt; maxN &gt; lib;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; LL &gt; prime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    lib[<span class=\"number\">0</span>] = lib[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt; maxN ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !lib[i] )&#123;</span><br><span class=\"line\">            prime.push_back ( i );</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i ; j &lt; maxN ; j += i )</span><br><span class=\"line\">                lib[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, len = prime.size();</span><br><span class=\"line\">    LL ans, stp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a &gt; b )</span><br><span class=\"line\">            swap ( a, b );</span><br><span class=\"line\">        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();</span><br><span class=\"line\">        stp = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = a + <span class=\"number\">1</span> ; i &lt;= b ; i++ )&#123;</span><br><span class=\"line\">            stp *= i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stp++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; ans ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ( stp % prime[i] == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                stp /= prime[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = ans ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !( stp % prime[i] ) )&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ( stp % prime[i] == <span class=\"number\">0</span> )</span><br><span class=\"line\">                    stp /= prime[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( stp &gt; maxN )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>最近特殊選才有點忙<br>加上 CodeForces，校內賽的陰影<br>我可能會暫時停筆一下啦XD<br>沒有意外，等到特選告一段落會繼續。。。吧<br>等等印象中好像有 CodeForces，啊不過有點晚<br>會不會打還是未知數<br>下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧<br>在特選放榜前我應該不會繼續認真搞比賽了<br>因為我不知道在放榜後我會何去何從（笑<br>先讀點書好像比較保險</p><p>不過如果特選有好結果我還是會認真搞 TOI 入營考啦<br>已經是最後一年了，能不能進去就聽由天命囉</p><p>然後，謝謝看到這邊的你<br>（我這麼寫怎麼有點感傷啊XD）<br>我已經很久沒有發文了，希望大家還有在看<br>謝謝各位一直以來對我的支持 &lt;3</p><!-- rebuild by neat -->"},{"title":"[TIOJ][1795] 咕嚕咕嚕呱啦呱啦","date":"2018-01-16T03:53:57.000Z","_content":"\n這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧\n\n## 題目\n\n題目連結[在這](https://tioj.ck.tp.edu.tw/problems/1795)\n\n給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$\n另外，任意一條邊的權重只有可能為 $0 or 1$\n<!--more-->\n\n\n## 解法\n\n只要做出最小生成樹以及最大生成樹就好了，證明如下\n假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：\n$$ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )$$\n又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\\le k\\e ub$ 的生成樹\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 100005\n\nstruct bridge{\n    int u, v, w;\n};\n\nstruct disjionSet{\n    int dis[maxN];\n\n    inline void Init ( void ){\n        for ( int i = 0 ; i < maxN ; i++ )\n            dis[i] = i;\n    }\n\n    inline int find ( int n ){\n        return dis[n] == n ? n : dis[n] = find ( dis[n] );\n    }\n\n    inline bool same ( int a, int b ){\n        return find ( a ) == find ( b );\n    }\n\n    inline void Union ( int a, int b ){\n        dis[find ( a )] = find ( b );\n    }\n};\n\nvector < bridge > edges;\n\ninline bool cmp ( bridge a, bridge b ){\n    return a.w < b.w;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, k, u, v, w, ub = 0, lb = 0;\n    disjionSet dis;\n    cin >> n >> m >> k;\n    while ( m-- ){\n        cin >> u >> v >> w;\n        edges.push_back ( bridge { u, v, w } );\n    }\n\n    sort ( edges.begin(), edges.end(), cmp );\n    dis.Init();\n    for ( auto i: edges ){\n        if ( dis.same ( i.u, i.v ) )\n            continue;\n\n        dis.Union ( i.u, i.v );\n        lb += i.w;\n    }\n\n\n    reverse ( edges.begin(), edges.end() );\n    dis.Init();\n    for ( auto i: edges ){\n        if ( dis.same ( i.u, i.v ) )\n            continue;\n\n        dis.Union ( i.u, i.v );\n        ub += i.w;\n    }\n\n    cout << ( lb <= k && k <= ub ? \"TAK\" : \"NIE\" ) << '\\n';\n}\n```","source":"_posts/TIOJ-1795.md","raw":"---\ntitle: '[TIOJ][1795] 咕嚕咕嚕呱啦呱啦'\ndate: 2018-01-16 11:53:57\ntags:\n - TIOJ\n - math\n---\n\n這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧\n\n## 題目\n\n題目連結[在這](https://tioj.ck.tp.edu.tw/problems/1795)\n\n給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$\n另外，任意一條邊的權重只有可能為 $0 or 1$\n<!--more-->\n\n\n## 解法\n\n只要做出最小生成樹以及最大生成樹就好了，證明如下\n假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：\n$$ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )$$\n又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\\le k\\e ub$ 的生成樹\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 100005\n\nstruct bridge{\n    int u, v, w;\n};\n\nstruct disjionSet{\n    int dis[maxN];\n\n    inline void Init ( void ){\n        for ( int i = 0 ; i < maxN ; i++ )\n            dis[i] = i;\n    }\n\n    inline int find ( int n ){\n        return dis[n] == n ? n : dis[n] = find ( dis[n] );\n    }\n\n    inline bool same ( int a, int b ){\n        return find ( a ) == find ( b );\n    }\n\n    inline void Union ( int a, int b ){\n        dis[find ( a )] = find ( b );\n    }\n};\n\nvector < bridge > edges;\n\ninline bool cmp ( bridge a, bridge b ){\n    return a.w < b.w;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, k, u, v, w, ub = 0, lb = 0;\n    disjionSet dis;\n    cin >> n >> m >> k;\n    while ( m-- ){\n        cin >> u >> v >> w;\n        edges.push_back ( bridge { u, v, w } );\n    }\n\n    sort ( edges.begin(), edges.end(), cmp );\n    dis.Init();\n    for ( auto i: edges ){\n        if ( dis.same ( i.u, i.v ) )\n            continue;\n\n        dis.Union ( i.u, i.v );\n        lb += i.w;\n    }\n\n\n    reverse ( edges.begin(), edges.end() );\n    dis.Init();\n    for ( auto i: edges ){\n        if ( dis.same ( i.u, i.v ) )\n            continue;\n\n        dis.Union ( i.u, i.v );\n        ub += i.w;\n    }\n\n    cout << ( lb <= k && k <= ub ? \"TAK\" : \"NIE\" ) << '\\n';\n}\n```","slug":"TIOJ-1795","published":1,"updated":"2020-05-03T10:27:23.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndq8000af19p8wm32wzu","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧</p><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>題目連結<a href=\"https://tioj.ck.tp.edu.tw/problems/1795\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$<br>另外，任意一條邊的權重只有可能為 $0 or 1$</p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>只要做出最小生成樹以及最大生成樹就好了，證明如下<br>假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：<br>$$ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )$$<br>又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\\le k\\e ub$ 的生成樹</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 100005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bridge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">disjionSet</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">            dis[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">        dis[find ( a )] = find ( b );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; bridge &gt; edges;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">cmp</span> <span class=\"params\">( bridge a, bridge b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, k, u, v, w, ub = <span class=\"number\">0</span>, lb = <span class=\"number\">0</span>;</span><br><span class=\"line\">    disjionSet dis;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class=\"line\">        edges.push_back ( bridge &#123; u, v, w &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class=\"line\">    dis.Init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dis.Union ( i.u, i.v );</span><br><span class=\"line\">        lb += i.w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    reverse ( edges.begin(), edges.end() );</span><br><span class=\"line\">    dis.Init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dis.Union ( i.u, i.v );</span><br><span class=\"line\">        ub += i.w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ( lb &lt;= k &amp;&amp; k &lt;= ub ? <span class=\"string\">\"TAK\"</span> : <span class=\"string\">\"NIE\"</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧</p><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>題目連結<a href=\"https://tioj.ck.tp.edu.tw/problems/1795\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$<br>另外，任意一條邊的權重只有可能為 $0 or 1$</p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>只要做出最小生成樹以及最大生成樹就好了，證明如下<br>假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：<br>$$ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )$$<br>又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\\le k\\e ub$ 的生成樹</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 100005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bridge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">disjionSet</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">            dis[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">        dis[find ( a )] = find ( b );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; bridge &gt; edges;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">cmp</span> <span class=\"params\">( bridge a, bridge b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, k, u, v, w, ub = <span class=\"number\">0</span>, lb = <span class=\"number\">0</span>;</span><br><span class=\"line\">    disjionSet dis;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class=\"line\">        edges.push_back ( bridge &#123; u, v, w &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class=\"line\">    dis.Init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dis.Union ( i.u, i.v );</span><br><span class=\"line\">        lb += i.w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    reverse ( edges.begin(), edges.end() );</span><br><span class=\"line\">    dis.Init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dis.Union ( i.u, i.v );</span><br><span class=\"line\">        ub += i.w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ( lb &lt;= k &amp;&amp; k &lt;= ub ? <span class=\"string\">\"TAK\"</span> : <span class=\"string\">\"NIE\"</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"[CF]Round 521","date":"2018-11-17T04:20:01.000Z","_content":"\n## 前言\n\n身為一個垃圾，當然要打的像垃圾一樣\n先是校內爆掉，現在換 div.3 爆掉\n。。。pC 沒開 long long 溢位被 hack 成智障的就是我\n坐等晚上 rating change\n沒意外應該會噴掉啦\n<!--more-->\n\n先放上所有題目的[連結](http://codeforces.com/contest/1077)\n\n## problem A\n\n### 題目\n\n大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步\n然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）\n\n### 解法\n\n阿不就直接暴力就好\n算一下會往左次往右幾次，算一下就好\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    #define int LL\n\n    int t, k, a, b, swp, ans;\n    cin >> t;\n    while ( t-- ){\n        cin >> a >> b >> k;\n        swp = a - b;\n        ans = swp * ( LL ) ( k / 2 );\n        if ( k & 1 )\n            ans += a;\n        cout << ans << '\\n';\n    }\n}\n```\n\n\n## problem B\n\n### 題目\n\n給定一排房屋現在是否有開燈\n通常關燈了就是在睡覺了\n\n題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈\n那麼那戶人家就會被干擾\n但是請注意，只有一邊的鄰居開燈並不會被干擾\n\n現在想要讓所有在睡覺的人都不會被干擾\n求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數\n\n### 解法\n\n因為只有一邊有開燈並不會被干擾\n也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了\n\n那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉\n順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, ans = 0, m;\n    cin >> n;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    for ( int i = 1 ; i < n - 1 ; i++ ){\n        if ( !data[i] && data[i - 1] && data[i + 1] )\n            lib.push_back ( i );\n    }\n\n    m = lib.size();\n    while ( lib.size() > 1 ){\n        if ( lib[1] - lib[0] == 2 ){\n            ans++;\n            lib.erase ( lib.begin() );\n            lib.erase ( lib.begin() );\n        }\n        else{\n            ans++;\n            lib.erase ( lib.begin() );\n        }\n    }\n\n    if ( !lib.empty() )\n        ans++;\n    cout << ans << '\\n';\n}\n```\n\n\n## problem C\n\n就是這題，我沒有開 long long 然後就被 hack 了\n名次噴掉 1500 多名\n\n### 題目\n\n給定一條長度為 $N$ 的序列\n我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和\n也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$\n求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的\n請列出數量，以及些解的位置\n\n因為題目有點難懂，我放上其中一個例子好了\n那現在看另外一個序列 $[ 8, 3, 5, 2 ]$\n1. 移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \\to 5 = 3 + 2$\n2. 移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \\to 8 = 3 + 5$\n\n### 解法\n\n1. 計算原先序列的總和\n2. 每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉\n3. 把 $sum$ 為奇數則返回步驟2\n4. 尋找 $\\frac{sum}{2}$ 是否出現於原序列中\n5. 檢查 $\\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次\n6. 如果有出現過兩次，那麼 i 就是其中一個答案\n7. 返回步驟 2\n\n有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數\n假設 $sum' = sum - a[i]，sum'$ 代表除了 $a[i]$ 以外的元素和\n既然一個序列為好的序列，代表說這個序列會被切成兩部分\n而這兩部分的和會一樣\n既然都會被切成兩個一樣的東西了，為什麼 $sum'$ 會是奇數\n這就矛盾了，所以 $sum'$ 一定為偶數\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define int LL\n\nmap < int, int > lib;\n\n#undef int\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    #define int LL\n\n    int n, sum = 0;\n    cin >> n;\n    vector < int > data ( n ), ans;\n    for ( auto &i: data ){\n        cin >> i;\n        sum += i;\n        lib[i]++;\n    }\n    for ( int i = 0 ; i < n ; i++ ){\n        sum -= data[i];\n        if ( sum & 1 ){\n            sum += data[i];\n            continue;\n        }\n        sum >>= 1;\n        if ( ( lib[sum] == 1 && sum != data[i] ) || lib[sum] > 1 ){\n            ans.push_back ( i + 1 );\n        }\n        sum <<= 1;\n        sum += data[i];\n    }\n\n    cout << ans.size() << '\\n';\n    for ( auto i: data )\n        cout << i << ' ';\n    cout << '\\n';\n}\n```\n\n\n## problem D\n\n### 題目\n\n給定一大小為 $N$ 的可重複集合 $S$\n求找出一大小為 $K$ 的可重複集合 $S' ( S'\\subseteq S )$ 且 $S'$ 在 $S$ 中出現次數最多\n\n**元素可重複，這件事情非常重要**\n\n### 解法\n\n我先做離散化，反正數字跟解法沒有關係\n接著紀錄每個數字出現幾次\n我先二分搜最多那個集合最多可以出現幾次\n然後按照次數輸出，反正只要符合要求的都行\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 200005\n\nint cnt[maxN], m, k, ma;\nvector < int > lib;\nmap < int, vector < int > > table;\n\ninline bool check ( int tms ){\n    int res = 0;\n    for ( int i = tms ; i < ma ; i++ )\n        for ( auto j: table[i] )\n            res += cnt[j] / tms;\n\n    return res >= k;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n\n    int n, l = 0, r = -1, mid;\n    cin >> n >> k;\n    vector < int > data ( n );\n    for ( auto &i: data )\n        cin >> i;\n    if ( n == k ){\n        for ( auto i: data )\n            cout << i << ' ';\n        cout << '\\n';\n        return 0;\n    }\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    m = lib.size();\n    for ( auto i: data ){\n        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;\n    }\n    for ( int i = 0 ; i < m ; i++ ){\n        r = max ( r, cnt[i] );\n        table[cnt[i]].push_back ( i );\n    }\n    ma = ++r;\n    mid = ( l + r ) >> 1;\n    while ( r - l > 1 ){\n        if ( check ( mid ) )\n            l = mid;\n        else\n            r = mid;\n        mid = ( l + r ) >> 1;\n    }\n\n    l = k;\n    for ( int i = 0 ; i < m ; i++ ){\n        for ( int j = 0 ; j < min ( cnt[i] / mid, l ) ; j++ )\n            cout << lib[i] << ' ';\n        l -= min ( cnt[i] / mid, l );\n        if ( !l )\n            break;\n    }\n    cout << '\\n';\n}\n```\n\n\n## problem E\n\n這題我賽中只有想到喇賽解法，賽後才想到正解\n\n### 題目\n\n給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$\n要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用\n且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）\n求最多可以使用多少題目\n**注意！你應該要最大會題目數量，而非天數**\n\n### 解法\n\n每舉第一天的題數，然後暴力往後找\n用 lower_bound 去尋找是個不錯的選擇\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 200005\n\nLL cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n\n    int n, m, ma, ans = -1, swp, idx, id;\n    cin >> n;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    m = lib.size();\n    for ( auto i: data )\n        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;\n\n    data.clear();\n    for ( int i = 0 ; i < m ; i++ ){\n        data.push_back ( cnt[i] );\n    }\n    sort ( data.begin(), data.end() );\n    ma = data.back() + 1;\n\n    for ( int i = 0 ; i < ma ; i++ ){\n        swp = idx = 0;\n        for ( int j = i ; j < ma && idx < m ; j <<= 1 ){\n            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();\n            if ( id < data.size() )\n                swp += j;\n            idx = id + 1;\n        }\n\n        ans = max ( ans, swp );\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n\n## 後記\n\n老實說我這場有點慘\npC 被 Hack，pE 賽中沒寫出來\n以我的實力來說不應該這樣子的\n因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@\n\n希望下一場可以好好發揮","source":"_posts/CFR521.md","raw":"---\ntitle: '[CF]Round 521'\ndate: 2018-11-17 12:20:01\ntags:\n - CodeForces\n - div.3\n - Full Contest Solution\n - dp\n---\n\n## 前言\n\n身為一個垃圾，當然要打的像垃圾一樣\n先是校內爆掉，現在換 div.3 爆掉\n。。。pC 沒開 long long 溢位被 hack 成智障的就是我\n坐等晚上 rating change\n沒意外應該會噴掉啦\n<!--more-->\n\n先放上所有題目的[連結](http://codeforces.com/contest/1077)\n\n## problem A\n\n### 題目\n\n大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步\n然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）\n\n### 解法\n\n阿不就直接暴力就好\n算一下會往左次往右幾次，算一下就好\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    #define int LL\n\n    int t, k, a, b, swp, ans;\n    cin >> t;\n    while ( t-- ){\n        cin >> a >> b >> k;\n        swp = a - b;\n        ans = swp * ( LL ) ( k / 2 );\n        if ( k & 1 )\n            ans += a;\n        cout << ans << '\\n';\n    }\n}\n```\n\n\n## problem B\n\n### 題目\n\n給定一排房屋現在是否有開燈\n通常關燈了就是在睡覺了\n\n題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈\n那麼那戶人家就會被干擾\n但是請注意，只有一邊的鄰居開燈並不會被干擾\n\n現在想要讓所有在睡覺的人都不會被干擾\n求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數\n\n### 解法\n\n因為只有一邊有開燈並不會被干擾\n也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了\n\n那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉\n順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, ans = 0, m;\n    cin >> n;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    for ( int i = 1 ; i < n - 1 ; i++ ){\n        if ( !data[i] && data[i - 1] && data[i + 1] )\n            lib.push_back ( i );\n    }\n\n    m = lib.size();\n    while ( lib.size() > 1 ){\n        if ( lib[1] - lib[0] == 2 ){\n            ans++;\n            lib.erase ( lib.begin() );\n            lib.erase ( lib.begin() );\n        }\n        else{\n            ans++;\n            lib.erase ( lib.begin() );\n        }\n    }\n\n    if ( !lib.empty() )\n        ans++;\n    cout << ans << '\\n';\n}\n```\n\n\n## problem C\n\n就是這題，我沒有開 long long 然後就被 hack 了\n名次噴掉 1500 多名\n\n### 題目\n\n給定一條長度為 $N$ 的序列\n我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和\n也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$\n求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的\n請列出數量，以及些解的位置\n\n因為題目有點難懂，我放上其中一個例子好了\n那現在看另外一個序列 $[ 8, 3, 5, 2 ]$\n1. 移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \\to 5 = 3 + 2$\n2. 移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \\to 8 = 3 + 5$\n\n### 解法\n\n1. 計算原先序列的總和\n2. 每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉\n3. 把 $sum$ 為奇數則返回步驟2\n4. 尋找 $\\frac{sum}{2}$ 是否出現於原序列中\n5. 檢查 $\\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次\n6. 如果有出現過兩次，那麼 i 就是其中一個答案\n7. 返回步驟 2\n\n有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數\n假設 $sum' = sum - a[i]，sum'$ 代表除了 $a[i]$ 以外的元素和\n既然一個序列為好的序列，代表說這個序列會被切成兩部分\n而這兩部分的和會一樣\n既然都會被切成兩個一樣的東西了，為什麼 $sum'$ 會是奇數\n這就矛盾了，所以 $sum'$ 一定為偶數\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define int LL\n\nmap < int, int > lib;\n\n#undef int\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    #define int LL\n\n    int n, sum = 0;\n    cin >> n;\n    vector < int > data ( n ), ans;\n    for ( auto &i: data ){\n        cin >> i;\n        sum += i;\n        lib[i]++;\n    }\n    for ( int i = 0 ; i < n ; i++ ){\n        sum -= data[i];\n        if ( sum & 1 ){\n            sum += data[i];\n            continue;\n        }\n        sum >>= 1;\n        if ( ( lib[sum] == 1 && sum != data[i] ) || lib[sum] > 1 ){\n            ans.push_back ( i + 1 );\n        }\n        sum <<= 1;\n        sum += data[i];\n    }\n\n    cout << ans.size() << '\\n';\n    for ( auto i: data )\n        cout << i << ' ';\n    cout << '\\n';\n}\n```\n\n\n## problem D\n\n### 題目\n\n給定一大小為 $N$ 的可重複集合 $S$\n求找出一大小為 $K$ 的可重複集合 $S' ( S'\\subseteq S )$ 且 $S'$ 在 $S$ 中出現次數最多\n\n**元素可重複，這件事情非常重要**\n\n### 解法\n\n我先做離散化，反正數字跟解法沒有關係\n接著紀錄每個數字出現幾次\n我先二分搜最多那個集合最多可以出現幾次\n然後按照次數輸出，反正只要符合要求的都行\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 200005\n\nint cnt[maxN], m, k, ma;\nvector < int > lib;\nmap < int, vector < int > > table;\n\ninline bool check ( int tms ){\n    int res = 0;\n    for ( int i = tms ; i < ma ; i++ )\n        for ( auto j: table[i] )\n            res += cnt[j] / tms;\n\n    return res >= k;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n\n    int n, l = 0, r = -1, mid;\n    cin >> n >> k;\n    vector < int > data ( n );\n    for ( auto &i: data )\n        cin >> i;\n    if ( n == k ){\n        for ( auto i: data )\n            cout << i << ' ';\n        cout << '\\n';\n        return 0;\n    }\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    m = lib.size();\n    for ( auto i: data ){\n        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;\n    }\n    for ( int i = 0 ; i < m ; i++ ){\n        r = max ( r, cnt[i] );\n        table[cnt[i]].push_back ( i );\n    }\n    ma = ++r;\n    mid = ( l + r ) >> 1;\n    while ( r - l > 1 ){\n        if ( check ( mid ) )\n            l = mid;\n        else\n            r = mid;\n        mid = ( l + r ) >> 1;\n    }\n\n    l = k;\n    for ( int i = 0 ; i < m ; i++ ){\n        for ( int j = 0 ; j < min ( cnt[i] / mid, l ) ; j++ )\n            cout << lib[i] << ' ';\n        l -= min ( cnt[i] / mid, l );\n        if ( !l )\n            break;\n    }\n    cout << '\\n';\n}\n```\n\n\n## problem E\n\n這題我賽中只有想到喇賽解法，賽後才想到正解\n\n### 題目\n\n給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$\n要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用\n且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）\n求最多可以使用多少題目\n**注意！你應該要最大會題目數量，而非天數**\n\n### 解法\n\n每舉第一天的題數，然後暴力往後找\n用 lower_bound 去尋找是個不錯的選擇\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 200005\n\nLL cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n\n    int n, m, ma, ans = -1, swp, idx, id;\n    cin >> n;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    m = lib.size();\n    for ( auto i: data )\n        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;\n\n    data.clear();\n    for ( int i = 0 ; i < m ; i++ ){\n        data.push_back ( cnt[i] );\n    }\n    sort ( data.begin(), data.end() );\n    ma = data.back() + 1;\n\n    for ( int i = 0 ; i < ma ; i++ ){\n        swp = idx = 0;\n        for ( int j = i ; j < ma && idx < m ; j <<= 1 ){\n            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();\n            if ( id < data.size() )\n                swp += j;\n            idx = id + 1;\n        }\n\n        ans = max ( ans, swp );\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n\n## 後記\n\n老實說我這場有點慘\npC 被 Hack，pE 賽中沒寫出來\n以我的實力來說不應該這樣子的\n因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@\n\n希望下一場可以好好發揮","slug":"CFR521","published":1,"updated":"2020-05-03T10:27:23.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqb000cf19p2og99csm","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>身為一個垃圾，當然要打的像垃圾一樣<br>先是校內爆掉，現在換 div.3 爆掉<br>。。。pC 沒開 long long 溢位被 hack 成智障的就是我<br>坐等晚上 rating change<br>沒意外應該會噴掉啦</p><a id=\"more\"></a><p>先放上所有題目的<a href=\"http://codeforces.com/contest/1077\" target=\"_blank\" rel=\"noopener\">連結</a></p><h2 id=\"problem-A\"><a class=\"header-anchor\" href=\"#problem-A\"></a>problem A</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步<br>然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>阿不就直接暴力就好<br>算一下會往左次往右幾次，算一下就好</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, k, a, b, swp, ans;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class=\"line\">        swp = a - b;</span><br><span class=\"line\">        ans = swp * ( LL ) ( k / <span class=\"number\">2</span> );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( k &amp; <span class=\"number\">1</span> )</span><br><span class=\"line\">            ans += a;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-B\"><a class=\"header-anchor\" href=\"#problem-B\"></a>problem B</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一排房屋現在是否有開燈<br>通常關燈了就是在睡覺了</p><p>題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈<br>那麼那戶人家就會被干擾<br>但是請注意，只有一邊的鄰居開燈並不會被干擾</p><p>現在想要讓所有在睡覺的人都不會被干擾<br>求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>因為只有一邊有開燈並不會被干擾<br>也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了</p><p>那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉<br>順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, ans = <span class=\"number\">0</span>, m;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; n - <span class=\"number\">1</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !data[i] &amp;&amp; data[i - <span class=\"number\">1</span>] &amp;&amp; data[i + <span class=\"number\">1</span>] )</span><br><span class=\"line\">            lib.push_back ( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( lib.size() &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( lib[<span class=\"number\">1</span>] - lib[<span class=\"number\">0</span>] == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !lib.empty() )</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-C\"><a class=\"header-anchor\" href=\"#problem-C\"></a>problem C</h2><p>就是這題，我沒有開 long long 然後就被 hack 了<br>名次噴掉 1500 多名</p><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定一條長度為 $N$ 的序列<br>我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和<br>也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$<br>求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的<br>請列出數量，以及些解的位置</p><p>因為題目有點難懂，我放上其中一個例子好了<br>那現在看另外一個序列 $[ 8, 3, 5, 2 ]$</p><ol><li>移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \\to 5 = 3 + 2$</li><li>移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \\to 8 = 3 + 5$</li></ol><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><ol><li>計算原先序列的總和</li><li>每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉</li><li>把 $sum$ 為奇數則返回步驟2</li><li>尋找 $\\frac{sum}{2}$ 是否出現於原序列中</li><li>檢查 $\\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次</li><li>如果有出現過兩次，那麼 i 就是其中一個答案</li><li>返回步驟 2</li></ol><p>有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數<br>假設 $sum’ = sum - a[i]，sum’$ 代表除了 $a[i]$ 以外的元素和<br>既然一個序列為好的序列，代表說這個序列會被切成兩部分<br>而這兩部分的和會一樣<br>既然都會被切成兩個一樣的東西了，為什麼 $sum’$ 會是奇數<br>這就矛盾了，所以 $sum’$ 一定為偶數</p><h3 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), ans;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">        lib[i]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        sum -= data[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( sum &amp; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            sum += data[i];</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ( lib[sum] == <span class=\"number\">1</span> &amp;&amp; sum != data[i] ) || lib[sum] &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            ans.push_back ( i + <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        sum += data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-D\"><a class=\"header-anchor\" href=\"#problem-D\"></a>problem D</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>給定一大小為 $N$ 的可重複集合 $S$<br>求找出一大小為 $K$ 的可重複集合 $S’ ( S’\\subseteq S )$ 且 $S’$ 在 $S$ 中出現次數最多</p><p><strong>元素可重複，這件事情非常重要</strong></p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>我先做離散化，反正數字跟解法沒有關係<br>接著紀錄每個數字出現幾次<br>我先二分搜最多那個集合最多可以出現幾次<br>然後按照次數輸出，反正只要符合要求的都行</p><h3 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN], m, k, ma;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; &gt; table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">check</span> <span class=\"params\">( <span class=\"keyword\">int</span> tms )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = tms ; i &lt; ma ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: table[i] )</span><br><span class=\"line\">            res += cnt[j] / tms;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res &gt;= k;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, l = <span class=\"number\">0</span>, r = <span class=\"number\">-1</span>, mid;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( n == k )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )&#123;</span><br><span class=\"line\">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        r = max ( r, cnt[i] );</span><br><span class=\"line\">        table[cnt[i]].push_back ( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ma = ++r;</span><br><span class=\"line\">    mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( r - l &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( check ( mid ) )</span><br><span class=\"line\">            l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">        mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    l = k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; min ( cnt[i] / mid, l ) ; j++ )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; lib[i] &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">        l -= min ( cnt[i] / mid, l );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !l )</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-E\"><a class=\"header-anchor\" href=\"#problem-E\"></a>problem E</h2><p>這題我賽中只有想到喇賽解法，賽後才想到正解</p><h3 id=\"題目-v5\"><a class=\"header-anchor\" href=\"#題目-v5\"></a>題目</h3><p>給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$<br>要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用<br>且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）<br>求最多可以使用多少題目<br><strong>注意！你應該要最大會題目數量，而非天數</strong></p><h3 id=\"解法-v5\"><a class=\"header-anchor\" href=\"#解法-v5\"></a>解法</h3><p>每舉第一天的題數，然後暴力往後找<br>用 lower_bound 去尋找是個不錯的選擇</p><h3 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\">LL cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ma, ans = <span class=\"number\">-1</span>, swp, idx, id;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;</span><br><span class=\"line\"></span><br><span class=\"line\">    data.clear();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        data.push_back ( cnt[i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort ( data.begin(), data.end() );</span><br><span class=\"line\">    ma = data.back() + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; ma ; i++ )&#123;</span><br><span class=\"line\">        swp = idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i ; j &lt; ma &amp;&amp; idx &lt; m ; j &lt;&lt;= <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( id &lt; data.size() )</span><br><span class=\"line\">                swp += j;</span><br><span class=\"line\">            idx = id + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ans = max ( ans, swp );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>老實說我這場有點慘<br>pC 被 Hack，pE 賽中沒寫出來<br>以我的實力來說不應該這樣子的<br>因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@</p><p>希望下一場可以好好發揮</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>身為一個垃圾，當然要打的像垃圾一樣<br>先是校內爆掉，現在換 div.3 爆掉<br>。。。pC 沒開 long long 溢位被 hack 成智障的就是我<br>坐等晚上 rating change<br>沒意外應該會噴掉啦</p>","more":"<p>先放上所有題目的<a href=\"http://codeforces.com/contest/1077\" target=\"_blank\" rel=\"noopener\">連結</a></p><h2 id=\"problem-A\"><a class=\"header-anchor\" href=\"#problem-A\"></a>problem A</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步<br>然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>阿不就直接暴力就好<br>算一下會往左次往右幾次，算一下就好</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, k, a, b, swp, ans;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class=\"line\">        swp = a - b;</span><br><span class=\"line\">        ans = swp * ( LL ) ( k / <span class=\"number\">2</span> );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( k &amp; <span class=\"number\">1</span> )</span><br><span class=\"line\">            ans += a;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-B\"><a class=\"header-anchor\" href=\"#problem-B\"></a>problem B</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一排房屋現在是否有開燈<br>通常關燈了就是在睡覺了</p><p>題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈<br>那麼那戶人家就會被干擾<br>但是請注意，只有一邊的鄰居開燈並不會被干擾</p><p>現在想要讓所有在睡覺的人都不會被干擾<br>求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>因為只有一邊有開燈並不會被干擾<br>也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了</p><p>那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉<br>順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, ans = <span class=\"number\">0</span>, m;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; n - <span class=\"number\">1</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !data[i] &amp;&amp; data[i - <span class=\"number\">1</span>] &amp;&amp; data[i + <span class=\"number\">1</span>] )</span><br><span class=\"line\">            lib.push_back ( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( lib.size() &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( lib[<span class=\"number\">1</span>] - lib[<span class=\"number\">0</span>] == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !lib.empty() )</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-C\"><a class=\"header-anchor\" href=\"#problem-C\"></a>problem C</h2><p>就是這題，我沒有開 long long 然後就被 hack 了<br>名次噴掉 1500 多名</p><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定一條長度為 $N$ 的序列<br>我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和<br>也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$<br>求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的<br>請列出數量，以及些解的位置</p><p>因為題目有點難懂，我放上其中一個例子好了<br>那現在看另外一個序列 $[ 8, 3, 5, 2 ]$</p><ol><li>移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \\to 5 = 3 + 2$</li><li>移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \\to 8 = 3 + 5$</li></ol><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><ol><li>計算原先序列的總和</li><li>每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉</li><li>把 $sum$ 為奇數則返回步驟2</li><li>尋找 $\\frac{sum}{2}$ 是否出現於原序列中</li><li>檢查 $\\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次</li><li>如果有出現過兩次，那麼 i 就是其中一個答案</li><li>返回步驟 2</li></ol><p>有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數<br>假設 $sum’ = sum - a[i]，sum’$ 代表除了 $a[i]$ 以外的元素和<br>既然一個序列為好的序列，代表說這個序列會被切成兩部分<br>而這兩部分的和會一樣<br>既然都會被切成兩個一樣的東西了，為什麼 $sum’$ 會是奇數<br>這就矛盾了，所以 $sum’$ 一定為偶數</p><h3 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), ans;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">        lib[i]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        sum -= data[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( sum &amp; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            sum += data[i];</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ( lib[sum] == <span class=\"number\">1</span> &amp;&amp; sum != data[i] ) || lib[sum] &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            ans.push_back ( i + <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        sum += data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-D\"><a class=\"header-anchor\" href=\"#problem-D\"></a>problem D</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>給定一大小為 $N$ 的可重複集合 $S$<br>求找出一大小為 $K$ 的可重複集合 $S’ ( S’\\subseteq S )$ 且 $S’$ 在 $S$ 中出現次數最多</p><p><strong>元素可重複，這件事情非常重要</strong></p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>我先做離散化，反正數字跟解法沒有關係<br>接著紀錄每個數字出現幾次<br>我先二分搜最多那個集合最多可以出現幾次<br>然後按照次數輸出，反正只要符合要求的都行</p><h3 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN], m, k, ma;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; &gt; table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">check</span> <span class=\"params\">( <span class=\"keyword\">int</span> tms )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = tms ; i &lt; ma ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: table[i] )</span><br><span class=\"line\">            res += cnt[j] / tms;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res &gt;= k;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, l = <span class=\"number\">0</span>, r = <span class=\"number\">-1</span>, mid;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( n == k )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )&#123;</span><br><span class=\"line\">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        r = max ( r, cnt[i] );</span><br><span class=\"line\">        table[cnt[i]].push_back ( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ma = ++r;</span><br><span class=\"line\">    mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( r - l &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( check ( mid ) )</span><br><span class=\"line\">            l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">        mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    l = k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; min ( cnt[i] / mid, l ) ; j++ )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; lib[i] &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">        l -= min ( cnt[i] / mid, l );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !l )</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-E\"><a class=\"header-anchor\" href=\"#problem-E\"></a>problem E</h2><p>這題我賽中只有想到喇賽解法，賽後才想到正解</p><h3 id=\"題目-v5\"><a class=\"header-anchor\" href=\"#題目-v5\"></a>題目</h3><p>給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$<br>要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用<br>且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）<br>求最多可以使用多少題目<br><strong>注意！你應該要最大會題目數量，而非天數</strong></p><h3 id=\"解法-v5\"><a class=\"header-anchor\" href=\"#解法-v5\"></a>解法</h3><p>每舉第一天的題數，然後暴力往後找<br>用 lower_bound 去尋找是個不錯的選擇</p><h3 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\">LL cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ma, ans = <span class=\"number\">-1</span>, swp, idx, id;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;</span><br><span class=\"line\"></span><br><span class=\"line\">    data.clear();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        data.push_back ( cnt[i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort ( data.begin(), data.end() );</span><br><span class=\"line\">    ma = data.back() + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; ma ; i++ )&#123;</span><br><span class=\"line\">        swp = idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i ; j &lt; ma &amp;&amp; idx &lt; m ; j &lt;&lt;= <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( id &lt; data.size() )</span><br><span class=\"line\">                swp += j;</span><br><span class=\"line\">            idx = id + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ans = max ( ans, swp );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>老實說我這場有點慘<br>pC 被 Hack，pE 賽中沒寫出來<br>以我的實力來說不應該這樣子的<br>因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@</p><p>希望下一場可以好好發揮</p><!-- rebuild by neat -->"},{"title":"[TIOJ][1940]Nim","date":"2017-12-26T12:28:32.000Z","_content":"\n## 題目\n\n這題目很哏，真得很哏\n哏到我都快不想寫了（結果還是用兩節課 AC 了）\n題目略過，要看原題的[在這](https://tioj.ck.tp.edu.tw/problems/1940)\n<!--more-->\n\n\n## 解法\n\n我看完題目第一個想法就是 DP\n\n。。。然後我就 TLE 了（廢話\n\n因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP\n但是請看範圍：$1e9$，怎麼看都會 TLE\n所以只能想一下數學解法了\n\n$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏\n\n接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：\n$$0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6$$\n經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\\frac{n}{2}$ 就好了\n\n接著再分兩個case : $n$ 為奇術時\n\ncase 餘一：$\\frac{n}{4}$ 的整數部分 $\\to \\lfloor \\frac{n}{4} \\rfloor$\ncase 餘三：$f ( 2, \\frac{n}{2} ) \\to$直接對這個函數做遞迴就好\n\n總結一下，函數大概長這樣\n\n$$f ( k, n ) =\n\\begin{cases}\nn, & \\text{if $k$ is $1$} \\\\\n\\begin{cases}\n\\frac{n}{2}, & \\text{if $n$ is even} \\\\\n\\lfloor \\frac{n}{4} \\rfloor, & \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\\\\nf ( 2, \\frac{n}{2} ), & \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }\n\\end{cases}, & \\text{if $k$ is $2$ }\n\\end{cases}\n$$\n\n因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define maxN 10005\n\ninline int count ( int n ){\n    switch ( n ){\n        case 3:\n        case 1: return 1;\n        case 5:\n        case 2: return 0;\n        default: \n            switch ( n % 4 ){\n                case 2:\n                case 0: return n / 2;\n                case 1: return n / 4;\n                case 3: return count ( n / 2 );\n            }\n    }\n    return 0;\n}\n\nint main(){\n    int k, m;\n    scanf ( \"%d%d\", &k, &m );\n    printf ( \"%d\\n\", ( k == 1 ? m : count ( m ) ) );\n}\n```\n\n## 後記(2019/03/23 00:29)\n\n為了能讓這篇文章的函數好看一些\n硬生生讓 hexo 支援 mathjax 了\n然後上面那個精美的函式，我把原始碼放這邊\n\n```\n$$\nf ( k, n ) =\n\\begin{cases}\nn, & \\text{if $k$ is $1$} \\\\\n\\begin{cases}\n\\frac{n}{2}, & \\text{if $n$ is even} \\\\\n\\lfloor \\frac{n}{4} \\rfloor, & \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\\\\nf ( 2, \\frac{n}{2} ), & \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }\n\\end{cases}, & \\text{if $k$ is $2$ }\n\\end{cases}\n$$\n```","source":"_posts/TIOJ-1940.md","raw":"---\ntitle: '[TIOJ][1940]Nim'\ndate: 2017-12-26 20:28:32\ntags: \n - TIOJ\n - math\n---\n\n## 題目\n\n這題目很哏，真得很哏\n哏到我都快不想寫了（結果還是用兩節課 AC 了）\n題目略過，要看原題的[在這](https://tioj.ck.tp.edu.tw/problems/1940)\n<!--more-->\n\n\n## 解法\n\n我看完題目第一個想法就是 DP\n\n。。。然後我就 TLE 了（廢話\n\n因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP\n但是請看範圍：$1e9$，怎麼看都會 TLE\n所以只能想一下數學解法了\n\n$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏\n\n接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：\n$$0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6$$\n經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\\frac{n}{2}$ 就好了\n\n接著再分兩個case : $n$ 為奇術時\n\ncase 餘一：$\\frac{n}{4}$ 的整數部分 $\\to \\lfloor \\frac{n}{4} \\rfloor$\ncase 餘三：$f ( 2, \\frac{n}{2} ) \\to$直接對這個函數做遞迴就好\n\n總結一下，函數大概長這樣\n\n$$f ( k, n ) =\n\\begin{cases}\nn, & \\text{if $k$ is $1$} \\\\\n\\begin{cases}\n\\frac{n}{2}, & \\text{if $n$ is even} \\\\\n\\lfloor \\frac{n}{4} \\rfloor, & \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\\\\nf ( 2, \\frac{n}{2} ), & \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }\n\\end{cases}, & \\text{if $k$ is $2$ }\n\\end{cases}\n$$\n\n因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define maxN 10005\n\ninline int count ( int n ){\n    switch ( n ){\n        case 3:\n        case 1: return 1;\n        case 5:\n        case 2: return 0;\n        default: \n            switch ( n % 4 ){\n                case 2:\n                case 0: return n / 2;\n                case 1: return n / 4;\n                case 3: return count ( n / 2 );\n            }\n    }\n    return 0;\n}\n\nint main(){\n    int k, m;\n    scanf ( \"%d%d\", &k, &m );\n    printf ( \"%d\\n\", ( k == 1 ? m : count ( m ) ) );\n}\n```\n\n## 後記(2019/03/23 00:29)\n\n為了能讓這篇文章的函數好看一些\n硬生生讓 hexo 支援 mathjax 了\n然後上面那個精美的函式，我把原始碼放這邊\n\n```\n$$\nf ( k, n ) =\n\\begin{cases}\nn, & \\text{if $k$ is $1$} \\\\\n\\begin{cases}\n\\frac{n}{2}, & \\text{if $n$ is even} \\\\\n\\lfloor \\frac{n}{4} \\rfloor, & \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\\\\nf ( 2, \\frac{n}{2} ), & \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }\n\\end{cases}, & \\text{if $k$ is $2$ }\n\\end{cases}\n$$\n```","slug":"TIOJ-1940","published":1,"updated":"2020-05-03T10:27:23.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqc000df19p9y6cezcz","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>這題目很哏，真得很哏<br>哏到我都快不想寫了（結果還是用兩節課 AC 了）<br>題目略過，要看原題的<a href=\"https://tioj.ck.tp.edu.tw/problems/1940\" target=\"_blank\" rel=\"noopener\">在這</a></p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>我看完題目第一個想法就是 DP</p><p>。。。然後我就 TLE 了（廢話</p><p>因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP<br>但是請看範圍：$1e9$，怎麼看都會 TLE<br>所以只能想一下數學解法了</p><p>$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏</p><p>接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：<br>$$0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6$$<br>經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\\frac{n}{2}$ 就好了</p><p>接著再分兩個case : $n$ 為奇術時</p><p>case 餘一：$\\frac{n}{4}$ 的整數部分 $\\to \\lfloor \\frac{n}{4} \\rfloor$<br>case 餘三：$f ( 2, \\frac{n}{2} ) \\to$直接對這個函數做遞迴就好</p><p>總結一下，函數大概長這樣</p><p>$$f ( k, n ) =<br>\\begin{cases}<br>n, &amp; \\text{if $k$ is $1$} \\<br>\\begin{cases}<br>\\frac{n}{2}, &amp; \\text{if $n$ is even} \\<br>\\lfloor \\frac{n}{4} \\rfloor, &amp; \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\<br>f ( 2, \\frac{n}{2} ), &amp; \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }<br>\\end{cases}, &amp; \\text{if $k$ is $2$ }<br>\\end{cases}<br>$$</p><p>因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 10005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">count</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> ( n )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: </span><br><span class=\"line\">            <span class=\"keyword\">switch</span> ( n % <span class=\"number\">4</span> )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> n / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> n / <span class=\"number\">4</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> count ( n / <span class=\"number\">2</span> );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k, m;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span> ( <span class=\"string\">\"%d%d\"</span>, &amp;k, &amp;m );</span><br><span class=\"line\">    <span class=\"built_in\">printf</span> ( <span class=\"string\">\"%d\\n\"</span>, ( k == <span class=\"number\">1</span> ? m : count ( m ) ) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記-2019-03-23-00-29\"><a class=\"header-anchor\" href=\"#後記-2019-03-23-00-29\"></a>後記(2019/03/23 00:29)</h2><p>為了能讓這篇文章的函數好看一些<br>硬生生讓 hexo 支援 mathjax 了<br>然後上面那個精美的函式，我把原始碼放這邊</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$</span><br><span class=\"line\">f ( k, n ) &#x3D;</span><br><span class=\"line\">\\begin&#123;cases&#125;</span><br><span class=\"line\">n, &amp; \\text&#123;if $k$ is $1$&#125; \\\\</span><br><span class=\"line\">\\begin&#123;cases&#125;</span><br><span class=\"line\">\\frac&#123;n&#125;&#123;2&#125;, &amp; \\text&#123;if $n$ is even&#125; \\\\</span><br><span class=\"line\">\\lfloor \\frac&#123;n&#125;&#123;4&#125; \\rfloor, &amp; \\text&#123;if $n &#x3D; 4\\times k + 1 ( k \\in \\mathbb&#123;R&#125; )$ &#125; \\\\</span><br><span class=\"line\">f ( 2, \\frac&#123;n&#125;&#123;2&#125; ), &amp; \\text&#123;if $n &#x3D; 4\\times k + 3 ( k \\in \\mathbb&#123;R&#125; )$ &#125;</span><br><span class=\"line\">\\end&#123;cases&#125;, &amp; \\text&#123;if $k$ is $2$ &#125;</span><br><span class=\"line\">\\end&#123;cases&#125;</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>這題目很哏，真得很哏<br>哏到我都快不想寫了（結果還是用兩節課 AC 了）<br>題目略過，要看原題的<a href=\"https://tioj.ck.tp.edu.tw/problems/1940\" target=\"_blank\" rel=\"noopener\">在這</a></p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>我看完題目第一個想法就是 DP</p><p>。。。然後我就 TLE 了（廢話</p><p>因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP<br>但是請看範圍：$1e9$，怎麼看都會 TLE<br>所以只能想一下數學解法了</p><p>$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏</p><p>接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：<br>$$0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6$$<br>經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\\frac{n}{2}$ 就好了</p><p>接著再分兩個case : $n$ 為奇術時</p><p>case 餘一：$\\frac{n}{4}$ 的整數部分 $\\to \\lfloor \\frac{n}{4} \\rfloor$<br>case 餘三：$f ( 2, \\frac{n}{2} ) \\to$直接對這個函數做遞迴就好</p><p>總結一下，函數大概長這樣</p><p>$$f ( k, n ) =<br>\\begin{cases}<br>n, &amp; \\text{if $k$ is $1$} \\<br>\\begin{cases}<br>\\frac{n}{2}, &amp; \\text{if $n$ is even} \\<br>\\lfloor \\frac{n}{4} \\rfloor, &amp; \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\<br>f ( 2, \\frac{n}{2} ), &amp; \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }<br>\\end{cases}, &amp; \\text{if $k$ is $2$ }<br>\\end{cases}<br>$$</p><p>因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 10005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">count</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> ( n )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: </span><br><span class=\"line\">            <span class=\"keyword\">switch</span> ( n % <span class=\"number\">4</span> )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> n / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> n / <span class=\"number\">4</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> count ( n / <span class=\"number\">2</span> );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k, m;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span> ( <span class=\"string\">\"%d%d\"</span>, &amp;k, &amp;m );</span><br><span class=\"line\">    <span class=\"built_in\">printf</span> ( <span class=\"string\">\"%d\\n\"</span>, ( k == <span class=\"number\">1</span> ? m : count ( m ) ) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記-2019-03-23-00-29\"><a class=\"header-anchor\" href=\"#後記-2019-03-23-00-29\"></a>後記(2019/03/23 00:29)</h2><p>為了能讓這篇文章的函數好看一些<br>硬生生讓 hexo 支援 mathjax 了<br>然後上面那個精美的函式，我把原始碼放這邊</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$</span><br><span class=\"line\">f ( k, n ) &#x3D;</span><br><span class=\"line\">\\begin&#123;cases&#125;</span><br><span class=\"line\">n, &amp; \\text&#123;if $k$ is $1$&#125; \\\\</span><br><span class=\"line\">\\begin&#123;cases&#125;</span><br><span class=\"line\">\\frac&#123;n&#125;&#123;2&#125;, &amp; \\text&#123;if $n$ is even&#125; \\\\</span><br><span class=\"line\">\\lfloor \\frac&#123;n&#125;&#123;4&#125; \\rfloor, &amp; \\text&#123;if $n &#x3D; 4\\times k + 1 ( k \\in \\mathbb&#123;R&#125; )$ &#125; \\\\</span><br><span class=\"line\">f ( 2, \\frac&#123;n&#125;&#123;2&#125; ), &amp; \\text&#123;if $n &#x3D; 4\\times k + 3 ( k \\in \\mathbb&#123;R&#125; )$ &#125;</span><br><span class=\"line\">\\end&#123;cases&#125;, &amp; \\text&#123;if $k$ is $2$ &#125;</span><br><span class=\"line\">\\end&#123;cases&#125;</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"[TOJ][391] E. 模數 CANDY","date":"2018-02-07T01:17:56.000Z","_content":"\n## 題目 & 解法\n我先附上題目[連結](http://toj.tfcis.org/oj/pro/391/)\n簡單來說，就是區間取餘數\n然後這東西**可以用線段樹實作**\n<!--more-->\n\n然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法\n在寫區間開根號的時候，我們用的是**區間最大值線段樹**，是的，區間最大值\n\n理由很簡單，因為開根號開到最後，一定會朝向$1$收斂\n所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧\n\n同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹**在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數**\n這應該算是一種剪枝（吧\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\n#define maxN 200005\n\nint seg[maxN << 2];\n\nvoid update ( int l, int r, int index, int value, int n ){\n    if ( l == r )\n        seg[n] += value;\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( index <= mid )\n            update ( l, mid, index, value, leftSon );\n        else\n            update ( mid + 1, r, index, value, rightSon );\n\n        seg[n] = max ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nvoid modify ( int l, int r, int nowL, int nowR, int value, int n ){\n    if ( seg[n] < value )\n        return;\n    if ( nowL == nowR )\n        seg[n] %= value;\n    else{\n        int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( r <= mid )\n            modify ( l, r, nowL, mid, value, leftSon );\n        else if ( mid < l )\n            modify ( l, r, mid + 1, nowR, value, rightSon );\n        else{\n            modify ( l, mid, nowL, mid, value, leftSon );\n            modify ( mid + 1, r, mid + 1, nowR, value, rightSon );\n        }\n\n        seg[n] = max ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, type, l, r, x, in;\n    cin >> n;\n    n--;\n    for ( int i = 0 ; i <= n ; i++ ){\n        cin >> in;\n        update ( 0, n, i, in, 1 );\n    }\n\n    cin >> m;\n    while ( m-- ){\n        cin >> type;\n        if ( type == 1 ){\n            cin >> l >> r;\n            update ( 0, n, r, l, 1 );\n        }        \n        else if ( type == 2 ){\n            cin >> l >> r >> x;\n            modify ( l, r, 0, n, x, 1 );\n        }\n        else\n            cout << seg[1] << '\\n';\n    }\n}\n```\n<del>所以其實這題也不難嘛</del>\n\n為什麼不能打 Lazy Tag？\n\n。。。因為 mod 沒有疊加性啊\n\n\n## 證明\n然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過\n因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）\n所以總複雜度大約為 $O ( log ( max \\lbrace a_i \\rbrace ) )$ 左右\n（此部分感謝 jd3 學長提供）","source":"_posts/TOJ-391.md","raw":"---\ntitle: '[TOJ][391] E. 模數 CANDY'\ndate: 2018-02-07 09:17:56\ntags:\n - TOJ\n - segment tree\n---\n\n## 題目 & 解法\n我先附上題目[連結](http://toj.tfcis.org/oj/pro/391/)\n簡單來說，就是區間取餘數\n然後這東西**可以用線段樹實作**\n<!--more-->\n\n然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法\n在寫區間開根號的時候，我們用的是**區間最大值線段樹**，是的，區間最大值\n\n理由很簡單，因為開根號開到最後，一定會朝向$1$收斂\n所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧\n\n同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹**在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數**\n這應該算是一種剪枝（吧\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\n#define maxN 200005\n\nint seg[maxN << 2];\n\nvoid update ( int l, int r, int index, int value, int n ){\n    if ( l == r )\n        seg[n] += value;\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( index <= mid )\n            update ( l, mid, index, value, leftSon );\n        else\n            update ( mid + 1, r, index, value, rightSon );\n\n        seg[n] = max ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nvoid modify ( int l, int r, int nowL, int nowR, int value, int n ){\n    if ( seg[n] < value )\n        return;\n    if ( nowL == nowR )\n        seg[n] %= value;\n    else{\n        int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( r <= mid )\n            modify ( l, r, nowL, mid, value, leftSon );\n        else if ( mid < l )\n            modify ( l, r, mid + 1, nowR, value, rightSon );\n        else{\n            modify ( l, mid, nowL, mid, value, leftSon );\n            modify ( mid + 1, r, mid + 1, nowR, value, rightSon );\n        }\n\n        seg[n] = max ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, type, l, r, x, in;\n    cin >> n;\n    n--;\n    for ( int i = 0 ; i <= n ; i++ ){\n        cin >> in;\n        update ( 0, n, i, in, 1 );\n    }\n\n    cin >> m;\n    while ( m-- ){\n        cin >> type;\n        if ( type == 1 ){\n            cin >> l >> r;\n            update ( 0, n, r, l, 1 );\n        }        \n        else if ( type == 2 ){\n            cin >> l >> r >> x;\n            modify ( l, r, 0, n, x, 1 );\n        }\n        else\n            cout << seg[1] << '\\n';\n    }\n}\n```\n<del>所以其實這題也不難嘛</del>\n\n為什麼不能打 Lazy Tag？\n\n。。。因為 mod 沒有疊加性啊\n\n\n## 證明\n然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過\n因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）\n所以總複雜度大約為 $O ( log ( max \\lbrace a_i \\rbrace ) )$ 左右\n（此部分感謝 jd3 學長提供）","slug":"TOJ-391","published":1,"updated":"2020-05-03T10:27:23.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqe000ff19p80rcddvn","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p>我先附上題目<a href=\"http://toj.tfcis.org/oj/pro/391/\" target=\"_blank\" rel=\"noopener\">連結</a><br>簡單來說，就是區間取餘數<br>然後這東西<strong>可以用線段樹實作</strong></p><a id=\"more\"></a><p>然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法<br>在寫區間開根號的時候，我們用的是<strong>區間最大值線段樹</strong>，是的，區間最大值</p><p>理由很簡單，因為開根號開到最後，一定會朝向$1$收斂<br>所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧</p><p>同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹<strong>在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數</strong><br>這應該算是一種剪枝（吧</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> seg[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        seg[n] += value;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( index &lt;= mid )</span><br><span class=\"line\">            update ( l, mid, index, value, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            update ( mid + <span class=\"number\">1</span>, r, index, value, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( seg[n] &lt; value )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( nowL == nowR )</span><br><span class=\"line\">        seg[n] %= value;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">            modify ( l, r, nowL, mid, value, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, value, rightSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            modify ( l, mid, nowL, mid, value, leftSon );</span><br><span class=\"line\">            modify ( mid + <span class=\"number\">1</span>, r, mid + <span class=\"number\">1</span>, nowR, value, rightSon );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, type, l, r, x, in;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    n--;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">        update ( <span class=\"number\">0</span>, n, i, in, <span class=\"number\">1</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">            update ( <span class=\"number\">0</span>, n, r, l, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class=\"line\">            modify ( l, r, <span class=\"number\">0</span>, n, x, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; seg[<span class=\"number\">1</span>] &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><del>所以其實這題也不難嘛</del></p><p>為什麼不能打 Lazy Tag？</p><p>。。。因為 mod 沒有疊加性啊</p><h2 id=\"證明\"><a class=\"header-anchor\" href=\"#證明\"></a>證明</h2><p>然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過<br>因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）<br>所以總複雜度大約為 $O ( log ( max \\lbrace a_i \\rbrace ) )$ 左右<br>（此部分感謝 jd3 學長提供）</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p>我先附上題目<a href=\"http://toj.tfcis.org/oj/pro/391/\" target=\"_blank\" rel=\"noopener\">連結</a><br>簡單來說，就是區間取餘數<br>然後這東西<strong>可以用線段樹實作</strong></p>","more":"<p>然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法<br>在寫區間開根號的時候，我們用的是<strong>區間最大值線段樹</strong>，是的，區間最大值</p><p>理由很簡單，因為開根號開到最後，一定會朝向$1$收斂<br>所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧</p><p>同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹<strong>在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數</strong><br>這應該算是一種剪枝（吧</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> seg[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        seg[n] += value;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( index &lt;= mid )</span><br><span class=\"line\">            update ( l, mid, index, value, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            update ( mid + <span class=\"number\">1</span>, r, index, value, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( seg[n] &lt; value )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( nowL == nowR )</span><br><span class=\"line\">        seg[n] %= value;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">            modify ( l, r, nowL, mid, value, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, value, rightSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            modify ( l, mid, nowL, mid, value, leftSon );</span><br><span class=\"line\">            modify ( mid + <span class=\"number\">1</span>, r, mid + <span class=\"number\">1</span>, nowR, value, rightSon );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, type, l, r, x, in;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    n--;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">        update ( <span class=\"number\">0</span>, n, i, in, <span class=\"number\">1</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">            update ( <span class=\"number\">0</span>, n, r, l, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class=\"line\">            modify ( l, r, <span class=\"number\">0</span>, n, x, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; seg[<span class=\"number\">1</span>] &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><del>所以其實這題也不難嘛</del></p><p>為什麼不能打 Lazy Tag？</p><p>。。。因為 mod 沒有疊加性啊</p><h2 id=\"證明\"><a class=\"header-anchor\" href=\"#證明\"></a>證明</h2><p>然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過<br>因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）<br>所以總複雜度大約為 $O ( log ( max \\lbrace a_i \\rbrace ) )$ 左右<br>（此部分感謝 jd3 學長提供）</p><!-- rebuild by neat -->"},{"title":"[TIOJ][1909] 勇者出征","date":"2019-01-04T01:46:38.000Z","_content":"\n## 題目\n\n[原題目連結](https://tioj.ck.tp.edu.tw/problems/1909)\n據說是 2015TOI 三模的題目\n簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：\n1. 從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個\n2.    假設 $D$ 可以連結到 $A$ 的話（$D的高度 \\lt A$），那麼$A$也可以到 $D$\n\n求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號\n如果有多組解，輸出編號最小的\n<!--more-->\n\n\n## 解法\n\n我們先來釐清一下什麼是簡單路徑好了\n所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑\n\n### 建圖\n\n看到路徑，我第一個想到的是圖論\n我們先想一下，要怎麼把圖建出來\n\n#### 暴力 $O ( N^2 )$\n\n$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較\n```cpp\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\nfor ( int i = 0 ; i < n ; i++ ){\n    int l = -1, r = n;\n    for ( int j = i - 1 ; j >= 0 ; j-- )\n        if ( data[j] > data[i] ){\n            l = j;\n            break;\n        }\n    for ( int j = i + 1 ; j < n ; j++ )\n        if ( data[j] > data[i] ){\n            r = j;\n            break;\n        }\n    if ( l == -1 && r == n )\n        continue;\n    if ( l == -1 ){\n        UNI ( r, i, edges );\n        continue;\n    }\n    if ( r == n ){\n        UNI ( l, i, edges );\n        continue;\n    }\n    UNI ( ( data[l] < data[r] ? l : r ), i, edges );\n}\n```\n\n#### 線段樹 $O ( NlogN )$\n\n然後我就想到線段樹了\n$index$ 是做離散化後的數字，$value$ 是編號\n然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值\n一開始右手邊的最小值線段樹，裡面有$N$個點\n每處理完一個點，就把這個點拔掉丟到左邊去\ncode大概像這樣\n```cpp\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n#define INF 0x3f3f3f3f\n\n// function\n// 線段樹1是紀錄最小值、右手邊的線段樹\n// 而線段數2是紀錄最大值、左手邊的線段樹\nint seg1[maxN << 2], seg2[maxN << 2];\nvoid update1 ( int l, int r, int index, int value, int n );\nint query1 ( int l, int r, int nowL, int nowR, int n );\nvoid update2 ( int l, int r, int index, int value, int n );\nint query2 ( int l, int r, int index, int value, int n );\n\n// lib是已經做完離散化的數列\nmemset ( seg1, INF, sizeof seg1 );\nmemset ( seg2, -1, sizeof seg2 )\nfor ( int i = 0 ; i < n ; i++ )\n    update1 ( 0, n, i, lib[i], 1 );\n\nfor ( int i = 0 ; i < n ; i++ ){\n    int l = query2 ( lib[i] + 1, n, 0, n, 1 );\n    int r = query1 ( lib[i] + 1, n, 0, n, 1 );\n    if ( l == -1 && r == INF )\n        continue;\n    if ( l == -1 ){\n        UNI ( i, r, edges );\n        continue;\n    }\n    if ( r == INF ){\n        UNI ( i, l, edges );\n        continue;\n    }\n    UNI ( i, ( data[l] < data[r] ? l : r ), edges );\n\n    update1 ( 0, n, INF, lib[i], 1 );\n    update2 ( 0, n, i, lib[i], 1 );\n}\n```\n\n#### 單調列隊優化 $O ( N )$\n\n關於單調列隊優化的介紹可以看這份建中講義第二頁[這邊](https://goo.gl/e12UAo)\n\n根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的\n\n那麼假設要插入一個數字呢？\n假設現在這個數字比最後一個還要大，那麼我們就不斷的拔\n拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候\n接著把這些拔掉的數字與 $A$ 做連接\n\n不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？\n因為他是說兩邊第一個比她大的數字的 min\n既然兩邊都比他大，那麼當然選小的啊\n\n最後這個 deque 會保證遞減\n那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L'$ 做連結\n直到這個 deque 清空為止\n\n不過因為只需要從後端做操作\n所以用 stack 就可以了\n\n詳細的 code 請看這\n```cpp\ntypedef pair < int, int > pii;\n#define F first\n#define S second\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n\n// data 是原數列\nstack < pii, vector < pii > > st;\n// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）\npii swp;\nst.push ( pii ( data[0], 0 ) );\nfor ( int i = 1 ; i < n ; i++ ){\n    while ( !st.empty() && data[i] > st.top().F ){\n        swp = st.top();\n        st.pop();\n        if ( EMP ( st ) )\n            UNI ( swp.S, i, edges );\n        else\n            UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );\n    }\n    st.push ( pii ( data[i], i ) );\n}\nswp = st.top();\nst.pop();\nwhile ( !st.empty() ){\n    UNI ( swp.S, st.top().S, edges );\n    swp = st.top();\n    st.pop();\n}\n```\n\n### 是時候來處理路徑囉\n\n至於這個題目的另外一個部分：路徑\n又該怎麼處理呢？\n我們可以發現，這份資料轉換完之後保證是二元樹\n為什麼？\n因為他最多只會被兩個其他的點連結（左邊一個右邊一個）\n而自己只會連結到一個點\n那麼這不就是二元樹嗎？\n那麼，通過點 $u$ 的路徑會有三種：\n1. $u$ 的祖先到 $u$ 的子孫的路徑\n2. $u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑\n3. 從 $u$ 開始（或結束）的路徑\n\n我們先定義\n$$dp[u] = u的子孫數目（包含 u ）$$\n\n因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）\n因此只要計算起點終點的組合數就好了\n\n那麼 1. 就很好算啦\n$$( 總點數 - dp[n] - 1 )\\times ( dp[n] - 1 )$$\n\n那麼 2. 呢？\n上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）\n所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\\times dp[n]$）就是答案了\n\n呃，3. 應該就不用講了吧 = =\n就 總點數減一啊 = =\n\n然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）\n\n綜合一二三，所以只需要dfs一次就好了\n\n這部分的code我放這\n```cpp\n#define maxN 1000005\nvector < int > edges[maxN];\nint cnt[maxN], dp[maxN], N;\n// N = 總點數 - 1\n\nvoid dfs ( int n,  int p ){\n    int a = -1, b = -1;\n    for ( auto i: edges[n] ){\n        if ( i == p )\n            continue;\n        if ( a == -1 )\n            a = i;\n        else\n            b = i;\n        dfs ( i, n );\n        dp[n] += dp[i];\n    }\n    cnt[n] += ( N - dp[n] ) * dp[n]; // 祖先到子孫\n    if ( deges[n].size() == 3 ) // 如果是有兩個子孫的話\n        cnt[n] += dp[a] * dp[b];\n    dp[n]++; // 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1\n    cnt[n] += N;\n    cnt[n] <<= 1; // 記得乘二喔\n}\n```\n\n## code\n\n綜合以上，我的code長這樣\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntypedef pair < int, int > pii;\n#define pb push_back\n#define F first\n#define S second\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n#define maxN 1000005\n\nvector < int > edges[maxN];\nLL dp[maxN], N, cnt[maxN];\n\nvoid dfs ( int n,  int p ){\n    int a = -1, b = -1;\n    for ( auto i: edges[n] ){\n        if ( i == p )\n            continue;\n        if ( a == -1 )\n            a = i;\n        else\n            b = i;\n        dfs ( i, n );\n        dp[n] += dp[i];\n    }\n    cnt[n] += ( N - dp[n] ) * dp[n];\n    if ( edges[n].size() == 3 )\n        cnt[n] += dp[a] * dp[b];\n    dp[n]++;\n    cnt[n] += N;\n    cnt[n] <<= 1;\n}\n\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, idx = -1;\n    LL ma = -1;\n    cin >> n;\n    vector < int > data ( n );\n    for ( auto &i: data )\n        cin >> i;\n\n\n    stack < pii, vector < pii > > st;\n    pii swp;\n    st.push ( pii ( data[0], 0 ) );\n    for ( int i =  1 ; i < n ; i++ ){\n        while ( !st.empty() && data[i] > st.top().F ){\n            swp = st.top();\n            st.pop();\n            if ( st.empty() )\n                UNI ( swp.S, i, edges );\n            else\n                UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );\n        }\n        st.push ( pii ( data[i], i ) );\n    }\n    swp = st.top();\n    st.pop();\n    while ( !st.empty() ){\n        UNI ( swp.S, st.top().S, edges );\n        swp = st.top();\n        st.pop();\n    }\n\n    N = n - 1;\n    dfs ( 0, -1 );\n\n    for ( int i = 0 ; i < n ; i++ ){\n        if ( cnt[i] > ma )\n            ma = cnt[i], idx = i;\n    }\n\n    cout << ma << ' ' << idx + 1 << '\\n';\n}\n```\n\n## 後記\n\n其實這題我寫了很久\n因為之前一段時間都在搞特選\n而且我怕特選爆掉沒學校念\n所以我都在讀學測\n最近特選出來了\n已經沒有後顧之憂可以好好搞 TOI 了 <3\n才回來鍊\n也是因為剛回來鍊\n所以手感很糟 = =\n線段樹寫 query 還把查詢區間 & 總區間寫反 = =\n還有忘了設定 ma = -1\n然後還想說為什麼 WA Orz\n這題也沒有看出來是單調列隊\n還傻傻花一個多小時寫線段樹 + debug\n結果單調隊列快狠準 = =\n我到底在幹嘛 = =\n不過好險還有三個月（吧\n\n然後這篇文章也太長 = =\n這一行是第 326 行\n呃我是說在原始的 md 檔案上\n喔這邊已經 328 行了\n好多 = =\n至少可定下心來好好練習了","source":"_posts/TIOJ-1909.md","raw":"---\ntitle: '[TIOJ][1909] 勇者出征'\ndate: 2019-01-04 09:46:38\ntags:\n - TIOJ\n - graph\n---\n\n## 題目\n\n[原題目連結](https://tioj.ck.tp.edu.tw/problems/1909)\n據說是 2015TOI 三模的題目\n簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：\n1. 從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個\n2.    假設 $D$ 可以連結到 $A$ 的話（$D的高度 \\lt A$），那麼$A$也可以到 $D$\n\n求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號\n如果有多組解，輸出編號最小的\n<!--more-->\n\n\n## 解法\n\n我們先來釐清一下什麼是簡單路徑好了\n所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑\n\n### 建圖\n\n看到路徑，我第一個想到的是圖論\n我們先想一下，要怎麼把圖建出來\n\n#### 暴力 $O ( N^2 )$\n\n$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較\n```cpp\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\nfor ( int i = 0 ; i < n ; i++ ){\n    int l = -1, r = n;\n    for ( int j = i - 1 ; j >= 0 ; j-- )\n        if ( data[j] > data[i] ){\n            l = j;\n            break;\n        }\n    for ( int j = i + 1 ; j < n ; j++ )\n        if ( data[j] > data[i] ){\n            r = j;\n            break;\n        }\n    if ( l == -1 && r == n )\n        continue;\n    if ( l == -1 ){\n        UNI ( r, i, edges );\n        continue;\n    }\n    if ( r == n ){\n        UNI ( l, i, edges );\n        continue;\n    }\n    UNI ( ( data[l] < data[r] ? l : r ), i, edges );\n}\n```\n\n#### 線段樹 $O ( NlogN )$\n\n然後我就想到線段樹了\n$index$ 是做離散化後的數字，$value$ 是編號\n然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值\n一開始右手邊的最小值線段樹，裡面有$N$個點\n每處理完一個點，就把這個點拔掉丟到左邊去\ncode大概像這樣\n```cpp\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n#define INF 0x3f3f3f3f\n\n// function\n// 線段樹1是紀錄最小值、右手邊的線段樹\n// 而線段數2是紀錄最大值、左手邊的線段樹\nint seg1[maxN << 2], seg2[maxN << 2];\nvoid update1 ( int l, int r, int index, int value, int n );\nint query1 ( int l, int r, int nowL, int nowR, int n );\nvoid update2 ( int l, int r, int index, int value, int n );\nint query2 ( int l, int r, int index, int value, int n );\n\n// lib是已經做完離散化的數列\nmemset ( seg1, INF, sizeof seg1 );\nmemset ( seg2, -1, sizeof seg2 )\nfor ( int i = 0 ; i < n ; i++ )\n    update1 ( 0, n, i, lib[i], 1 );\n\nfor ( int i = 0 ; i < n ; i++ ){\n    int l = query2 ( lib[i] + 1, n, 0, n, 1 );\n    int r = query1 ( lib[i] + 1, n, 0, n, 1 );\n    if ( l == -1 && r == INF )\n        continue;\n    if ( l == -1 ){\n        UNI ( i, r, edges );\n        continue;\n    }\n    if ( r == INF ){\n        UNI ( i, l, edges );\n        continue;\n    }\n    UNI ( i, ( data[l] < data[r] ? l : r ), edges );\n\n    update1 ( 0, n, INF, lib[i], 1 );\n    update2 ( 0, n, i, lib[i], 1 );\n}\n```\n\n#### 單調列隊優化 $O ( N )$\n\n關於單調列隊優化的介紹可以看這份建中講義第二頁[這邊](https://goo.gl/e12UAo)\n\n根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的\n\n那麼假設要插入一個數字呢？\n假設現在這個數字比最後一個還要大，那麼我們就不斷的拔\n拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候\n接著把這些拔掉的數字與 $A$ 做連接\n\n不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？\n因為他是說兩邊第一個比她大的數字的 min\n既然兩邊都比他大，那麼當然選小的啊\n\n最後這個 deque 會保證遞減\n那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L'$ 做連結\n直到這個 deque 清空為止\n\n不過因為只需要從後端做操作\n所以用 stack 就可以了\n\n詳細的 code 請看這\n```cpp\ntypedef pair < int, int > pii;\n#define F first\n#define S second\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n\n// data 是原數列\nstack < pii, vector < pii > > st;\n// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）\npii swp;\nst.push ( pii ( data[0], 0 ) );\nfor ( int i = 1 ; i < n ; i++ ){\n    while ( !st.empty() && data[i] > st.top().F ){\n        swp = st.top();\n        st.pop();\n        if ( EMP ( st ) )\n            UNI ( swp.S, i, edges );\n        else\n            UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );\n    }\n    st.push ( pii ( data[i], i ) );\n}\nswp = st.top();\nst.pop();\nwhile ( !st.empty() ){\n    UNI ( swp.S, st.top().S, edges );\n    swp = st.top();\n    st.pop();\n}\n```\n\n### 是時候來處理路徑囉\n\n至於這個題目的另外一個部分：路徑\n又該怎麼處理呢？\n我們可以發現，這份資料轉換完之後保證是二元樹\n為什麼？\n因為他最多只會被兩個其他的點連結（左邊一個右邊一個）\n而自己只會連結到一個點\n那麼這不就是二元樹嗎？\n那麼，通過點 $u$ 的路徑會有三種：\n1. $u$ 的祖先到 $u$ 的子孫的路徑\n2. $u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑\n3. 從 $u$ 開始（或結束）的路徑\n\n我們先定義\n$$dp[u] = u的子孫數目（包含 u ）$$\n\n因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）\n因此只要計算起點終點的組合數就好了\n\n那麼 1. 就很好算啦\n$$( 總點數 - dp[n] - 1 )\\times ( dp[n] - 1 )$$\n\n那麼 2. 呢？\n上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）\n所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\\times dp[n]$）就是答案了\n\n呃，3. 應該就不用講了吧 = =\n就 總點數減一啊 = =\n\n然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）\n\n綜合一二三，所以只需要dfs一次就好了\n\n這部分的code我放這\n```cpp\n#define maxN 1000005\nvector < int > edges[maxN];\nint cnt[maxN], dp[maxN], N;\n// N = 總點數 - 1\n\nvoid dfs ( int n,  int p ){\n    int a = -1, b = -1;\n    for ( auto i: edges[n] ){\n        if ( i == p )\n            continue;\n        if ( a == -1 )\n            a = i;\n        else\n            b = i;\n        dfs ( i, n );\n        dp[n] += dp[i];\n    }\n    cnt[n] += ( N - dp[n] ) * dp[n]; // 祖先到子孫\n    if ( deges[n].size() == 3 ) // 如果是有兩個子孫的話\n        cnt[n] += dp[a] * dp[b];\n    dp[n]++; // 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1\n    cnt[n] += N;\n    cnt[n] <<= 1; // 記得乘二喔\n}\n```\n\n## code\n\n綜合以上，我的code長這樣\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntypedef pair < int, int > pii;\n#define pb push_back\n#define F first\n#define S second\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n#define maxN 1000005\n\nvector < int > edges[maxN];\nLL dp[maxN], N, cnt[maxN];\n\nvoid dfs ( int n,  int p ){\n    int a = -1, b = -1;\n    for ( auto i: edges[n] ){\n        if ( i == p )\n            continue;\n        if ( a == -1 )\n            a = i;\n        else\n            b = i;\n        dfs ( i, n );\n        dp[n] += dp[i];\n    }\n    cnt[n] += ( N - dp[n] ) * dp[n];\n    if ( edges[n].size() == 3 )\n        cnt[n] += dp[a] * dp[b];\n    dp[n]++;\n    cnt[n] += N;\n    cnt[n] <<= 1;\n}\n\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, idx = -1;\n    LL ma = -1;\n    cin >> n;\n    vector < int > data ( n );\n    for ( auto &i: data )\n        cin >> i;\n\n\n    stack < pii, vector < pii > > st;\n    pii swp;\n    st.push ( pii ( data[0], 0 ) );\n    for ( int i =  1 ; i < n ; i++ ){\n        while ( !st.empty() && data[i] > st.top().F ){\n            swp = st.top();\n            st.pop();\n            if ( st.empty() )\n                UNI ( swp.S, i, edges );\n            else\n                UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );\n        }\n        st.push ( pii ( data[i], i ) );\n    }\n    swp = st.top();\n    st.pop();\n    while ( !st.empty() ){\n        UNI ( swp.S, st.top().S, edges );\n        swp = st.top();\n        st.pop();\n    }\n\n    N = n - 1;\n    dfs ( 0, -1 );\n\n    for ( int i = 0 ; i < n ; i++ ){\n        if ( cnt[i] > ma )\n            ma = cnt[i], idx = i;\n    }\n\n    cout << ma << ' ' << idx + 1 << '\\n';\n}\n```\n\n## 後記\n\n其實這題我寫了很久\n因為之前一段時間都在搞特選\n而且我怕特選爆掉沒學校念\n所以我都在讀學測\n最近特選出來了\n已經沒有後顧之憂可以好好搞 TOI 了 <3\n才回來鍊\n也是因為剛回來鍊\n所以手感很糟 = =\n線段樹寫 query 還把查詢區間 & 總區間寫反 = =\n還有忘了設定 ma = -1\n然後還想說為什麼 WA Orz\n這題也沒有看出來是單調列隊\n還傻傻花一個多小時寫線段樹 + debug\n結果單調隊列快狠準 = =\n我到底在幹嘛 = =\n不過好險還有三個月（吧\n\n然後這篇文章也太長 = =\n這一行是第 326 行\n呃我是說在原始的 md 檔案上\n喔這邊已經 328 行了\n好多 = =\n至少可定下心來好好練習了","slug":"TIOJ-1909","published":1,"updated":"2020-05-03T10:27:23.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqf000gf19paoq2e8mj","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p><a href=\"https://tioj.ck.tp.edu.tw/problems/1909\" target=\"_blank\" rel=\"noopener\">原題目連結</a><br>據說是 2015TOI 三模的題目<br>簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：</p><ol><li>從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個</li><li>假設 $D$ 可以連結到 $A$ 的話（$D的高度 \\lt A$），那麼$A$也可以到 $D$</li></ol><p>求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號<br>如果有多組解，輸出編號最小的</p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>我們先來釐清一下什麼是簡單路徑好了<br>所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑</p><h3 id=\"建圖\"><a class=\"header-anchor\" href=\"#建圖\"></a>建圖</h3><p>看到路徑，我第一個想到的是圖論<br>我們先想一下，要怎麼把圖建出來</p><h4 id=\"暴力-O-N-2\"><a class=\"header-anchor\" href=\"#暴力-O-N-2\"></a>暴力 $O ( N^2 )$</h4><p>$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">-1</span>, r = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span> ; j &gt;= <span class=\"number\">0</span> ; j-- )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class=\"line\">            l = j;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span> ; j &lt; n ; j++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class=\"line\">            r = j;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> &amp;&amp; r == n )</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">        UNI ( r, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r == n )&#123;</span><br><span class=\"line\">        UNI ( l, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    UNI ( ( data[l] &lt; data[r] ? l : r ), i, edges );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"線段樹-O-NlogN\"><a class=\"header-anchor\" href=\"#線段樹-O-NlogN\"></a>線段樹 $O ( NlogN )$</h4><p>然後我就想到線段樹了<br>$index$ 是做離散化後的數字，$value$ 是編號<br>然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值<br>一開始右手邊的最小值線段樹，裡面有$N$個點<br>每處理完一個點，就把這個點拔掉丟到左邊去<br>code大概像這樣</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"comment\">// 線段樹1是紀錄最小值、右手邊的線段樹</span></span><br><span class=\"line\"><span class=\"comment\">// 而線段數2是紀錄最大值、左手邊的線段樹</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> seg1[maxN &lt;&lt; <span class=\"number\">2</span>], seg2[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update1</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query1</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update2</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query2</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lib是已經做完離散化的數列</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span> ( seg1, INF, <span class=\"keyword\">sizeof</span> seg1 );</span><br><span class=\"line\"><span class=\"built_in\">memset</span> ( seg2, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> seg2 )</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">    update1 ( <span class=\"number\">0</span>, n, i, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = query2 ( lib[i] + <span class=\"number\">1</span>, n, <span class=\"number\">0</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = query1 ( lib[i] + <span class=\"number\">1</span>, n, <span class=\"number\">0</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> &amp;&amp; r == INF )</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">        UNI ( i, r, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r == INF )&#123;</span><br><span class=\"line\">        UNI ( i, l, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    UNI ( i, ( data[l] &lt; data[r] ? l : r ), edges );</span><br><span class=\"line\"></span><br><span class=\"line\">    update1 ( <span class=\"number\">0</span>, n, INF, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\">    update2 ( <span class=\"number\">0</span>, n, i, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"單調列隊優化-O-N\"><a class=\"header-anchor\" href=\"#單調列隊優化-O-N\"></a>單調列隊優化 $O ( N )$</h4><p>關於單調列隊優化的介紹可以看這份建中講義第二頁<a href=\"https://goo.gl/e12UAo\" target=\"_blank\" rel=\"noopener\">這邊</a></p><p>根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的</p><p>那麼假設要插入一個數字呢？<br>假設現在這個數字比最後一個還要大，那麼我們就不斷的拔<br>拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候<br>接著把這些拔掉的數字與 $A$ 做連接</p><p>不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？<br>因為他是說兩邊第一個比她大的數字的 min<br>既然兩邊都比他大，那麼當然選小的啊</p><p>最後這個 deque 會保證遞減<br>那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L’$ 做連結<br>直到這個 deque 清空為止</p><p>不過因為只需要從後端做操作<br>所以用 stack 就可以了</p><p>詳細的 code 請看這</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// data 是原數列</span></span><br><span class=\"line\"><span class=\"built_in\">stack</span> &lt; pii, <span class=\"built_in\">vector</span> &lt; pii &gt; &gt; st;</span><br><span class=\"line\"><span class=\"comment\">// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）</span></span><br><span class=\"line\">pii swp;</span><br><span class=\"line\">st.push ( pii ( data[<span class=\"number\">0</span>], <span class=\"number\">0</span> ) );</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class=\"line\">        swp = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( EMP ( st ) )</span><br><span class=\"line\">            UNI ( swp.S, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    st.push ( pii ( data[i], i ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">swp = st.top();</span><br><span class=\"line\">st.pop();</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( !st.empty() )&#123;</span><br><span class=\"line\">    UNI ( swp.S, st.top().S, edges );</span><br><span class=\"line\">    swp = st.top();</span><br><span class=\"line\">    st.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"是時候來處理路徑囉\"><a class=\"header-anchor\" href=\"#是時候來處理路徑囉\"></a>是時候來處理路徑囉</h3><p>至於這個題目的另外一個部分：路徑<br>又該怎麼處理呢？<br>我們可以發現，這份資料轉換完之後保證是二元樹<br>為什麼？<br>因為他最多只會被兩個其他的點連結（左邊一個右邊一個）<br>而自己只會連結到一個點<br>那麼這不就是二元樹嗎？<br>那麼，通過點 $u$ 的路徑會有三種：</p><ol><li>$u$ 的祖先到 $u$ 的子孫的路徑</li><li>$u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑</li><li>從 $u$ 開始（或結束）的路徑</li></ol><p>我們先定義<br>$$dp[u] = u的子孫數目（包含 u ）$$</p><p>因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）<br>因此只要計算起點終點的組合數就好了</p><p>那麼 1. 就很好算啦<br>$$( 總點數 - dp[n] - 1 )\\times ( dp[n] - 1 )$$</p><p>那麼 2. 呢？<br>上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）<br>所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\\times dp[n]$）就是答案了</p><p>呃，3. 應該就不用講了吧 = =<br>就 總點數減一啊 = =</p><p>然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）</p><p>綜合一二三，所以只需要dfs一次就好了</p><p>這部分的code我放這</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN], dp[maxN], N;</span><br><span class=\"line\"><span class=\"comment\">// N = 總點數 - 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n,  <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">-1</span>, b = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a == <span class=\"number\">-1</span> )</span><br><span class=\"line\">            a = i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b = i;</span><br><span class=\"line\">        dfs ( i, n );</span><br><span class=\"line\">        dp[n] += dp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cnt[n] += ( N - dp[n] ) * dp[n]; <span class=\"comment\">// 祖先到子孫</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( deges[n].size() == <span class=\"number\">3</span> ) <span class=\"comment\">// 如果是有兩個子孫的話</span></span><br><span class=\"line\">        cnt[n] += dp[a] * dp[b];</span><br><span class=\"line\">    dp[n]++; <span class=\"comment\">// 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1</span></span><br><span class=\"line\">    cnt[n] += N;</span><br><span class=\"line\">    cnt[n] &lt;&lt;= <span class=\"number\">1</span>; <span class=\"comment\">// 記得乘二喔</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><p>綜合以上，我的code長這樣</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\">LL dp[maxN], N, cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n,  <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">-1</span>, b = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a == <span class=\"number\">-1</span> )</span><br><span class=\"line\">            a = i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b = i;</span><br><span class=\"line\">        dfs ( i, n );</span><br><span class=\"line\">        dp[n] += dp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cnt[n] += ( N - dp[n] ) * dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( edges[n].size() == <span class=\"number\">3</span> )</span><br><span class=\"line\">        cnt[n] += dp[a] * dp[b];</span><br><span class=\"line\">    dp[n]++;</span><br><span class=\"line\">    cnt[n] += N;</span><br><span class=\"line\">    cnt[n] &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, idx = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    LL ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> &lt; pii, <span class=\"built_in\">vector</span> &lt; pii &gt; &gt; st;</span><br><span class=\"line\">    pii swp;</span><br><span class=\"line\">    st.push ( pii ( data[<span class=\"number\">0</span>], <span class=\"number\">0</span> ) );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i =  <span class=\"number\">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class=\"line\">            swp = st.top();</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( st.empty() )</span><br><span class=\"line\">                UNI ( swp.S, i, edges );</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        st.push ( pii ( data[i], i ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swp = st.top();</span><br><span class=\"line\">    st.pop();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( !st.empty() )&#123;</span><br><span class=\"line\">        UNI ( swp.S, st.top().S, edges );</span><br><span class=\"line\">        swp = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    N = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    dfs ( <span class=\"number\">0</span>, <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( cnt[i] &gt; ma )</span><br><span class=\"line\">            ma = cnt[i], idx = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ma &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; idx + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>其實這題我寫了很久<br>因為之前一段時間都在搞特選<br>而且我怕特選爆掉沒學校念<br>所以我都在讀學測<br>最近特選出來了<br>已經沒有後顧之憂可以好好搞 TOI 了 &lt;3<br>才回來鍊<br>也是因為剛回來鍊<br>所以手感很糟 = =<br>線段樹寫 query 還把查詢區間 &amp; 總區間寫反 = =<br>還有忘了設定 ma = -1<br>然後還想說為什麼 WA Orz<br>這題也沒有看出來是單調列隊<br>還傻傻花一個多小時寫線段樹 + debug<br>結果單調隊列快狠準 = =<br>我到底在幹嘛 = =<br>不過好險還有三個月（吧</p><p>然後這篇文章也太長 = =<br>這一行是第 326 行<br>呃我是說在原始的 md 檔案上<br>喔這邊已經 328 行了<br>好多 = =<br>至少可定下心來好好練習了</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p><a href=\"https://tioj.ck.tp.edu.tw/problems/1909\" target=\"_blank\" rel=\"noopener\">原題目連結</a><br>據說是 2015TOI 三模的題目<br>簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：</p><ol><li>從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個</li><li>假設 $D$ 可以連結到 $A$ 的話（$D的高度 \\lt A$），那麼$A$也可以到 $D$</li></ol><p>求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號<br>如果有多組解，輸出編號最小的</p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>我們先來釐清一下什麼是簡單路徑好了<br>所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑</p><h3 id=\"建圖\"><a class=\"header-anchor\" href=\"#建圖\"></a>建圖</h3><p>看到路徑，我第一個想到的是圖論<br>我們先想一下，要怎麼把圖建出來</p><h4 id=\"暴力-O-N-2\"><a class=\"header-anchor\" href=\"#暴力-O-N-2\"></a>暴力 $O ( N^2 )$</h4><p>$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">-1</span>, r = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span> ; j &gt;= <span class=\"number\">0</span> ; j-- )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class=\"line\">            l = j;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span> ; j &lt; n ; j++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class=\"line\">            r = j;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> &amp;&amp; r == n )</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">        UNI ( r, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r == n )&#123;</span><br><span class=\"line\">        UNI ( l, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    UNI ( ( data[l] &lt; data[r] ? l : r ), i, edges );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"線段樹-O-NlogN\"><a class=\"header-anchor\" href=\"#線段樹-O-NlogN\"></a>線段樹 $O ( NlogN )$</h4><p>然後我就想到線段樹了<br>$index$ 是做離散化後的數字，$value$ 是編號<br>然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值<br>一開始右手邊的最小值線段樹，裡面有$N$個點<br>每處理完一個點，就把這個點拔掉丟到左邊去<br>code大概像這樣</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"comment\">// 線段樹1是紀錄最小值、右手邊的線段樹</span></span><br><span class=\"line\"><span class=\"comment\">// 而線段數2是紀錄最大值、左手邊的線段樹</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> seg1[maxN &lt;&lt; <span class=\"number\">2</span>], seg2[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update1</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query1</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update2</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query2</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lib是已經做完離散化的數列</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span> ( seg1, INF, <span class=\"keyword\">sizeof</span> seg1 );</span><br><span class=\"line\"><span class=\"built_in\">memset</span> ( seg2, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> seg2 )</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">    update1 ( <span class=\"number\">0</span>, n, i, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = query2 ( lib[i] + <span class=\"number\">1</span>, n, <span class=\"number\">0</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = query1 ( lib[i] + <span class=\"number\">1</span>, n, <span class=\"number\">0</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> &amp;&amp; r == INF )</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">        UNI ( i, r, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r == INF )&#123;</span><br><span class=\"line\">        UNI ( i, l, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    UNI ( i, ( data[l] &lt; data[r] ? l : r ), edges );</span><br><span class=\"line\"></span><br><span class=\"line\">    update1 ( <span class=\"number\">0</span>, n, INF, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\">    update2 ( <span class=\"number\">0</span>, n, i, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"單調列隊優化-O-N\"><a class=\"header-anchor\" href=\"#單調列隊優化-O-N\"></a>單調列隊優化 $O ( N )$</h4><p>關於單調列隊優化的介紹可以看這份建中講義第二頁<a href=\"https://goo.gl/e12UAo\" target=\"_blank\" rel=\"noopener\">這邊</a></p><p>根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的</p><p>那麼假設要插入一個數字呢？<br>假設現在這個數字比最後一個還要大，那麼我們就不斷的拔<br>拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候<br>接著把這些拔掉的數字與 $A$ 做連接</p><p>不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？<br>因為他是說兩邊第一個比她大的數字的 min<br>既然兩邊都比他大，那麼當然選小的啊</p><p>最後這個 deque 會保證遞減<br>那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L’$ 做連結<br>直到這個 deque 清空為止</p><p>不過因為只需要從後端做操作<br>所以用 stack 就可以了</p><p>詳細的 code 請看這</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// data 是原數列</span></span><br><span class=\"line\"><span class=\"built_in\">stack</span> &lt; pii, <span class=\"built_in\">vector</span> &lt; pii &gt; &gt; st;</span><br><span class=\"line\"><span class=\"comment\">// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）</span></span><br><span class=\"line\">pii swp;</span><br><span class=\"line\">st.push ( pii ( data[<span class=\"number\">0</span>], <span class=\"number\">0</span> ) );</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class=\"line\">        swp = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( EMP ( st ) )</span><br><span class=\"line\">            UNI ( swp.S, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    st.push ( pii ( data[i], i ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">swp = st.top();</span><br><span class=\"line\">st.pop();</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( !st.empty() )&#123;</span><br><span class=\"line\">    UNI ( swp.S, st.top().S, edges );</span><br><span class=\"line\">    swp = st.top();</span><br><span class=\"line\">    st.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"是時候來處理路徑囉\"><a class=\"header-anchor\" href=\"#是時候來處理路徑囉\"></a>是時候來處理路徑囉</h3><p>至於這個題目的另外一個部分：路徑<br>又該怎麼處理呢？<br>我們可以發現，這份資料轉換完之後保證是二元樹<br>為什麼？<br>因為他最多只會被兩個其他的點連結（左邊一個右邊一個）<br>而自己只會連結到一個點<br>那麼這不就是二元樹嗎？<br>那麼，通過點 $u$ 的路徑會有三種：</p><ol><li>$u$ 的祖先到 $u$ 的子孫的路徑</li><li>$u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑</li><li>從 $u$ 開始（或結束）的路徑</li></ol><p>我們先定義<br>$$dp[u] = u的子孫數目（包含 u ）$$</p><p>因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）<br>因此只要計算起點終點的組合數就好了</p><p>那麼 1. 就很好算啦<br>$$( 總點數 - dp[n] - 1 )\\times ( dp[n] - 1 )$$</p><p>那麼 2. 呢？<br>上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）<br>所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\\times dp[n]$）就是答案了</p><p>呃，3. 應該就不用講了吧 = =<br>就 總點數減一啊 = =</p><p>然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）</p><p>綜合一二三，所以只需要dfs一次就好了</p><p>這部分的code我放這</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN], dp[maxN], N;</span><br><span class=\"line\"><span class=\"comment\">// N = 總點數 - 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n,  <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">-1</span>, b = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a == <span class=\"number\">-1</span> )</span><br><span class=\"line\">            a = i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b = i;</span><br><span class=\"line\">        dfs ( i, n );</span><br><span class=\"line\">        dp[n] += dp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cnt[n] += ( N - dp[n] ) * dp[n]; <span class=\"comment\">// 祖先到子孫</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( deges[n].size() == <span class=\"number\">3</span> ) <span class=\"comment\">// 如果是有兩個子孫的話</span></span><br><span class=\"line\">        cnt[n] += dp[a] * dp[b];</span><br><span class=\"line\">    dp[n]++; <span class=\"comment\">// 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1</span></span><br><span class=\"line\">    cnt[n] += N;</span><br><span class=\"line\">    cnt[n] &lt;&lt;= <span class=\"number\">1</span>; <span class=\"comment\">// 記得乘二喔</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><p>綜合以上，我的code長這樣</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\">LL dp[maxN], N, cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n,  <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">-1</span>, b = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a == <span class=\"number\">-1</span> )</span><br><span class=\"line\">            a = i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b = i;</span><br><span class=\"line\">        dfs ( i, n );</span><br><span class=\"line\">        dp[n] += dp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cnt[n] += ( N - dp[n] ) * dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( edges[n].size() == <span class=\"number\">3</span> )</span><br><span class=\"line\">        cnt[n] += dp[a] * dp[b];</span><br><span class=\"line\">    dp[n]++;</span><br><span class=\"line\">    cnt[n] += N;</span><br><span class=\"line\">    cnt[n] &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, idx = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    LL ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> &lt; pii, <span class=\"built_in\">vector</span> &lt; pii &gt; &gt; st;</span><br><span class=\"line\">    pii swp;</span><br><span class=\"line\">    st.push ( pii ( data[<span class=\"number\">0</span>], <span class=\"number\">0</span> ) );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i =  <span class=\"number\">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class=\"line\">            swp = st.top();</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( st.empty() )</span><br><span class=\"line\">                UNI ( swp.S, i, edges );</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        st.push ( pii ( data[i], i ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swp = st.top();</span><br><span class=\"line\">    st.pop();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( !st.empty() )&#123;</span><br><span class=\"line\">        UNI ( swp.S, st.top().S, edges );</span><br><span class=\"line\">        swp = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    N = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    dfs ( <span class=\"number\">0</span>, <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( cnt[i] &gt; ma )</span><br><span class=\"line\">            ma = cnt[i], idx = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ma &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; idx + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>其實這題我寫了很久<br>因為之前一段時間都在搞特選<br>而且我怕特選爆掉沒學校念<br>所以我都在讀學測<br>最近特選出來了<br>已經沒有後顧之憂可以好好搞 TOI 了 &lt;3<br>才回來鍊<br>也是因為剛回來鍊<br>所以手感很糟 = =<br>線段樹寫 query 還把查詢區間 &amp; 總區間寫反 = =<br>還有忘了設定 ma = -1<br>然後還想說為什麼 WA Orz<br>這題也沒有看出來是單調列隊<br>還傻傻花一個多小時寫線段樹 + debug<br>結果單調隊列快狠準 = =<br>我到底在幹嘛 = =<br>不過好險還有三個月（吧</p><p>然後這篇文章也太長 = =<br>這一行是第 326 行<br>呃我是說在原始的 md 檔案上<br>喔這邊已經 328 行了<br>好多 = =<br>至少可定下心來好好練習了</p><!-- rebuild by neat -->"},{"title":"[TOJ][365]G.大龍貓","date":"2017-12-26T12:50:14.000Z","_content":"\n## 題目\n\n給定一個數列，為一群龍貓的『高度』\n定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群\n請實作出支援單點修改及區間查詢的 code\n[題目原網址](http://toj.tfcis.org/oj/pro/365/)\n\n<!--more-->\n\n## 解法\n\n先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\n\n接著定義另外一種資料型態，用在線段樹上維護的 $node$\n$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\n\n在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$\n\n\n那麼，$stop.ma$ 呢？\n\n$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大\n\n## 總結\n\n其實這題不難，只是 coding 有點複雜，query & update 都與正常的線段樹差不多，只是 up 需要思考一下（？）\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 100005\n\nstruct piece{\n    int f, s, sz;\n};\n\ninline bool same ( piece a, piece b ){\n    return a.f == b.f && a.s == b.s;\n}\n\nstruct node{\n    piece fro, bck, ma;\n} seg[maxN << 2];\n\nint basic[maxN];\n\ninline node up ( node L, node R ){\n    node res;\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\n\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\n\n        if ( same ( L.fro, L.bck ) )\n            res.fro = stop;\n        if ( same ( R.fro, R.bck ) )\n            res.bck = stop;\n\n        res.ma = ( stop.sz > res.ma.sz ? stop : res.ma );\n    }\n\n    return res;\n}\n\ninline void build ( int l, int r, int n ){\n    if ( l == r )\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        build ( l, mid, leftSon );\n        build ( mid + 1, r, rightSon );\n\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nvoid update ( int l, int r, int Index, int n ){\n    if ( l == r )\n        return;\n    int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( Index <= mid )\n        update ( l, mid, Index, leftSon );\n    else\n        update ( mid + 1, r, Index, rightSon );\n\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\n}\n\nnode query ( int l, int r, int nowL, int nowR, int n ){\n    if ( l <= nowL && nowR <= r )\n        return seg[n];\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( r <= mid )\n        return query ( l, r, nowL, mid, leftSon );\n    if ( mid < l )\n        return query ( l, r, mid + 1, nowR, rightSon );\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, q, l, r, type;\n    cin >> n;\n    for ( int i = 1 ; i <= n ; i++ )\n        cin >> basic[i];\n    build ( 1, n, 1 );\n\n    cin >> q;\n    while ( q-- ){\n        cin >> type >> l >> r;\n        if ( type == 1 ){\n            basic[l] = r;\n            update ( 1, n, l, 1 );\n        }\n        else\n            cout << query ( l, r, 1, n, 1 ).ma.sz << '\\n';\n    }\n}\n```\n\n","source":"_posts/TOJ-365.md","raw":"---\ntitle: '[TOJ][365]G.大龍貓'\ndate: 2017-12-26 20:50:14\ntags:\n - TOJ\n - segment tree\n---\n\n## 題目\n\n給定一個數列，為一群龍貓的『高度』\n定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群\n請實作出支援單點修改及區間查詢的 code\n[題目原網址](http://toj.tfcis.org/oj/pro/365/)\n\n<!--more-->\n\n## 解法\n\n先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\n\n接著定義另外一種資料型態，用在線段樹上維護的 $node$\n$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\n\n在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$\n\n\n那麼，$stop.ma$ 呢？\n\n$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大\n\n## 總結\n\n其實這題不難，只是 coding 有點複雜，query & update 都與正常的線段樹差不多，只是 up 需要思考一下（？）\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 100005\n\nstruct piece{\n    int f, s, sz;\n};\n\ninline bool same ( piece a, piece b ){\n    return a.f == b.f && a.s == b.s;\n}\n\nstruct node{\n    piece fro, bck, ma;\n} seg[maxN << 2];\n\nint basic[maxN];\n\ninline node up ( node L, node R ){\n    node res;\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\n\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\n\n        if ( same ( L.fro, L.bck ) )\n            res.fro = stop;\n        if ( same ( R.fro, R.bck ) )\n            res.bck = stop;\n\n        res.ma = ( stop.sz > res.ma.sz ? stop : res.ma );\n    }\n\n    return res;\n}\n\ninline void build ( int l, int r, int n ){\n    if ( l == r )\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        build ( l, mid, leftSon );\n        build ( mid + 1, r, rightSon );\n\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nvoid update ( int l, int r, int Index, int n ){\n    if ( l == r )\n        return;\n    int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( Index <= mid )\n        update ( l, mid, Index, leftSon );\n    else\n        update ( mid + 1, r, Index, rightSon );\n\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\n}\n\nnode query ( int l, int r, int nowL, int nowR, int n ){\n    if ( l <= nowL && nowR <= r )\n        return seg[n];\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( r <= mid )\n        return query ( l, r, nowL, mid, leftSon );\n    if ( mid < l )\n        return query ( l, r, mid + 1, nowR, rightSon );\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, q, l, r, type;\n    cin >> n;\n    for ( int i = 1 ; i <= n ; i++ )\n        cin >> basic[i];\n    build ( 1, n, 1 );\n\n    cin >> q;\n    while ( q-- ){\n        cin >> type >> l >> r;\n        if ( type == 1 ){\n            basic[l] = r;\n            update ( 1, n, l, 1 );\n        }\n        else\n            cout << query ( l, r, 1, n, 1 ).ma.sz << '\\n';\n    }\n}\n```\n\n","slug":"TOJ-365","published":1,"updated":"2020-05-03T10:27:23.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqg000if19p6i1sbz4b","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>給定一個數列，為一群龍貓的『高度』<br>定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群<br>請實作出支援單點修改及區間查詢的 code<br><a href=\"http://toj.tfcis.org/oj/pro/365/\" target=\"_blank\" rel=\"noopener\">題目原網址</a></p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）</p><p>接著定義另外一種資料型態，用在線段樹上維護的 $node$<br>$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個</p><p>在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$</p><p>那麼，$stop.ma$ 呢？</p><p>$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大</p><h2 id=\"總結\"><a class=\"header-anchor\" href=\"#總結\"></a>總結</h2><p>其實這題不難，只是 coding 有點複雜，query &amp; update 都與正常的線段樹差不多，只是 up 需要思考一下（？）</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 100005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">piece</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> f, s, sz;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( piece a, piece b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.f == b.f &amp;&amp; a.s == b.s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    piece fro, bck, ma;</span><br><span class=\"line\">&#125; seg[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> basic[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">up</span> <span class=\"params\">( node L, node R )</span></span>&#123;</span><br><span class=\"line\">    node res;</span><br><span class=\"line\">    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( basic[L.bck.s] + <span class=\"number\">1</span> == basic[R.fro.f] )&#123;</span><br><span class=\"line\">        piece stop = piece &#123; L.bck.f, R.fro.s, R.fro.s - L.bck.f + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( L.fro, L.bck ) )</span><br><span class=\"line\">            res.fro = stop;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( R.fro, R.bck ) )</span><br><span class=\"line\">            res.bck = stop;</span><br><span class=\"line\"></span><br><span class=\"line\">        res.ma = ( stop.sz &gt; res.ma.sz ? stop : res.ma );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        seg[n].fro = seg[n].bck = seg[n].ma = piece &#123; l, r, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        build ( l, mid, leftSon );</span><br><span class=\"line\">        build ( mid + <span class=\"number\">1</span>, r, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> Index, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( Index &lt;= mid )</span><br><span class=\"line\">        update ( l, mid, Index, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update ( mid + <span class=\"number\">1</span>, r, Index, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">    seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seg[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, q, l, r, type;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; basic[i];</span><br><span class=\"line\">    build ( <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( q-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            basic[l] = r;</span><br><span class=\"line\">            update ( <span class=\"number\">1</span>, n, l, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> ).ma.sz &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>給定一個數列，為一群龍貓的『高度』<br>定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群<br>請實作出支援單點修改及區間查詢的 code<br><a href=\"http://toj.tfcis.org/oj/pro/365/\" target=\"_blank\" rel=\"noopener\">題目原網址</a></p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）</p><p>接著定義另外一種資料型態，用在線段樹上維護的 $node$<br>$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個</p><p>在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$</p><p>那麼，$stop.ma$ 呢？</p><p>$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大</p><h2 id=\"總結\"><a class=\"header-anchor\" href=\"#總結\"></a>總結</h2><p>其實這題不難，只是 coding 有點複雜，query &amp; update 都與正常的線段樹差不多，只是 up 需要思考一下（？）</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 100005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">piece</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> f, s, sz;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( piece a, piece b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.f == b.f &amp;&amp; a.s == b.s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    piece fro, bck, ma;</span><br><span class=\"line\">&#125; seg[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> basic[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">up</span> <span class=\"params\">( node L, node R )</span></span>&#123;</span><br><span class=\"line\">    node res;</span><br><span class=\"line\">    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( basic[L.bck.s] + <span class=\"number\">1</span> == basic[R.fro.f] )&#123;</span><br><span class=\"line\">        piece stop = piece &#123; L.bck.f, R.fro.s, R.fro.s - L.bck.f + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( L.fro, L.bck ) )</span><br><span class=\"line\">            res.fro = stop;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( R.fro, R.bck ) )</span><br><span class=\"line\">            res.bck = stop;</span><br><span class=\"line\"></span><br><span class=\"line\">        res.ma = ( stop.sz &gt; res.ma.sz ? stop : res.ma );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        seg[n].fro = seg[n].bck = seg[n].ma = piece &#123; l, r, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        build ( l, mid, leftSon );</span><br><span class=\"line\">        build ( mid + <span class=\"number\">1</span>, r, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> Index, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( Index &lt;= mid )</span><br><span class=\"line\">        update ( l, mid, Index, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update ( mid + <span class=\"number\">1</span>, r, Index, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">    seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seg[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, q, l, r, type;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; basic[i];</span><br><span class=\"line\">    build ( <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( q-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            basic[l] = r;</span><br><span class=\"line\">            update ( <span class=\"number\">1</span>, n, l, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> ).ma.sz &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"[TOJ][406] C. 軍隊部署","date":"2018-07-18T11:39:09.000Z","_content":"\n## 題目\n老樣子先放連結\n[TOJ](<http://toj.tfcis.org/oj/pro/406/)\n[ZJ](<https://zerojudge.tw/ShowProblem?problemid=c460)\n這是去年（106年）全國學科能力競賽資訊科全國賽的pC\n分類上算是水題一枚（按照去年整體難度來說）\n\n題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊\n<!--more-->\n\n\n## 解法\n\n所以如果我們先不看種族，我們先看能力就好，可以看成：\n* 第一位：是否對空，是為 $1$，否為 $0$\n* 第二位：是否範圍，是為 $1$，否為 $0$\n* 第三位：是否遠距，是為 $1$，否為 $0$\n\n所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$\n然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧\n會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$\n\n接著是種族，有三種族，所以代號為$1, 2, 3$\n\n那麼來做dp陣列的規劃吧\n$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能\n\n然後要求是三種族、三功能都要有，所以**那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族**\n\n呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想\n看 code 可能會比較好瞭解，我 code 放下面\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long dp[5][10];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    long long n, x, y, z, w, ans = 0;\n    cin >> n;\n    for ( int i = 0 ; i < n ; i++ ){\n        cin >> w >> x >> y >> z;\n        dp[w][x * 4 + y * 2 + z]++;\n    }\n\n    for ( int i = 0 ; i < 8 ; i++ )\n        for ( int j = 0 ; j < 8 ; j++ )\n            for ( int k = 0 ; k < 8 ; k++ )\n                if ( ( i | j | k ) == 7 )\n                    ans += dp[1][i] * dp[2][j] * dp[3][k];\n\n    cout << ans << '\\n';\n}\n```","source":"_posts/TOJ-406.md","raw":"---\ntitle: '[TOJ][406] C. 軍隊部署'\ndate: 2018-07-18 19:39:09\ntags:\n - TOJ\n - ZJ\n - 全國賽\n - dp\n---\n\n## 題目\n老樣子先放連結\n[TOJ](<http://toj.tfcis.org/oj/pro/406/)\n[ZJ](<https://zerojudge.tw/ShowProblem?problemid=c460)\n這是去年（106年）全國學科能力競賽資訊科全國賽的pC\n分類上算是水題一枚（按照去年整體難度來說）\n\n題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊\n<!--more-->\n\n\n## 解法\n\n所以如果我們先不看種族，我們先看能力就好，可以看成：\n* 第一位：是否對空，是為 $1$，否為 $0$\n* 第二位：是否範圍，是為 $1$，否為 $0$\n* 第三位：是否遠距，是為 $1$，否為 $0$\n\n所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$\n然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧\n會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$\n\n接著是種族，有三種族，所以代號為$1, 2, 3$\n\n那麼來做dp陣列的規劃吧\n$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能\n\n然後要求是三種族、三功能都要有，所以**那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族**\n\n呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想\n看 code 可能會比較好瞭解，我 code 放下面\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long dp[5][10];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    long long n, x, y, z, w, ans = 0;\n    cin >> n;\n    for ( int i = 0 ; i < n ; i++ ){\n        cin >> w >> x >> y >> z;\n        dp[w][x * 4 + y * 2 + z]++;\n    }\n\n    for ( int i = 0 ; i < 8 ; i++ )\n        for ( int j = 0 ; j < 8 ; j++ )\n            for ( int k = 0 ; k < 8 ; k++ )\n                if ( ( i | j | k ) == 7 )\n                    ans += dp[1][i] * dp[2][j] * dp[3][k];\n\n    cout << ans << '\\n';\n}\n```","slug":"TOJ-406","published":1,"updated":"2020-05-03T10:27:23.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqi000kf19p3a0x9bzx","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>老樣子先放連結<br>[TOJ](&lt;<a href=\"http://toj.tfcis.org/oj/pro/406/\" target=\"_blank\" rel=\"noopener\">http://toj.tfcis.org/oj/pro/406/</a>)<br>[ZJ](&lt;<a href=\"https://zerojudge.tw/ShowProblem?problemid=c460\" target=\"_blank\" rel=\"noopener\">https://zerojudge.tw/ShowProblem?problemid=c460</a>)<br>這是去年（106年）全國學科能力競賽資訊科全國賽的pC<br>分類上算是水題一枚（按照去年整體難度來說）</p><p>題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊</p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>所以如果我們先不看種族，我們先看能力就好，可以看成：</p><ul><li>第一位：是否對空，是為 $1$，否為 $0$</li><li>第二位：是否範圍，是為 $1$，否為 $0$</li><li>第三位：是否遠距，是為 $1$，否為 $0$</li></ul><p>所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$<br>然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧<br>會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$</p><p>接著是種族，有三種族，所以代號為$1, 2, 3$</p><p>那麼來做dp陣列的規劃吧<br>$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能</p><p>然後要求是三種族、三功能都要有，所以<strong>那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族</strong></p><p>呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想<br>看 code 可能會比較好瞭解，我 code 放下面</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[<span class=\"number\">5</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, x, y, z, w, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; w &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class=\"line\">        dp[w][x * <span class=\"number\">4</span> + y * <span class=\"number\">2</span> + z]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">8</span> ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; <span class=\"number\">8</span> ; j++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> k = <span class=\"number\">0</span> ; k &lt; <span class=\"number\">8</span> ; k++ )</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( ( i | j | k ) == <span class=\"number\">7</span> )</span><br><span class=\"line\">                    ans += dp[<span class=\"number\">1</span>][i] * dp[<span class=\"number\">2</span>][j] * dp[<span class=\"number\">3</span>][k];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>老樣子先放連結<br>[TOJ](&lt;<a href=\"http://toj.tfcis.org/oj/pro/406/\" target=\"_blank\" rel=\"noopener\">http://toj.tfcis.org/oj/pro/406/</a>)<br>[ZJ](&lt;<a href=\"https://zerojudge.tw/ShowProblem?problemid=c460\" target=\"_blank\" rel=\"noopener\">https://zerojudge.tw/ShowProblem?problemid=c460</a>)<br>這是去年（106年）全國學科能力競賽資訊科全國賽的pC<br>分類上算是水題一枚（按照去年整體難度來說）</p><p>題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊</p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>所以如果我們先不看種族，我們先看能力就好，可以看成：</p><ul><li>第一位：是否對空，是為 $1$，否為 $0$</li><li>第二位：是否範圍，是為 $1$，否為 $0$</li><li>第三位：是否遠距，是為 $1$，否為 $0$</li></ul><p>所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$<br>然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧<br>會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$</p><p>接著是種族，有三種族，所以代號為$1, 2, 3$</p><p>那麼來做dp陣列的規劃吧<br>$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能</p><p>然後要求是三種族、三功能都要有，所以<strong>那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族</strong></p><p>呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想<br>看 code 可能會比較好瞭解，我 code 放下面</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[<span class=\"number\">5</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, x, y, z, w, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; w &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class=\"line\">        dp[w][x * <span class=\"number\">4</span> + y * <span class=\"number\">2</span> + z]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">8</span> ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; <span class=\"number\">8</span> ; j++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> k = <span class=\"number\">0</span> ; k &lt; <span class=\"number\">8</span> ; k++ )</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( ( i | j | k ) == <span class=\"number\">7</span> )</span><br><span class=\"line\">                    ans += dp[<span class=\"number\">1</span>][i] * dp[<span class=\"number\">2</span>][j] * dp[<span class=\"number\">3</span>][k];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"[TOJ][407] D. 警力配置","date":"2018-08-16T13:59:42.000Z","_content":"\n又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =\n<del>別再給我增加工作量啊垃圾</del>\n我還要把舊站的文章搬過來改成 md 檔啊 = =\n\n\n## 題目\n\n我先附上[連結](http://toj.tfcis.org/oj/pro/407/)\n\n題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」\n不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組\n<!--more-->\n有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長\n組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長\n\n**注意：至少有一個 $\\to$ 有兩個也沒關係**\n\n這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫\n<del>（但是不小心撈到73分，我問號）</del>\n\n\n## 解法\n\n很顯然的要先轉成一張圖，這絕對是圖論 = =\n也就是說題意可以被化簡成這樣：\n給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到\n。。。啊不就匈牙利\n既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下[這篇](http://www.csie.ntnu.edu.tw/~u91029/Matching.html)\n然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法\n\n因為這題真的是裸題（？）所以我就直接附 code 了\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n\n#define maxN 200005\n\nvector < int > edges[maxN];\nint match[maxN], visit[maxN], turn;\n\ninline bool dfs ( int n ){\n    visit[n] = turn;\n    for ( auto i: edges[n] ){\n        if ( match[i] == -1 || ( visit[match[i]] != turn && dfs ( match[i] ) ) ){\n            match[i] = n;\n            match[n] = i;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, m, u, v, p, q, ans;\n    cin >> t;\n    while ( t-- ){\n        ans = 0;\n        memset ( match, -1, sizeof match );\n        for ( auto &i: edges )\n            i.clear();\n        cin >> p >> q >> m;\n        while ( m-- ){\n            cin >> u >> v;\n            v += p;\n            edges[u].pb ( v );\n            edges[v].pb ( u );\n        }\n\n        p += q;\n        for ( int i = 0 ; i <= p ; i++ ){\n            if ( match[i] == -1 ){\n                turn++;\n                // 省去每次 dfs 都要 memset 一次 visit 陣列的時間\n                if ( dfs ( i ) )\n                    ans++;\n                    // 如果可以找到新的配對就 ans++\n            }\n        }\n\n        cout << ans << '\\n';\n    }\n}\n```\n\n\n## tips\n\n然後這邊我有用到一個小技巧，可以避免 TLE\n通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow\n不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）\n如果我們把這個陣列開成 int 陣列\n並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪\n這樣就不用浪費時間去 memset 了","source":"_posts/TOJ-407.md","raw":"---\ntitle: '[TOJ][407] D. 警力配置'\ndate: 2018-08-16 21:59:42\ntags:\n - TOJ\n - graph\n---\n\n又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =\n<del>別再給我增加工作量啊垃圾</del>\n我還要把舊站的文章搬過來改成 md 檔啊 = =\n\n\n## 題目\n\n我先附上[連結](http://toj.tfcis.org/oj/pro/407/)\n\n題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」\n不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組\n<!--more-->\n有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長\n組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長\n\n**注意：至少有一個 $\\to$ 有兩個也沒關係**\n\n這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫\n<del>（但是不小心撈到73分，我問號）</del>\n\n\n## 解法\n\n很顯然的要先轉成一張圖，這絕對是圖論 = =\n也就是說題意可以被化簡成這樣：\n給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到\n。。。啊不就匈牙利\n既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下[這篇](http://www.csie.ntnu.edu.tw/~u91029/Matching.html)\n然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法\n\n因為這題真的是裸題（？）所以我就直接附 code 了\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n\n#define maxN 200005\n\nvector < int > edges[maxN];\nint match[maxN], visit[maxN], turn;\n\ninline bool dfs ( int n ){\n    visit[n] = turn;\n    for ( auto i: edges[n] ){\n        if ( match[i] == -1 || ( visit[match[i]] != turn && dfs ( match[i] ) ) ){\n            match[i] = n;\n            match[n] = i;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, m, u, v, p, q, ans;\n    cin >> t;\n    while ( t-- ){\n        ans = 0;\n        memset ( match, -1, sizeof match );\n        for ( auto &i: edges )\n            i.clear();\n        cin >> p >> q >> m;\n        while ( m-- ){\n            cin >> u >> v;\n            v += p;\n            edges[u].pb ( v );\n            edges[v].pb ( u );\n        }\n\n        p += q;\n        for ( int i = 0 ; i <= p ; i++ ){\n            if ( match[i] == -1 ){\n                turn++;\n                // 省去每次 dfs 都要 memset 一次 visit 陣列的時間\n                if ( dfs ( i ) )\n                    ans++;\n                    // 如果可以找到新的配對就 ans++\n            }\n        }\n\n        cout << ans << '\\n';\n    }\n}\n```\n\n\n## tips\n\n然後這邊我有用到一個小技巧，可以避免 TLE\n通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow\n不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）\n如果我們把這個陣列開成 int 陣列\n並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪\n這樣就不用浪費時間去 memset 了","slug":"TOJ-407","published":1,"updated":"2020-05-03T10:27:23.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqk000mf19p6ggk8ebd","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =<br><del>別再給我增加工作量啊垃圾</del><br>我還要把舊站的文章搬過來改成 md 檔啊 = =</p><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>我先附上<a href=\"http://toj.tfcis.org/oj/pro/407/\" target=\"_blank\" rel=\"noopener\">連結</a></p><p>題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」<br>不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組</p><a id=\"more\"></a><p>有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長<br>組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長</p><p><strong>注意：至少有一個 $\\to$ 有兩個也沒關係</strong></p><p>這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫<br><del>（但是不小心撈到73分，我問號）</del></p><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>很顯然的要先轉成一張圖，這絕對是圖論 = =<br>也就是說題意可以被化簡成這樣：<br>給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到<br>。。。啊不就匈牙利<br>既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下<a href=\"http://www.csie.ntnu.edu.tw/~u91029/Matching.html\" target=\"_blank\" rel=\"noopener\">這篇</a><br>然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法</p><p>因為這題真的是裸題（？）所以我就直接附 code 了</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> match[maxN], visit[maxN], turn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    visit[n] = turn;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( match[i] == <span class=\"number\">-1</span> || ( visit[match[i]] != turn &amp;&amp; dfs ( match[i] ) ) )&#123;</span><br><span class=\"line\">            match[i] = n;</span><br><span class=\"line\">            match[n] = i;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, m, u, v, p, q, ans;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( match, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> match );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: edges )</span><br><span class=\"line\">            i.clear();</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; p &gt;&gt; q &gt;&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">            v += p;</span><br><span class=\"line\">            edges[u].pb ( v );</span><br><span class=\"line\">            edges[v].pb ( u );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        p += q;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= p ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( match[i] == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">                turn++;</span><br><span class=\"line\">                <span class=\"comment\">// 省去每次 dfs 都要 memset 一次 visit 陣列的時間</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( dfs ( i ) )</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果可以找到新的配對就 ans++</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"tips\"><a class=\"header-anchor\" href=\"#tips\"></a>tips</h2><p>然後這邊我有用到一個小技巧，可以避免 TLE<br>通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow<br>不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）<br>如果我們把這個陣列開成 int 陣列<br>並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪<br>這樣就不用浪費時間去 memset 了</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =<br><del>別再給我增加工作量啊垃圾</del><br>我還要把舊站的文章搬過來改成 md 檔啊 = =</p><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>我先附上<a href=\"http://toj.tfcis.org/oj/pro/407/\" target=\"_blank\" rel=\"noopener\">連結</a></p><p>題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」<br>不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組</p>","more":"<p>有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長<br>組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長</p><p><strong>注意：至少有一個 $\\to$ 有兩個也沒關係</strong></p><p>這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫<br><del>（但是不小心撈到73分，我問號）</del></p><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>很顯然的要先轉成一張圖，這絕對是圖論 = =<br>也就是說題意可以被化簡成這樣：<br>給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到<br>。。。啊不就匈牙利<br>既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下<a href=\"http://www.csie.ntnu.edu.tw/~u91029/Matching.html\" target=\"_blank\" rel=\"noopener\">這篇</a><br>然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法</p><p>因為這題真的是裸題（？）所以我就直接附 code 了</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> match[maxN], visit[maxN], turn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    visit[n] = turn;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( match[i] == <span class=\"number\">-1</span> || ( visit[match[i]] != turn &amp;&amp; dfs ( match[i] ) ) )&#123;</span><br><span class=\"line\">            match[i] = n;</span><br><span class=\"line\">            match[n] = i;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, m, u, v, p, q, ans;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( match, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> match );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: edges )</span><br><span class=\"line\">            i.clear();</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; p &gt;&gt; q &gt;&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">            v += p;</span><br><span class=\"line\">            edges[u].pb ( v );</span><br><span class=\"line\">            edges[v].pb ( u );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        p += q;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= p ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( match[i] == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">                turn++;</span><br><span class=\"line\">                <span class=\"comment\">// 省去每次 dfs 都要 memset 一次 visit 陣列的時間</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( dfs ( i ) )</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果可以找到新的配對就 ans++</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"tips\"><a class=\"header-anchor\" href=\"#tips\"></a>tips</h2><p>然後這邊我有用到一個小技巧，可以避免 TLE<br>通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow<br>不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）<br>如果我們把這個陣列開成 int 陣列<br>並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪<br>這樣就不用浪費時間去 memset 了</p><!-- rebuild by neat -->"},{"title":"Disjoint Set 並查集","date":"2018-09-11T00:16:11.000Z","_content":"\n上一篇blog因為介紹並查集的地方太多了，文章太長\n所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了\n然後會在昨天文章上加入這篇的連結\n<!--more-->\n\n## disjoint set 並查集\n\n我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）\n在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$\n至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了\n\n這個時候大概會寫出像這樣的 code\n\n```cpp\n// disjoint set\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 10005\n\nint dis[maxN];\n\ninline void init ( void ){\n    for ( int i = 0 ; i < maxN ; i++ )\n        dis[i] = i;\n}\n\ninline int find ( int n ){\n    return dis[n] == n ? dis[n] : find ( dis[n] );\n}\n\ninline void Union ( int a, int b ){\n    dis[a] = b;\n}\n\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b );\n}\n```\n\n### 路徑壓縮\n\n我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）\n所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰\n下次就可以直接略過中間的點，直接到老大那了\n\nfind 函數會被改成這樣\n親民寫法：\n```cpp\nvoid find ( int n ){\n    if ( dis[n] == n )\n        return n;\n    return dis[n] = find ( n );\n}\n```\n\n然後就是會有人（例如我），會想要把它寫在一起\n所以就變成這樣了XD\n```cpp\nvoid find ( int n ){\n    return dis[n] == n ? n : dis[n] = find ( dis[n] );\n}\n```\n\n最後這個東西的複雜度會變成均攤 $O ( \\log N )$，感覺還不錯\n\n\n### 避免 Stack Overflow\n\n最最最後有個東西也挺重要的\n因為路徑壓縮還是要按照這個點的遍歷往上爬\n又是用遞迴實作\n所以有機會會戳到 Stack overflow\n然後你就吃 RE 了\n恭喜多一個 penalty\n重點是你不知道**這樣會吃到 Stack overflow** 然後就會多吃幾個w\n\n雖然說現在很多 judge 都避免掉了啦\n會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大\n只是難免會戳到那種舊型 judge\n所以還是乖乖學一下怎麼避免 Stack overflow 吧\n\n要壓縮遞迴深度，可以有兩種方法\n\n#### 方法一：random\n\n在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍\n但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦\n\n```cpp\ninline void Union ( int a, int b ){\n    dis[a] = b;\n    find ( rand() % n );\n}\n```\n\n#### 方法二：Union by rank\n\n把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈\n理論上這樣應該不會爆炸，因為深度很平均\n\n```cpp\nint rk[maxN];\n\ninline void Union ( int a, int b ){\n    if ( rk[a] < rk[b] )\n        swap ( a, b );\n    dis[b] = a;\n    rk[b] = rk[a] + 1 ;\n}\n```\n\n這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下\n那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數\n至於那是啥我也不知道，只知道幾乎可以算是常數了\n\n不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用\n\n#### 方法三：Union by size\n\n這也挺直觀的\n把大小比較小的並查集接在大的下面\n比較小，需要做改動的點就比較少，對吧\n\n```cpp\nint sz[maxN];\n\ninline void Union ( int a, int b ){\n    if ( sz[a] > sz[b] )\n        swap ( a, b );\n    dis[a] = b;\n    sz[b] += sz[a];\n}\n```\n\n#### 如果開優化還是爛了呢\n\n通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size\n再爛掉。。。這應該是叫你去寫啟發式合併吧\n據說那東西比並查集還要快\n不過我也沒有實作過，所以我並不清楚\n\n\n### 確認是否屬於同一個並查集\n\n確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內\n\n```cpp\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b )\n}\n```\n\n\n用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了\n\n\n## 後記\n\n我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =\n現在看了一下，我光 dsu 就寫 171 行了@@\n覺得累","source":"_posts/dsu.md","raw":"---\ntitle: 'Disjoint Set 並查集'\ndate: 2018-09-11 08:16:11\ntags:\n - dsu\n - disjoint set\n - data structure\n---\n\n上一篇blog因為介紹並查集的地方太多了，文章太長\n所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了\n然後會在昨天文章上加入這篇的連結\n<!--more-->\n\n## disjoint set 並查集\n\n我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）\n在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$\n至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了\n\n這個時候大概會寫出像這樣的 code\n\n```cpp\n// disjoint set\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 10005\n\nint dis[maxN];\n\ninline void init ( void ){\n    for ( int i = 0 ; i < maxN ; i++ )\n        dis[i] = i;\n}\n\ninline int find ( int n ){\n    return dis[n] == n ? dis[n] : find ( dis[n] );\n}\n\ninline void Union ( int a, int b ){\n    dis[a] = b;\n}\n\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b );\n}\n```\n\n### 路徑壓縮\n\n我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）\n所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰\n下次就可以直接略過中間的點，直接到老大那了\n\nfind 函數會被改成這樣\n親民寫法：\n```cpp\nvoid find ( int n ){\n    if ( dis[n] == n )\n        return n;\n    return dis[n] = find ( n );\n}\n```\n\n然後就是會有人（例如我），會想要把它寫在一起\n所以就變成這樣了XD\n```cpp\nvoid find ( int n ){\n    return dis[n] == n ? n : dis[n] = find ( dis[n] );\n}\n```\n\n最後這個東西的複雜度會變成均攤 $O ( \\log N )$，感覺還不錯\n\n\n### 避免 Stack Overflow\n\n最最最後有個東西也挺重要的\n因為路徑壓縮還是要按照這個點的遍歷往上爬\n又是用遞迴實作\n所以有機會會戳到 Stack overflow\n然後你就吃 RE 了\n恭喜多一個 penalty\n重點是你不知道**這樣會吃到 Stack overflow** 然後就會多吃幾個w\n\n雖然說現在很多 judge 都避免掉了啦\n會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大\n只是難免會戳到那種舊型 judge\n所以還是乖乖學一下怎麼避免 Stack overflow 吧\n\n要壓縮遞迴深度，可以有兩種方法\n\n#### 方法一：random\n\n在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍\n但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦\n\n```cpp\ninline void Union ( int a, int b ){\n    dis[a] = b;\n    find ( rand() % n );\n}\n```\n\n#### 方法二：Union by rank\n\n把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈\n理論上這樣應該不會爆炸，因為深度很平均\n\n```cpp\nint rk[maxN];\n\ninline void Union ( int a, int b ){\n    if ( rk[a] < rk[b] )\n        swap ( a, b );\n    dis[b] = a;\n    rk[b] = rk[a] + 1 ;\n}\n```\n\n這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下\n那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數\n至於那是啥我也不知道，只知道幾乎可以算是常數了\n\n不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用\n\n#### 方法三：Union by size\n\n這也挺直觀的\n把大小比較小的並查集接在大的下面\n比較小，需要做改動的點就比較少，對吧\n\n```cpp\nint sz[maxN];\n\ninline void Union ( int a, int b ){\n    if ( sz[a] > sz[b] )\n        swap ( a, b );\n    dis[a] = b;\n    sz[b] += sz[a];\n}\n```\n\n#### 如果開優化還是爛了呢\n\n通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size\n再爛掉。。。這應該是叫你去寫啟發式合併吧\n據說那東西比並查集還要快\n不過我也沒有實作過，所以我並不清楚\n\n\n### 確認是否屬於同一個並查集\n\n確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內\n\n```cpp\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b )\n}\n```\n\n\n用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了\n\n\n## 後記\n\n我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =\n現在看了一下，我光 dsu 就寫 171 行了@@\n覺得累","slug":"dsu","published":1,"updated":"2020-05-03T10:27:23.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqs000pf19p4i2h6b36","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>上一篇blog因為介紹並查集的地方太多了，文章太長<br>所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了<br>然後會在昨天文章上加入這篇的連結</p><a id=\"more\"></a><h2 id=\"disjoint-set-並查集\"><a class=\"header-anchor\" href=\"#disjoint-set-並查集\"></a>disjoint set 並查集</h2><p>我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）<br>在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$<br>至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了</p><p>這個時候大概會寫出像這樣的 code</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// disjoint set</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 10005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">        dis[i] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? dis[n] : find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"路徑壓縮\"><a class=\"header-anchor\" href=\"#路徑壓縮\"></a>路徑壓縮</h3><p>我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）<br>所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰<br>下次就可以直接略過中間的點，直接到老大那了</p><p>find 函數會被改成這樣<br>親民寫法：</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( dis[n] == n )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] = find ( n );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然後就是會有人（例如我），會想要把它寫在一起<br>所以就變成這樣了XD</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>最後這個東西的複雜度會變成均攤 $O ( \\log N )$，感覺還不錯</p><h3 id=\"避免-Stack-Overflow\"><a class=\"header-anchor\" href=\"#避免-Stack-Overflow\"></a>避免 Stack Overflow</h3><p>最最最後有個東西也挺重要的<br>因為路徑壓縮還是要按照這個點的遍歷往上爬<br>又是用遞迴實作<br>所以有機會會戳到 Stack overflow<br>然後你就吃 RE 了<br>恭喜多一個 penalty<br>重點是你不知道<strong>這樣會吃到 Stack overflow</strong> 然後就會多吃幾個w</p><p>雖然說現在很多 judge 都避免掉了啦<br>會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大<br>只是難免會戳到那種舊型 judge<br>所以還是乖乖學一下怎麼避免 Stack overflow 吧</p><p>要壓縮遞迴深度，可以有兩種方法</p><h4 id=\"方法一：random\"><a class=\"header-anchor\" href=\"#方法一：random\"></a>方法一：random</h4><p>在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍<br>但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">    find ( rand() % n );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：Union-by-rank\"><a class=\"header-anchor\" href=\"#方法二：Union-by-rank\"></a>方法二：Union by rank</h4><p>把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈<br>理論上這樣應該不會爆炸，因為深度很平均</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> rk[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( rk[a] &lt; rk[b] )</span><br><span class=\"line\">        swap ( a, b );</span><br><span class=\"line\">    dis[b] = a;</span><br><span class=\"line\">    rk[b] = rk[a] + <span class=\"number\">1</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下<br>那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數<br>至於那是啥我也不知道，只知道幾乎可以算是常數了</p><p>不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用</p><h4 id=\"方法三：Union-by-size\"><a class=\"header-anchor\" href=\"#方法三：Union-by-size\"></a>方法三：Union by size</h4><p>這也挺直觀的<br>把大小比較小的並查集接在大的下面<br>比較小，需要做改動的點就比較少，對吧</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sz[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( sz[a] &gt; sz[b] )</span><br><span class=\"line\">        swap ( a, b );</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">    sz[b] += sz[a];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"如果開優化還是爛了呢\"><a class=\"header-anchor\" href=\"#如果開優化還是爛了呢\"></a>如果開優化還是爛了呢</h4><p>通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size<br>再爛掉。。。這應該是叫你去寫啟發式合併吧<br>據說那東西比並查集還要快<br>不過我也沒有實作過，所以我並不清楚</p><h3 id=\"確認是否屬於同一個並查集\"><a class=\"header-anchor\" href=\"#確認是否屬於同一個並查集\"></a>確認是否屬於同一個並查集</h3><p>確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了</p><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =<br>現在看了一下，我光 dsu 就寫 171 行了@@<br>覺得累</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>上一篇blog因為介紹並查集的地方太多了，文章太長<br>所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了<br>然後會在昨天文章上加入這篇的連結</p>","more":"<h2 id=\"disjoint-set-並查集\"><a class=\"header-anchor\" href=\"#disjoint-set-並查集\"></a>disjoint set 並查集</h2><p>我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）<br>在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$<br>至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了</p><p>這個時候大概會寫出像這樣的 code</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// disjoint set</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 10005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">        dis[i] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? dis[n] : find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"路徑壓縮\"><a class=\"header-anchor\" href=\"#路徑壓縮\"></a>路徑壓縮</h3><p>我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）<br>所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰<br>下次就可以直接略過中間的點，直接到老大那了</p><p>find 函數會被改成這樣<br>親民寫法：</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( dis[n] == n )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] = find ( n );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然後就是會有人（例如我），會想要把它寫在一起<br>所以就變成這樣了XD</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>最後這個東西的複雜度會變成均攤 $O ( \\log N )$，感覺還不錯</p><h3 id=\"避免-Stack-Overflow\"><a class=\"header-anchor\" href=\"#避免-Stack-Overflow\"></a>避免 Stack Overflow</h3><p>最最最後有個東西也挺重要的<br>因為路徑壓縮還是要按照這個點的遍歷往上爬<br>又是用遞迴實作<br>所以有機會會戳到 Stack overflow<br>然後你就吃 RE 了<br>恭喜多一個 penalty<br>重點是你不知道<strong>這樣會吃到 Stack overflow</strong> 然後就會多吃幾個w</p><p>雖然說現在很多 judge 都避免掉了啦<br>會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大<br>只是難免會戳到那種舊型 judge<br>所以還是乖乖學一下怎麼避免 Stack overflow 吧</p><p>要壓縮遞迴深度，可以有兩種方法</p><h4 id=\"方法一：random\"><a class=\"header-anchor\" href=\"#方法一：random\"></a>方法一：random</h4><p>在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍<br>但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">    find ( rand() % n );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：Union-by-rank\"><a class=\"header-anchor\" href=\"#方法二：Union-by-rank\"></a>方法二：Union by rank</h4><p>把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈<br>理論上這樣應該不會爆炸，因為深度很平均</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> rk[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( rk[a] &lt; rk[b] )</span><br><span class=\"line\">        swap ( a, b );</span><br><span class=\"line\">    dis[b] = a;</span><br><span class=\"line\">    rk[b] = rk[a] + <span class=\"number\">1</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下<br>那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數<br>至於那是啥我也不知道，只知道幾乎可以算是常數了</p><p>不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用</p><h4 id=\"方法三：Union-by-size\"><a class=\"header-anchor\" href=\"#方法三：Union-by-size\"></a>方法三：Union by size</h4><p>這也挺直觀的<br>把大小比較小的並查集接在大的下面<br>比較小，需要做改動的點就比較少，對吧</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sz[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( sz[a] &gt; sz[b] )</span><br><span class=\"line\">        swap ( a, b );</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">    sz[b] += sz[a];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"如果開優化還是爛了呢\"><a class=\"header-anchor\" href=\"#如果開優化還是爛了呢\"></a>如果開優化還是爛了呢</h4><p>通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size<br>再爛掉。。。這應該是叫你去寫啟發式合併吧<br>據說那東西比並查集還要快<br>不過我也沒有實作過，所以我並不清楚</p><h3 id=\"確認是否屬於同一個並查集\"><a class=\"header-anchor\" href=\"#確認是否屬於同一個並查集\"></a>確認是否屬於同一個並查集</h3><p>確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了</p><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =<br>現在看了一下，我光 dsu 就寫 171 行了@@<br>覺得累</p><!-- rebuild by neat -->"},{"title":"[TOJ][420] C. 藏寶圖","date":"2018-09-10T06:17:57.000Z","_content":"\n今天來講講自己出的題目好了\n這題是我在今年（2018）六月時排名賽出的題目\n搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ\n<!--more-->\n\n\n## 題目\n\n先附上[原題目網址](https://toj.tfcis.org/oj/pro/420/)\n\n題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑\nMST 怎麼做？我這邊選用 Kruskal\n（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）\n\n## 先備知識\n\n在提 Kruskal 前，我們先講講 MST 到底是什麼吧\n\n### 最小生成樹\nMST 的正式全名為「最小生成樹」\n所謂的生成樹就是把這張圖拔掉一些邊後，這張圖*沒有環*以及*所有點都有聯通*\n也就是說：\n假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有*剛好*一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹\n\n而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T'$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹\n\n### 樹直徑\n\n那麼樹直徑又是什麼呢？\n通常樹直徑就是一棵樹上的任意點對的最長距離\n\n## 作法\n\n### Kruskal\n\n我先講講Kruskal是什麼好了\n\n按照MST的定義，有個很直觀的想法\n1. 先按照邊的權重對於所有邊由小到大排序過\n2. 依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中\n\n至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧\n這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)\n詳細內容可以看[這篇](https://miohitokiri5474.github.io/code/dsu/)\n\n### 樹直徑\n\n樹直徑作法通常有兩個：\n1. dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑\n2. 先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案\n\n作法1還挺好瞭解的，只是實作上可能會出包\n作法2有點費時間，但是很好寫\n\n\n## code\n\n總而言之，我的 code 長這樣\n是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 1000005\ntypedef pair < int, int > pii;\ntypedef long long LL;\n#define pb push_back\n#define F first\n#define S second\n\nstruct node{\n    int u, v, w;\n};\n\ninline bool cmp ( node a, node b ){\n    return a.w < b.w;\n}\n\nint dis[maxN];\nLL dist[maxN];\nvector < node > edges;\nvector < pii > mst[maxN];\n\ninline void init ( void ){\n    for ( int i = 0 ; i < maxN ; i++ )\n        dis[i] = i;\n}\n\nint find ( int n ){\n    return dis[n] == n ? n : dis[n] = find ( dis[n] );\n}\n\ninline void Union ( int a, int b ){\n    dis[find ( a )] = find ( b );\n}\n\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b );\n}\n\ninline void Kruskal ( void ){\n    sort ( edges.begin(), edges.end(), cmp );\n    for ( auto &i: edges ){\n        if ( same ( i.u, i.v ) )\n            continue;\n        Union ( i.u, i.v );\n        mst[i.u].pb ( pii ( i.v, i.w ) );\n        mst[i.v].pb ( pii ( i.u, i.w ) );\n    }\n}\n\nvoid dfs ( int n, int p ){ // 樹直徑\n    for ( auto i: mst[n] ){\n        if ( i.F == p )\n            continue;\n        dist[i.F] = dist[n] + i.S;\n        dfs ( i.F, n );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, u, v, w, t, idx, now;\n    LL ma = -1;\n    cin >> n >> m;\n    init();\n    while ( m-- ){\n        cin >> u >> v >> w;\n        edges.pb ( node { u, v, w } );\n    }\n\n    Kruskal();\n\n    dfs ( 0, -1 );\n    for ( int i = 0 ; i < n ; i++ )\n        if ( ma < dist[i] )\n            ma = dist[i], idx = i;\n\n    dist[idx] = 0;\n    dfs ( idx, -1 );\n    ma = -1;\n    for ( int i = 0 ; i < n ; i++ )\n        ma = max ( ma, dist[i] );\n\n    cout << ma << '\\n';\n}\n```\n\n\n## 後記\n\n我這一篇文我有種我是在寫 disjoint set 教學的錯覺\n覺得累\n大半篇幅都是在教 disjoint set\n看來原始 md 檔要破 300 行了呢（倒地\n\n然後還有那一堆數學式子，看到頭都在痛\n我個人還蠻喜歡寫那些東西的\n看起來很猛（就是中二啦 = =\n不過常常寫到一半會開始懷疑\n我沒事寫那麼難動幹嘛\n沒事虐待自己幹嘛\n話雖如此不過還是寫完了啦XD\n\n\n## 更新(2019/03/06)\n\n雖然說不是最近的事了，不過我想我還是提一下好了\n因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了\n所以目前在 TOJ 上寫不到這題喔\n非常抱歉 > <","source":"_posts/TOJ-420.md","raw":"---\ntitle: '[TOJ][420] C. 藏寶圖'\ndate: 2018-09-10 14:17:57\ntags:\n - TOJ\n - MST\n - dsu\n - dfs\n - 樹直徑\n - Kruskal\n---\n\n今天來講講自己出的題目好了\n這題是我在今年（2018）六月時排名賽出的題目\n搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ\n<!--more-->\n\n\n## 題目\n\n先附上[原題目網址](https://toj.tfcis.org/oj/pro/420/)\n\n題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑\nMST 怎麼做？我這邊選用 Kruskal\n（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）\n\n## 先備知識\n\n在提 Kruskal 前，我們先講講 MST 到底是什麼吧\n\n### 最小生成樹\nMST 的正式全名為「最小生成樹」\n所謂的生成樹就是把這張圖拔掉一些邊後，這張圖*沒有環*以及*所有點都有聯通*\n也就是說：\n假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有*剛好*一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹\n\n而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T'$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹\n\n### 樹直徑\n\n那麼樹直徑又是什麼呢？\n通常樹直徑就是一棵樹上的任意點對的最長距離\n\n## 作法\n\n### Kruskal\n\n我先講講Kruskal是什麼好了\n\n按照MST的定義，有個很直觀的想法\n1. 先按照邊的權重對於所有邊由小到大排序過\n2. 依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中\n\n至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧\n這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)\n詳細內容可以看[這篇](https://miohitokiri5474.github.io/code/dsu/)\n\n### 樹直徑\n\n樹直徑作法通常有兩個：\n1. dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑\n2. 先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案\n\n作法1還挺好瞭解的，只是實作上可能會出包\n作法2有點費時間，但是很好寫\n\n\n## code\n\n總而言之，我的 code 長這樣\n是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 1000005\ntypedef pair < int, int > pii;\ntypedef long long LL;\n#define pb push_back\n#define F first\n#define S second\n\nstruct node{\n    int u, v, w;\n};\n\ninline bool cmp ( node a, node b ){\n    return a.w < b.w;\n}\n\nint dis[maxN];\nLL dist[maxN];\nvector < node > edges;\nvector < pii > mst[maxN];\n\ninline void init ( void ){\n    for ( int i = 0 ; i < maxN ; i++ )\n        dis[i] = i;\n}\n\nint find ( int n ){\n    return dis[n] == n ? n : dis[n] = find ( dis[n] );\n}\n\ninline void Union ( int a, int b ){\n    dis[find ( a )] = find ( b );\n}\n\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b );\n}\n\ninline void Kruskal ( void ){\n    sort ( edges.begin(), edges.end(), cmp );\n    for ( auto &i: edges ){\n        if ( same ( i.u, i.v ) )\n            continue;\n        Union ( i.u, i.v );\n        mst[i.u].pb ( pii ( i.v, i.w ) );\n        mst[i.v].pb ( pii ( i.u, i.w ) );\n    }\n}\n\nvoid dfs ( int n, int p ){ // 樹直徑\n    for ( auto i: mst[n] ){\n        if ( i.F == p )\n            continue;\n        dist[i.F] = dist[n] + i.S;\n        dfs ( i.F, n );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, u, v, w, t, idx, now;\n    LL ma = -1;\n    cin >> n >> m;\n    init();\n    while ( m-- ){\n        cin >> u >> v >> w;\n        edges.pb ( node { u, v, w } );\n    }\n\n    Kruskal();\n\n    dfs ( 0, -1 );\n    for ( int i = 0 ; i < n ; i++ )\n        if ( ma < dist[i] )\n            ma = dist[i], idx = i;\n\n    dist[idx] = 0;\n    dfs ( idx, -1 );\n    ma = -1;\n    for ( int i = 0 ; i < n ; i++ )\n        ma = max ( ma, dist[i] );\n\n    cout << ma << '\\n';\n}\n```\n\n\n## 後記\n\n我這一篇文我有種我是在寫 disjoint set 教學的錯覺\n覺得累\n大半篇幅都是在教 disjoint set\n看來原始 md 檔要破 300 行了呢（倒地\n\n然後還有那一堆數學式子，看到頭都在痛\n我個人還蠻喜歡寫那些東西的\n看起來很猛（就是中二啦 = =\n不過常常寫到一半會開始懷疑\n我沒事寫那麼難動幹嘛\n沒事虐待自己幹嘛\n話雖如此不過還是寫完了啦XD\n\n\n## 更新(2019/03/06)\n\n雖然說不是最近的事了，不過我想我還是提一下好了\n因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了\n所以目前在 TOJ 上寫不到這題喔\n非常抱歉 > <","slug":"TOJ-420","published":1,"updated":"2020-05-03T10:27:23.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqw000rf19p8cgt241q","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>今天來講講自己出的題目好了<br>這題是我在今年（2018）六月時排名賽出的題目<br>搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ</p><a id=\"more\"></a><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>先附上<a href=\"https://toj.tfcis.org/oj/pro/420/\" target=\"_blank\" rel=\"noopener\">原題目網址</a></p><p>題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑<br>MST 怎麼做？我這邊選用 Kruskal<br>（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）</p><h2 id=\"先備知識\"><a class=\"header-anchor\" href=\"#先備知識\"></a>先備知識</h2><p>在提 Kruskal 前，我們先講講 MST 到底是什麼吧</p><h3 id=\"最小生成樹\"><a class=\"header-anchor\" href=\"#最小生成樹\"></a>最小生成樹</h3><p>MST 的正式全名為「最小生成樹」<br>所謂的生成樹就是把這張圖拔掉一些邊後，這張圖<em>沒有環</em>以及<em>所有點都有聯通</em><br>也就是說：<br>假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有<em>剛好</em>一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹</p><p>而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T’$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹</p><h3 id=\"樹直徑\"><a class=\"header-anchor\" href=\"#樹直徑\"></a>樹直徑</h3><p>那麼樹直徑又是什麼呢？<br>通常樹直徑就是一棵樹上的任意點對的最長距離</p><h2 id=\"作法\"><a class=\"header-anchor\" href=\"#作法\"></a>作法</h2><h3 id=\"Kruskal\"><a class=\"header-anchor\" href=\"#Kruskal\"></a>Kruskal</h3><p>我先講講Kruskal是什麼好了</p><p>按照MST的定義，有個很直觀的想法</p><ol><li>先按照邊的權重對於所有邊由小到大排序過</li><li>依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中</li></ol><p>至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧<br>這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)<br>詳細內容可以看<a href=\"https://miohitokiri5474.github.io/code/dsu/\">這篇</a></p><h3 id=\"樹直徑-v2\"><a class=\"header-anchor\" href=\"#樹直徑-v2\"></a>樹直徑</h3><p>樹直徑作法通常有兩個：</p><ol><li>dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑</li><li>先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案</li></ol><p>作法1還挺好瞭解的，只是實作上可能會出包<br>作法2有點費時間，但是很好寫</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><p>總而言之，我的 code 長這樣<br>是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">cmp</span> <span class=\"params\">( node a, node b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\">LL dist[maxN];</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; node &gt; edges;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; pii &gt; mst[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">        dis[i] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[find ( a )] = find ( b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Kruskal</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        Union ( i.u, i.v );</span><br><span class=\"line\">        mst[i.u].pb ( pii ( i.v, i.w ) );</span><br><span class=\"line\">        mst[i.v].pb ( pii ( i.u, i.w ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> p )</span></span>&#123; <span class=\"comment\">// 樹直徑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: mst[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i.F == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dist[i.F] = dist[n] + i.S;</span><br><span class=\"line\">        dfs ( i.F, n );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, u, v, w, t, idx, now;</span><br><span class=\"line\">    LL ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class=\"line\">        edges.pb ( node &#123; u, v, w &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Kruskal();</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs ( <span class=\"number\">0</span>, <span class=\"number\">-1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ma &lt; dist[i] )</span><br><span class=\"line\">            ma = dist[i], idx = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    dist[idx] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dfs ( idx, <span class=\"number\">-1</span> );</span><br><span class=\"line\">    ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">        ma = max ( ma, dist[i] );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ma &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>我這一篇文我有種我是在寫 disjoint set 教學的錯覺<br>覺得累<br>大半篇幅都是在教 disjoint set<br>看來原始 md 檔要破 300 行了呢（倒地</p><p>然後還有那一堆數學式子，看到頭都在痛<br>我個人還蠻喜歡寫那些東西的<br>看起來很猛（就是中二啦 = =<br>不過常常寫到一半會開始懷疑<br>我沒事寫那麼難動幹嘛<br>沒事虐待自己幹嘛<br>話雖如此不過還是寫完了啦XD</p><h2 id=\"更新-2019-03-06\"><a class=\"header-anchor\" href=\"#更新-2019-03-06\"></a>更新(2019/03/06)</h2><p>雖然說不是最近的事了，不過我想我還是提一下好了<br>因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了<br>所以目前在 TOJ 上寫不到這題喔<br>非常抱歉 &gt; &lt;</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>今天來講講自己出的題目好了<br>這題是我在今年（2018）六月時排名賽出的題目<br>搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ</p>","more":"<h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>先附上<a href=\"https://toj.tfcis.org/oj/pro/420/\" target=\"_blank\" rel=\"noopener\">原題目網址</a></p><p>題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑<br>MST 怎麼做？我這邊選用 Kruskal<br>（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）</p><h2 id=\"先備知識\"><a class=\"header-anchor\" href=\"#先備知識\"></a>先備知識</h2><p>在提 Kruskal 前，我們先講講 MST 到底是什麼吧</p><h3 id=\"最小生成樹\"><a class=\"header-anchor\" href=\"#最小生成樹\"></a>最小生成樹</h3><p>MST 的正式全名為「最小生成樹」<br>所謂的生成樹就是把這張圖拔掉一些邊後，這張圖<em>沒有環</em>以及<em>所有點都有聯通</em><br>也就是說：<br>假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有<em>剛好</em>一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹</p><p>而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T’$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹</p><h3 id=\"樹直徑\"><a class=\"header-anchor\" href=\"#樹直徑\"></a>樹直徑</h3><p>那麼樹直徑又是什麼呢？<br>通常樹直徑就是一棵樹上的任意點對的最長距離</p><h2 id=\"作法\"><a class=\"header-anchor\" href=\"#作法\"></a>作法</h2><h3 id=\"Kruskal\"><a class=\"header-anchor\" href=\"#Kruskal\"></a>Kruskal</h3><p>我先講講Kruskal是什麼好了</p><p>按照MST的定義，有個很直觀的想法</p><ol><li>先按照邊的權重對於所有邊由小到大排序過</li><li>依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中</li></ol><p>至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧<br>這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)<br>詳細內容可以看<a href=\"https://miohitokiri5474.github.io/code/dsu/\">這篇</a></p><h3 id=\"樹直徑-v2\"><a class=\"header-anchor\" href=\"#樹直徑-v2\"></a>樹直徑</h3><p>樹直徑作法通常有兩個：</p><ol><li>dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑</li><li>先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案</li></ol><p>作法1還挺好瞭解的，只是實作上可能會出包<br>作法2有點費時間，但是很好寫</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><p>總而言之，我的 code 長這樣<br>是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">cmp</span> <span class=\"params\">( node a, node b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\">LL dist[maxN];</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; node &gt; edges;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; pii &gt; mst[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">        dis[i] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[find ( a )] = find ( b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Kruskal</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        Union ( i.u, i.v );</span><br><span class=\"line\">        mst[i.u].pb ( pii ( i.v, i.w ) );</span><br><span class=\"line\">        mst[i.v].pb ( pii ( i.u, i.w ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> p )</span></span>&#123; <span class=\"comment\">// 樹直徑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: mst[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i.F == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dist[i.F] = dist[n] + i.S;</span><br><span class=\"line\">        dfs ( i.F, n );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, u, v, w, t, idx, now;</span><br><span class=\"line\">    LL ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class=\"line\">        edges.pb ( node &#123; u, v, w &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Kruskal();</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs ( <span class=\"number\">0</span>, <span class=\"number\">-1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ma &lt; dist[i] )</span><br><span class=\"line\">            ma = dist[i], idx = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    dist[idx] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dfs ( idx, <span class=\"number\">-1</span> );</span><br><span class=\"line\">    ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">        ma = max ( ma, dist[i] );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ma &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>我這一篇文我有種我是在寫 disjoint set 教學的錯覺<br>覺得累<br>大半篇幅都是在教 disjoint set<br>看來原始 md 檔要破 300 行了呢（倒地</p><p>然後還有那一堆數學式子，看到頭都在痛<br>我個人還蠻喜歡寫那些東西的<br>看起來很猛（就是中二啦 = =<br>不過常常寫到一半會開始懷疑<br>我沒事寫那麼難動幹嘛<br>沒事虐待自己幹嘛<br>話雖如此不過還是寫完了啦XD</p><h2 id=\"更新-2019-03-06\"><a class=\"header-anchor\" href=\"#更新-2019-03-06\"></a>更新(2019/03/06)</h2><p>雖然說不是最近的事了，不過我想我還是提一下好了<br>因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了<br>所以目前在 TOJ 上寫不到這題喔<br>非常抱歉 &gt; &lt;</p><!-- rebuild by neat -->"},{"title":"進階資料結構 for NCKU-ICPC Week 9","date":"2020-05-02T09:54:39.000Z","password":"maiismywife","_content":"\n# Week 9 DLC\n\n## 前言\n\n有些內容筆者本來想要放在這週的授課內容中\n不過一來是筆者的期中快要爆炸，沒有空做簡報\n另一方面由於授課內容偏難，放在影片中可能會讓影片長度暴增（像是變成三個小時）\n因此決定另外寫一篇文章來當作補充內容，並且發在自己的部落格\n\n<!--more-->\n\n## 線段樹 Extra\n\n### 持久化\n\n#### 老樣子開始前先看個題目\n\n> 給定一個長度為 $N$ 的序列，並且有 $M$ 條指令，指令內容如下\n>\n> 1. 修改其中一個元素的值\n> 2. 查詢查詢區間 $[l, r]$ 內的最大值\n> 3. 回復到第 k 次修改後的狀態\n>\n> $N, M \\le 10 ^ 5, k \\le$ 當前修改次數, $0 \\le l, r \\lt N$\n\n1, 2 都還是基本的線段樹，那麼 3 呢\n\n感覺可以每修改一次就開一顆新的線段樹，要回朔就複製回去\n\n所以需要開到 $M$ 棵線段樹，所以要開 $4NM$ 的記憶體......先 MLE 了\n再看一下時間複雜度：$O(M(N + \\log N))$ （先複製一遍 $O(N)$，再做單點修改 $O(\\log N)$，最糟糕要執行 $M$ 次）\n從各種方面來看感覺都不會過\n\n#### 先觀察一下\n\n對於每次修改，會修改到的地方只有從根節點到要修改的點的路徑而已\n也就是說 **其他節點沿用舊的資料也沒關係**\n\n> 這邊記得放結構圖\n\n但是用陣列寫就要另外維護節點編號，從實作上來說是幾乎不可能達成的事\n看來我們需要換個想法\n\n#### Hmmm，指標？\n\n沒錯，就是指標\n只要紀錄記憶體位置就好，不用把整個 node 都複製過去\n\n所以現在線段樹要改成指標版本\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n\tnode *l, *r;\n\tint value;\n\n\tnode ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) {}\n\n\tinline void up ( void ){\n\t\tvalue = -1;\n\t\tif ( l )\n\t\t\tvalue = max ( value, l -> value );\n\t\tif ( r )\n\t\t\tvalue = max ( value, r -> value );\n\t}\n} *seg = nullptr;\n\nvoid build ( int l, int r, node *&o ){\n\to = new node ( 0 );\n\tif ( l == r )\n\t\treturn;\n\tint mid = ( l + r ) >> 1;\n\tbuild ( l, mid, o -> l );\n\tbuild ( mid + 1, r, o -> r );\n\n\to -> up();\n}\n\nvoid update ( int l, int r, int index, int value, node *&o ){\n\tif ( l == r )\n\t\to -> value = value;\n\telse{\n\t\tint mid = ( l + r ) >> 1;\n\t\tif ( index <= mid )\n\t\t\tupdate ( l, mid, index, value, o -> l );\n\t\telse\n\t\t\tupdate ( mid + 1, r, index, value, o -> r );\n\n\t\to -> up();\n\t}\n}\n\nint query ( int l, int r, int nowL, int nowR, node *o ){\n\tif ( l <= nowR && nowR <= r )\n\t\treturn o -> value;\n\tint mid = ( nowL + nowR ) >> 1;\n\tif ( r <= mid )\n\t\treturn query ( l, r, nowL, mid, o -> l );\n\tif ( mid < l )\n\t\treturn query ( l, r, mid + 1, nowR, o -> r );\n\n\treturn max ( query ( l, r, nowL, mid, o -> l ), query ( l, r, mid + 1, nowR, o -> r ) );\n}\n\nint main(){\n\tios::sync_with_stdio ( false );\n\tcin.tie ( 0 );\n\tcout.tie ( 0 );\n\n\tint n, m, l, r, in, type;\n\tcin >> n >> m;\n\tbuild ( 1, n, seg );\n\tfor ( int i = 1 ; i <= n ; i++ ){\n\t\tcin >> in;\n\t\tupdate ( 1, n, i, in, seg );\n\t}\n\n\t// type 1: 單點修改\n\t// type 2: 區間查詢最大值\n\twhile ( m-- ){\n\t\tcin >> type;\n\t\tif ( type == 1 ){\n\t\t\tcin >> l >> in;\n\t\t\tupdate ( 1, n, l, in, seg );\n\t\t}\n\t\telse if ( type == 2 ){\n\t\t\tcin >> l >> r;\n\t\t\tcout << query ( l, r, 1, n, seg ) << '\\n';\n\t\t}\n\t}\n}\n```\n\n#### 持久化\n\n因為要保留舊版本，所以對所有需要被修改的節點新開一個位置來\n並且把左右子結點的指標，指向原本左右子結點的位置\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n\tnode *l, *r;\n\tint value;\n\n\tnode ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) {}\n\t// 新增一個建構子，可以直接複製原本的 l, r\n\tnode ( node *o ): l ( o -> l ), r ( o -> r ), value ( o -> value ) {}\n\n\tinline void up ( void ){\n\t\tvalue = -1;\n\t\tif ( l )\n\t\t\tvalue = max ( value, l -> value );\n\t\tif ( r )\n\t\t\tvalue = max ( value, r -> value );\n\t}\n} *seg = nullptr;\n\nvoid build ( int l, int r, node *&o ){\n\to = new node ( 0 );\n\tif ( l == r )\n\t\treturn;\n\tint mid = ( l + r ) >> 1;\n\tbuild ( l, mid, o -> l );\n\tbuild ( mid + 1, r, o -> r );\n\n\to -> up();\n}\n\nvoid update ( int l, int r, int index, int value, node *&o ){\n\t// 把需要修改的節點在修改前先開一個新位置出來\n\to = new node ( o );\n\tif ( l == r )\n\t\to -> value = value;\n\telse{\n\t\tint mid = ( l + r ) >> 1;\n\t\tif ( index <= mid )\n\t\t\tupdate ( l, mid, index, value, o -> l );\n\t\telse\n\t\t\tupdate ( mid + 1, r, index, value, o -> r );\n\n\t\to -> up();\n\t}\n}\n\nint query ( int l, int r, int nowL, int nowR, node *o ){\n\tif ( l <= nowR && nowR <= r )\n\t\treturn o -> value;\n\tint mid = ( nowL + nowR ) >> 1;\n\tif ( r <= mid )\n\t\treturn query ( l, r, nowL, mid, o -> l );\n\tif ( mid < l )\n\t\treturn query ( l, r, mid + 1, nowR, o -> r );\n\n\treturn max ( query ( l, r, nowL, mid, o -> l ), query ( l, r, mid + 1, nowR, o -> r ) );\n}\n\nint main(){\n\tios::sync_with_stdio ( false );\n\tcin.tie ( 0 );\n\tcout.tie ( 0 );\n\n\tint n, m, l, r, in, type;\n    // 紀錄版本用的 vector\n\tvector < node* > version;\n\tcin >> n >> m;\n\tbuild ( 1, n, seg );\n\tfor ( int i = 1 ; i <= n ; i++ ){\n\t\tcin >> in;\n\t\tupdate ( 1, n, i, in, seg );\n\t}\n\t// 記錄初始版本\n\tversion.push_back ( seg );\n\n\t// type 1: 單點修改\n\t// type 2: 區間查詢最大值\n\t// type 3: 回朔到版本 k\n\twhile ( m-- ){\n\t\tcin >> type;\n\t\tif ( type == 1 ){\n\t\t\tcin >> l >> in;\n\t\t\tupdate ( 1, n, l, in, seg );\n\t\t\t// 修改完紀錄版本\n\t\t\tversion.push_back ( seg );\n\t\t}\n\t\telse if ( type == 2 ){\n\t\t\tcin >> l >> r;\n\t\t\tcout << query ( l, r, 1, n, seg ) << '\\n';\n\t\t}\n\t\telse{\n\t\t\t// 回朔到版本 k\n\t\t\tcin >> in;\n\t\t\tseg = version[in];\n\t\t}\n\t}\n}\n```\n\n##### 有修改過的地方\n\n| line   | 修改內容                                |\n| ------ | --------------------------------------- |\n| 12     | 新增一個建構子，可以直接複製原本的 l, r |\n| 36     | 在對節點修改前先開一個新的位置          |\n| 69     | 記錄用的 vector                         |\n| 77, 88 | 修改完成後，記錄當前版本內容            |\n| 94     | 新增一個操作，可回朔到版本 k            |\n\n### 非簡單操作線段樹\n\n#### 我們還是看個題目\n\n> 現在給定一個長度為 $N$ 序列，以及 $M$ 筆操作，操作內容有\n>\n> 1. 修改一個元素的值\n> 2. 查詢區間中最長的「好序列」長度\n>\n> 定義一個「好區間」為：每個元素都是前一個元素 + 1\n>\n> 這邊是一個題目叫大龍貓的濃縮版，完整版題目可以看 [這邊](http://toj.tfcis.org/oj/pro/365/)\n\n現在有點麻煩了，RMQ 我們會，但是這種該怎麼用線段樹實作\n\n我們可以在 node 中紀錄目前最長的好序列長度，以及其開始位置以及結束位置\n每次合併兩個區間就取兩邊紀錄的最長好序列的最大值\n\nEmmm，但是感覺好像怪怪的\n如果合併兩個區間後，交界處那邊形成一個更長的好序列，怎麼辦？\n\n尷尬，那我們只好在每個 node 也記錄從開頭處到結束處的好序列了\n\n聽起來很複雜，但是其實一點也不\n\n為了方便編寫，我們先定義一個 piece，還有如何辨識兩個 piece 是否相同\n\n```cpp\nstruct piece{\n\tint l, r, sz;\n\n\t// 檢查兩個 piece 是否相同\n\tbool operator == ( const piece b ){\n\t\treturn l == b.l && r == b.r;\n\t}\n};\n\n// 不想寫 operator（或是覺得太麻煩）可以這樣寫\ninline bool same ( piece a, piece b ){\n\treturn a.l == b.l && a.r == b.r;\n}\n```\n\n$l, r$ 就是這個區間的左右界\n$sz$ 是大小，可有可無，只是寫 code 上方便\n\n然後是 node\n\n```cpp\nstruct node{\n    piece front, back, ma;\n};\n```\n\n$front, back$ 分別為是記錄當前線段樹區間內，從左邊界開始的好序列長度，以及從右邊屆開始的好序列長度\n$ma$ 則是記錄當前線段樹區間內，最長的好序列長度\n\n接著來寫合併兩個區間的函數吧，因為沒有內建的函數可以用，只能自己寫一下\n\n```cpp\ninline node merge ( node L, node R ){\n    node res;\n\tres.front = L.front, res.back = R.back, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\n\n\tif ( basic[L.back.r] + 1 == basic[R.front.l] ){\n\t\tpiece swp = piece { L.back.l, R.front.r, R.front.r - L.back.l + 1 };\n\n\t\tif ( L.front == L.back )\n\t\t\tres.front = swp;\n\t\tif ( R.front == R.back )\n\t\t\tres.back = swp;\n\n\t\tres.ma = ( swp.sz > res.ma.sz ? swp : res.ma );\n\t}\n\n\treturn res;\n}\n```\n\n合併兩個區間後，要回傳的 res 內容如下\n\n| res 內的 piece | 來源                                             |\n| -------------- | ------------------------------------------------ |\n| front          | l.front                                          |\n| back           | r.back                                           |\n| ma             | l.ma, r.ma, l.back + r.back 這三者中的最長好序列 |\n\n\n\n\n\n## 後記\n\n這篇文章寫的也挺久的，主要是文中的內容大部分都不常用到，在寫的時候還跑去翻了一些文章\n\n正因如此，內容上可能有些錯誤，如有發現，請聯絡 [筆者](https://miohitokiri5474.github.io/code/about/)","source":"_posts/ncku-icpc-2020-week9-dlc.md","raw":"---\ntitle: '進階資料結構 for NCKU-ICPC Week 9'\ndate: 2020-05-02 17:54:39\ntags:\n - Data Structure\n - Segment Tree\npassword: maiismywife\n\n---\n\n# Week 9 DLC\n\n## 前言\n\n有些內容筆者本來想要放在這週的授課內容中\n不過一來是筆者的期中快要爆炸，沒有空做簡報\n另一方面由於授課內容偏難，放在影片中可能會讓影片長度暴增（像是變成三個小時）\n因此決定另外寫一篇文章來當作補充內容，並且發在自己的部落格\n\n<!--more-->\n\n## 線段樹 Extra\n\n### 持久化\n\n#### 老樣子開始前先看個題目\n\n> 給定一個長度為 $N$ 的序列，並且有 $M$ 條指令，指令內容如下\n>\n> 1. 修改其中一個元素的值\n> 2. 查詢查詢區間 $[l, r]$ 內的最大值\n> 3. 回復到第 k 次修改後的狀態\n>\n> $N, M \\le 10 ^ 5, k \\le$ 當前修改次數, $0 \\le l, r \\lt N$\n\n1, 2 都還是基本的線段樹，那麼 3 呢\n\n感覺可以每修改一次就開一顆新的線段樹，要回朔就複製回去\n\n所以需要開到 $M$ 棵線段樹，所以要開 $4NM$ 的記憶體......先 MLE 了\n再看一下時間複雜度：$O(M(N + \\log N))$ （先複製一遍 $O(N)$，再做單點修改 $O(\\log N)$，最糟糕要執行 $M$ 次）\n從各種方面來看感覺都不會過\n\n#### 先觀察一下\n\n對於每次修改，會修改到的地方只有從根節點到要修改的點的路徑而已\n也就是說 **其他節點沿用舊的資料也沒關係**\n\n> 這邊記得放結構圖\n\n但是用陣列寫就要另外維護節點編號，從實作上來說是幾乎不可能達成的事\n看來我們需要換個想法\n\n#### Hmmm，指標？\n\n沒錯，就是指標\n只要紀錄記憶體位置就好，不用把整個 node 都複製過去\n\n所以現在線段樹要改成指標版本\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n\tnode *l, *r;\n\tint value;\n\n\tnode ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) {}\n\n\tinline void up ( void ){\n\t\tvalue = -1;\n\t\tif ( l )\n\t\t\tvalue = max ( value, l -> value );\n\t\tif ( r )\n\t\t\tvalue = max ( value, r -> value );\n\t}\n} *seg = nullptr;\n\nvoid build ( int l, int r, node *&o ){\n\to = new node ( 0 );\n\tif ( l == r )\n\t\treturn;\n\tint mid = ( l + r ) >> 1;\n\tbuild ( l, mid, o -> l );\n\tbuild ( mid + 1, r, o -> r );\n\n\to -> up();\n}\n\nvoid update ( int l, int r, int index, int value, node *&o ){\n\tif ( l == r )\n\t\to -> value = value;\n\telse{\n\t\tint mid = ( l + r ) >> 1;\n\t\tif ( index <= mid )\n\t\t\tupdate ( l, mid, index, value, o -> l );\n\t\telse\n\t\t\tupdate ( mid + 1, r, index, value, o -> r );\n\n\t\to -> up();\n\t}\n}\n\nint query ( int l, int r, int nowL, int nowR, node *o ){\n\tif ( l <= nowR && nowR <= r )\n\t\treturn o -> value;\n\tint mid = ( nowL + nowR ) >> 1;\n\tif ( r <= mid )\n\t\treturn query ( l, r, nowL, mid, o -> l );\n\tif ( mid < l )\n\t\treturn query ( l, r, mid + 1, nowR, o -> r );\n\n\treturn max ( query ( l, r, nowL, mid, o -> l ), query ( l, r, mid + 1, nowR, o -> r ) );\n}\n\nint main(){\n\tios::sync_with_stdio ( false );\n\tcin.tie ( 0 );\n\tcout.tie ( 0 );\n\n\tint n, m, l, r, in, type;\n\tcin >> n >> m;\n\tbuild ( 1, n, seg );\n\tfor ( int i = 1 ; i <= n ; i++ ){\n\t\tcin >> in;\n\t\tupdate ( 1, n, i, in, seg );\n\t}\n\n\t// type 1: 單點修改\n\t// type 2: 區間查詢最大值\n\twhile ( m-- ){\n\t\tcin >> type;\n\t\tif ( type == 1 ){\n\t\t\tcin >> l >> in;\n\t\t\tupdate ( 1, n, l, in, seg );\n\t\t}\n\t\telse if ( type == 2 ){\n\t\t\tcin >> l >> r;\n\t\t\tcout << query ( l, r, 1, n, seg ) << '\\n';\n\t\t}\n\t}\n}\n```\n\n#### 持久化\n\n因為要保留舊版本，所以對所有需要被修改的節點新開一個位置來\n並且把左右子結點的指標，指向原本左右子結點的位置\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n\tnode *l, *r;\n\tint value;\n\n\tnode ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) {}\n\t// 新增一個建構子，可以直接複製原本的 l, r\n\tnode ( node *o ): l ( o -> l ), r ( o -> r ), value ( o -> value ) {}\n\n\tinline void up ( void ){\n\t\tvalue = -1;\n\t\tif ( l )\n\t\t\tvalue = max ( value, l -> value );\n\t\tif ( r )\n\t\t\tvalue = max ( value, r -> value );\n\t}\n} *seg = nullptr;\n\nvoid build ( int l, int r, node *&o ){\n\to = new node ( 0 );\n\tif ( l == r )\n\t\treturn;\n\tint mid = ( l + r ) >> 1;\n\tbuild ( l, mid, o -> l );\n\tbuild ( mid + 1, r, o -> r );\n\n\to -> up();\n}\n\nvoid update ( int l, int r, int index, int value, node *&o ){\n\t// 把需要修改的節點在修改前先開一個新位置出來\n\to = new node ( o );\n\tif ( l == r )\n\t\to -> value = value;\n\telse{\n\t\tint mid = ( l + r ) >> 1;\n\t\tif ( index <= mid )\n\t\t\tupdate ( l, mid, index, value, o -> l );\n\t\telse\n\t\t\tupdate ( mid + 1, r, index, value, o -> r );\n\n\t\to -> up();\n\t}\n}\n\nint query ( int l, int r, int nowL, int nowR, node *o ){\n\tif ( l <= nowR && nowR <= r )\n\t\treturn o -> value;\n\tint mid = ( nowL + nowR ) >> 1;\n\tif ( r <= mid )\n\t\treturn query ( l, r, nowL, mid, o -> l );\n\tif ( mid < l )\n\t\treturn query ( l, r, mid + 1, nowR, o -> r );\n\n\treturn max ( query ( l, r, nowL, mid, o -> l ), query ( l, r, mid + 1, nowR, o -> r ) );\n}\n\nint main(){\n\tios::sync_with_stdio ( false );\n\tcin.tie ( 0 );\n\tcout.tie ( 0 );\n\n\tint n, m, l, r, in, type;\n    // 紀錄版本用的 vector\n\tvector < node* > version;\n\tcin >> n >> m;\n\tbuild ( 1, n, seg );\n\tfor ( int i = 1 ; i <= n ; i++ ){\n\t\tcin >> in;\n\t\tupdate ( 1, n, i, in, seg );\n\t}\n\t// 記錄初始版本\n\tversion.push_back ( seg );\n\n\t// type 1: 單點修改\n\t// type 2: 區間查詢最大值\n\t// type 3: 回朔到版本 k\n\twhile ( m-- ){\n\t\tcin >> type;\n\t\tif ( type == 1 ){\n\t\t\tcin >> l >> in;\n\t\t\tupdate ( 1, n, l, in, seg );\n\t\t\t// 修改完紀錄版本\n\t\t\tversion.push_back ( seg );\n\t\t}\n\t\telse if ( type == 2 ){\n\t\t\tcin >> l >> r;\n\t\t\tcout << query ( l, r, 1, n, seg ) << '\\n';\n\t\t}\n\t\telse{\n\t\t\t// 回朔到版本 k\n\t\t\tcin >> in;\n\t\t\tseg = version[in];\n\t\t}\n\t}\n}\n```\n\n##### 有修改過的地方\n\n| line   | 修改內容                                |\n| ------ | --------------------------------------- |\n| 12     | 新增一個建構子，可以直接複製原本的 l, r |\n| 36     | 在對節點修改前先開一個新的位置          |\n| 69     | 記錄用的 vector                         |\n| 77, 88 | 修改完成後，記錄當前版本內容            |\n| 94     | 新增一個操作，可回朔到版本 k            |\n\n### 非簡單操作線段樹\n\n#### 我們還是看個題目\n\n> 現在給定一個長度為 $N$ 序列，以及 $M$ 筆操作，操作內容有\n>\n> 1. 修改一個元素的值\n> 2. 查詢區間中最長的「好序列」長度\n>\n> 定義一個「好區間」為：每個元素都是前一個元素 + 1\n>\n> 這邊是一個題目叫大龍貓的濃縮版，完整版題目可以看 [這邊](http://toj.tfcis.org/oj/pro/365/)\n\n現在有點麻煩了，RMQ 我們會，但是這種該怎麼用線段樹實作\n\n我們可以在 node 中紀錄目前最長的好序列長度，以及其開始位置以及結束位置\n每次合併兩個區間就取兩邊紀錄的最長好序列的最大值\n\nEmmm，但是感覺好像怪怪的\n如果合併兩個區間後，交界處那邊形成一個更長的好序列，怎麼辦？\n\n尷尬，那我們只好在每個 node 也記錄從開頭處到結束處的好序列了\n\n聽起來很複雜，但是其實一點也不\n\n為了方便編寫，我們先定義一個 piece，還有如何辨識兩個 piece 是否相同\n\n```cpp\nstruct piece{\n\tint l, r, sz;\n\n\t// 檢查兩個 piece 是否相同\n\tbool operator == ( const piece b ){\n\t\treturn l == b.l && r == b.r;\n\t}\n};\n\n// 不想寫 operator（或是覺得太麻煩）可以這樣寫\ninline bool same ( piece a, piece b ){\n\treturn a.l == b.l && a.r == b.r;\n}\n```\n\n$l, r$ 就是這個區間的左右界\n$sz$ 是大小，可有可無，只是寫 code 上方便\n\n然後是 node\n\n```cpp\nstruct node{\n    piece front, back, ma;\n};\n```\n\n$front, back$ 分別為是記錄當前線段樹區間內，從左邊界開始的好序列長度，以及從右邊屆開始的好序列長度\n$ma$ 則是記錄當前線段樹區間內，最長的好序列長度\n\n接著來寫合併兩個區間的函數吧，因為沒有內建的函數可以用，只能自己寫一下\n\n```cpp\ninline node merge ( node L, node R ){\n    node res;\n\tres.front = L.front, res.back = R.back, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\n\n\tif ( basic[L.back.r] + 1 == basic[R.front.l] ){\n\t\tpiece swp = piece { L.back.l, R.front.r, R.front.r - L.back.l + 1 };\n\n\t\tif ( L.front == L.back )\n\t\t\tres.front = swp;\n\t\tif ( R.front == R.back )\n\t\t\tres.back = swp;\n\n\t\tres.ma = ( swp.sz > res.ma.sz ? swp : res.ma );\n\t}\n\n\treturn res;\n}\n```\n\n合併兩個區間後，要回傳的 res 內容如下\n\n| res 內的 piece | 來源                                             |\n| -------------- | ------------------------------------------------ |\n| front          | l.front                                          |\n| back           | r.back                                           |\n| ma             | l.ma, r.ma, l.back + r.back 這三者中的最長好序列 |\n\n\n\n\n\n## 後記\n\n這篇文章寫的也挺久的，主要是文中的內容大部分都不常用到，在寫的時候還跑去翻了一些文章\n\n正因如此，內容上可能有些錯誤，如有發現，請聯絡 [筆者](https://miohitokiri5474.github.io/code/about/)","slug":"ncku-icpc-2020-week9-dlc","published":1,"updated":"2020-05-03T11:02:35.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqx000tf19p2twtd8ax","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">Hey, password is required here.</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"66f8bd09c851ea92c6ac3ddd0428ae39e91beb1398f7735ccd6163184d6c1077\">4f11c70cde93ad29e66f0be09f1124977d8d9743a8dc8aacfca075bef2885b7951e6dd9849ac90ec6738945eb80a01793dbd576b97fbe274ecf45aceb15e87f74fb4dc31384ba1b57ed556e1abb937cb2fbdcbf4e7ab4fa86151af5a9f27c0f99512e998d5751c00a579373c76adc6567dc86bd48be8b29f626278490ef29d46370cb31a1d8ea066dc58e0b23032c633d7f7387db269fac76620a8bb1fc89b84ae604d7de7a2ccd27d017f5ead8205e37f4cc91db7b8755835f9aae0c24f9bb78dc2953ba58932e23be748ee444ab339b96af6071042962fdff345e0af27c49758affd66b69e2a621e5728da191b0f21d8f5edb873f020a69dedcc539f9274c36b1f71a369eb1e858c2978e177342c458f51d07a5d7962c5dd9e0b0fc4088df65bf1c4e34a239572cc9ef4d1307cefb05b0f46b9ea1efa8b8a5df73baba8caa25d02fcdaebdd88eff069f53753176ab7765da96ff2648aa4a035e5653d24af49cbaceb4650d3d481d877f9113edf0f2ed4f28e4913d5481dbc47088c562768746b0901d2c088440336edb2d89b96e8df6cca8163b5ab673798e15813fbd94ed3da78ddd137a80f2c737181c1c38e163b0789a3b5767ea47d89c13e1d17b9df2ae7ddbeb5b205382f4dcc701e513a40cee23d4acdec8faf96480866e4b3517f81d84a878adc742fcba7207b9dab43f9992050a6ee5b65fff5807c8a2224f83bd17948eda7378b0395900b23f77fbd5a72db4eecb0c1c469a03c857b9c949af7e5bfd74e181eb50f6291773fcc90f2e5cac5fdac6b255364820dd31e41b3c727acee0dd07830880d9907bae6d40dfba152b7957d975e4ffda39d9cc391981c37883097702286179bba3352564e8d76b9703c3f7222fd62f661b70b236ad5695f58adbb90db99dc53aeb9e8afba0de4a19972e474dc0a9887ca5f2d7a5b71f4abd27a8a9c52008901cdc5d197d97611df6325914817d630f51413e0cb392ae8d0c209d59507f1a9478e3dda307521229bf43da6fbdfd6c42c3dc7e1c6f5ef02ab2824c6464ae5098f5a6f0235c195d1b0d2da7c858b069d5b5528441b78eb42b6fe3a1789fdd1c7c31c0e84da61fc51cc693f8a50362a421a165ba7733e503f1a9c079b19ae803a7df2673944218a38921cfe04e41f4ed9708987d319e35de43527e5b52a07be708c6bc78afb562b8ee8e18cda9def8acce995fe75d50fec74e2e273d72a00c869f16cee9414c86b4be94be2b5f72c30552cf5f2dc316287b573e4a6a8b15dc0effa2d5d36b55d34546657f7a2a0ae48d69e0e64d85c0489bcfd22b5ad4d75425112ccc402507e983536aed9c3a4064b8da8baa552e26aaa25c4caf61abf89455fc51b05fc841bfcf8981708b1357bdd48405576fd38fc9bc40e66b3cfd3811966e1510dcaae194aa4881e2c9f83c6fbe38733e899ab2f91f03fb5254b774790ffe2958ac18057d8ec3613190548e47f58f16297b3d3f1d770eff25b8fe8d9ca202b7b4277dfff2007643d90a052c10cad881dda4cc44889f04804377c2a7f31cf82f4f64496b975edf2f684165431b54a4dcb527364846258b4c57e129d73355e849bcbe559f16b5a76b5a8b7d8fc29cd73ed818d911ceef4c790640f950bd63a00fa83929dc21d2fb50999824ae7e41bd2f569b7fa008b7ee2e91df16bb8b7ddf87190856247c7a878b330f3cd057711c76132bf4c3ab528627e85e195e52390f629a07d291be081d630f08e68205e699342788edc3c002f35e81382314693cbecd2fa51096777122cc848934dddf0446d63059c8a1f71ea9b26c400a20d41a41364134baccf16884596db8c9cf12d929ccf1875c025200a18301d33fe135a7e4bb786cba2c27111a943b8d65250be2b61cf1c8cda3f0fc3081e129026c61adfc87479e0cadd1dd9e1847ab38fb9e5c8eed0ed512a1b81f60f4e4c19585dc9e4dfab57e286e4120c3141a50c6f25795f709e1eeeb2f87094df52e6ab6fc68462b52689fe82820b3486441bc1644acfa384beb971c9ab600a0e52d3623bb4ccd681fbfdff23a125c99f1f3561f973a29c682e36eef77cee286e9df69c9679ce47db54582234bdead67501435bb94d1e60a26d08cfa71cc5627eb450b19f27e887e539b0f81b9102c959c1d65e23bf6b515308c2d0bd6e0e3d225dd81e0bcbfbdbea89da7a3c43b87d52833f60c735088a442fc2804c8b18ad1eba3bf367ab249459a92960092070be18afe43c5b6183dafb217561f67ddd283364b22fd1df432aa912f1ce85beb6b69337fb378de87eca160680d5cdeb8a7d0c46785ea30e85beb6d677079bdc9e9fc71841c398ea8ee9bbac826c2297cf7439b6b7832213cd33b586a6df53d9dd7e41658d4190fcce5a646de8a8096db35fed39b3d809659fdf85723975569ea14ffe272aa8dc3594a35e51d519aaefed6d26dffed75e72c7a3a3da01c46c8c4c26f4dc673b7524253a3d739eb6148548c0ccb50fb84e78b757fa19c9da837f80fd7a41249110833dce6fac7698fb53002a6b2522873215c0a085ee231a72156787a0a6f03dc1c64517bcd1d94522fc94a3f2a18550d5d4af8537ac6b1eb8bdaf4dc4f4e11220771a1b2590af48d56e2cbec29ccb9457f925cb8c079aee143657901602e940c622b435dfb42833c5335d873a4ab0901882ccf1ebadedb874d818ac30415e93aa5e1ac0260c8bf53ed99926da521267e64f4437ae430b9efdbf4c2d69c776510f7d0b41ad269ec212aae10075e0bfcbddede06cb554ca0929048c1ca9d33a64859e95941996a340e71f123a25451a2643ac6daac701a6153e1363133d06c883777181d6a436f2ac3f5e23c838aa2d8ba47ee4d5c39a080f656f2264edc641cd8c1afedeebf66bf6e69a7bff6da80de825c7bc1e92f4ab74dd2d2a3e0e0eaba34f92428c066e91db7f9f3aa923b849a4230fd42caf287b49053c78aa41d6b9bca4d86c01aebc646b804e1574221d17617cd0a7511079f822d77f1a7bc3080e95c2b35a15f839876f8eaaa9599e20b6393fc2374490efacf0acefa5d1d30aa77d2c2534b9fa0128bb0d8afcb2e6a5fb43baca5d0b54344e96db78d52d330f8d95e6f4b116ff652069bcb4d3ebc1e2ecf3cef2a0171eb6577f86511b73ef4cdace5a4a6b525dfa6699e31a548c786369a98bd8d03f0e28fcfde5e66fcd466f617aaa88e3ad16815fcbb5f4d047a5f8a240d5732a972024b7c954d612415a07a725a94c27f333460c274d91b48b1ba9150f946e5b28d017845ebd1b1e31c9cc044c9d859799b5cd526392cfd2a4df8da6b8f2e6cfe7a3093f92f4bc75caa3b1251cece0df0753814a606c98a664c17193f08a3728821eeeb2e282ec82ab221c5a76ff23434c6cf6f2a14792e55f25ad14daa114738804d5378fe32b13c4e9c9ad135858142bfbef1e7ebd6f11bf7b79ff51c4ff2a10bdab1777a941b50f777691d662a1bf7ae9ae2b2ec6235f6d694477152ea4e78a03c1c993a4b27ecf1fa20a9f6d1880965cea86fe115cf34ad8eee0511cd7ce455bdf2db8b192dc7744a216e8e1acf2846e16cb874e429a325915ee5016c7c17cb515d9569c8a38b8cb316d381e4b2a6f98fb3e81982016b0204229bb6e9f43515fda776d9830239a5406b86c4caacbd7b51a9bbf57524e56d2b9f904ce58e1b172b3ef4bca87d7373b0123a1bde1a0878ea23b06767126fa543c795a5be383155d0f60c2c7dd89b36e5553cf7765d29b61aaa7dab9b04e1eb96d54e91f8a7760f7f185506ac85488927bf68e4bdb8326a1c3e4201a90a5dae15679602b5ca8a06c10a6a9b666e15cba5a5d0111de2336c45e02a8f6f7eb3402198df5d06d12805f432d66e7e29d6ea6486b0fa5c6c7cf4d220b3863762b054793bb57efd16ac73edb2b1564034d29039fcb43aca6de5c0289d7d8dd6d78b8024ac4471a4436d8dc3f287dfc6722d02b32bc3972a205ff24dbcc2553748c6796e5b83a69d8929548aa30706ac01096e10548a46cce8187b84abe59e0a862dc13265763b537a915b46243b6db29c1d2d40349520003407e27ad904a36323277b76ae5036a6cbf3d62e23225d316cc661911aabec939998469475305ca0373078f8020c3c8ec1a36ccfc4d4cf19ac5f018375f156f1471fb8864f957d8a7ebe5fcacbde07b4723638a43571a5246ba0e7182ecf5a5a7ce9181d8ba814b19b218ac00ad9b0d21f562ac9f0380ebb2a7d20ca8e1cc6735b578c9e712454b0fb2bffb3226952d15c77850e6fe48d260d349e4606aa31e041cd24b962cb666df19d47b69f8605de3f31b7e121cce5038042dd03e284657f13d624a70c292531f7c7af25cacb1417ed5ef6e632eff607b5d4c14600f2cab46ae808f1a5aa73f8e21af920ec77b8a8e7d3e8dbf699b1510345aeb6795eb9e906d3a3407ff85247e54df9c0f5792c7a8a842009d2c6060f6adc203a9af91fb712ec495d9695416268be1b39cdaa39be92712ec913657ab4cd0f5214c5054a34842d66b24936c821dc8b7a67813bc72fa0e9a91621d0f45ea9dde1eff89a9fc00c74d329f9edc4084fac1ab4659158960814005a0fe23b8d8c9622cd63ae885f246c85a883bc0e0514870d81ba9675cf77b364e300ff26c8a4fa9836c2fa9bd07fe9d88a07fd43ef902f2f8b3c1efc587d7c0396cb0cfa4816a4ee1245681c9d30c6fdc1a315fa653ff61c7115a6ba695cd7fccf3176263df0e93a2e0712f987e592ab043f1a9ee1cb079dd05468972881a5f581fe1fb6ff0d10316fe9a764c456e72fbb336e3dd9b13b4eeca8f507456fe1e414fedac0887a92fb1f238a453af73aa8f8fba306ce6d9450a5a6b263377aac6ffe428a62d2cad4fa9199be014c39d5b968b9895ab857da11f482e9fbaca7e33857876657e2c08258717ef23c5417b72fce05935659c6899c91d9b63986317586a4026e0379f9380cb8c038da97fa64bfdb1aeb139fe820b28ad38b3b0c2f11d57cfc2159c56446722bdbb72baa037cb0e3309e13bc6dd286d235d587809246f39c790103694e99f976a376b1d4cb66a588feadfdbc4b99c9dabe494d979639fb6620d0c16e46d7093985adf6ea883b78c8e39ae2f6775e4cbf9992fa70a791b12d591a39ffe5dff8e42e0b80b7f263d5934599404fac9d7f8ff4c296617e588ec328b3e7cafd141c478068595dcc6b696a845c1b7b9a41d38eb5e91239ff8b647230f47c95b0d244b5cfa815ee07809ec928330735df93478d3c1c0f0310fd1704c202e03bd92b40f0f6a4fbc38ce1854c1b732aaa2b27f1f810cfb1e10b7d1ead60ed568f5d6f0f2922bbdb3f4611b9d22fdef1f51a0c9764ef9cc6d31efa485b0f11e537cf6143a0f634a8047bc13537328f8719074a6aabf4ddd65a4d447cfbc16de3fab4c82511be899f650492b9070c58b6872ad35ea8d36339b511dec6ef857cec59bff5163f6f5450caa68b2878f52abe29d8917fe62fdab8641804f1d221d964612b80f45af4b774cfc9d0d39580f9d46eaeb4e78d3475c9fbdfdcd6668a572881c17321c39aa124241ace830cdd4cb7e6ceded6a4b386b288a38fbcbbaf6aa52839abb67f3d00173d8559143aa74649bfed26c8fe74084d514a992a8e98e516144bac8ef1043d3271c12e6de199000ff26772d2e79b31a61c318b285a0a961325c8787b0800945a4706489cb2c401ce37e40e1860121ac4e7a122ed558eb4a9843b410b02c7a987cc7435302142ae1ecd902b70c1423bac8c4a23c3f34db5078d89d429311a19691e79a66a4a6ff412799ed1c9e2e7c135148c547a0e6101701303af9d0c333e02e578ba79be09aba0e30b74cd4da6ac4430cc748da9e92948bb29d9bd9b4aead4172ec41171a2b73890bc991c71f4c0c5e5ee16fa416a6c51c13572c9f4f071de83399dd3e8a5f36a1808555bafe627fdc834b9a54452a5615eca6469c27aeb94f35d62eade8bd6b072e16746b3142d8b00d527b97de1bbce27ffc93c1caeb20defc02942d8b62c559a3a31d25f8a67c5011b610c5da2aa99e5aa166b0023d0d0c649ba266ab276dd8ffe568457e80df3cd2f8d35e0788c3a12bd3059e4ec835484a1733c6419c87eba24985a6fc2783af3c73d2477a99133bb280a8e2d64033dbaffaddae4d22fd1903fe774f5481dfb1fa3ccd9118c2c5ac570ecb77ddf6396f762e864e37de036072306e153837f5aa26d46307432fe8e854cae4375c07ca8962b8d03bbfd0280a2dc41e446b92b27a867c5dc77a962da83cb6dafce4bbeba9473fda2bc4d45ef847bae9453192f248c5eb8f8fcbcfbf1b034657587a2f833945ab4203ca8ab054905f2cf25bb5d2b968170c7ceff151d2892cc15623fe69f263f6ce55fd558aefc682aaf78e89797481dae7bd113e88777c33609181dee53274759aaf83f25ac094eeac73eab5e72ab75b43964a28083792e1998b7f13e7ec660b7f6e705cb3bdbbafb2ad473faaaa103722bb402c2545a56e0e3db7e3ab18bb2f8ed6ff783d80d7b7c8f82bd359af882a4e05e2900d1eff14ebab2eba598eadf4726ab39d5df4ae8cdbab618cb830b02d33e97c0ae34b1da4cd21d719f2fd9051383d10457a27ad7a3e6450cf16a1c38cd606a10e09d350bb402316b442f28bd37593bc6f61d680d41ca82f75d3ce6aeae70695e140334af7cf78d9a2176796e78c1e764bb7d5d4669e452ae98579d6e045dd31884cbfa77d623234620e122d616aaf8e3e0d1f5ed6efa033bc76507a4c19461a70aecacb84e34396a40b265469af92405082bcbc99db49b598dcff6cab61736d23752b6ffa8677aa1120c41934839a0397c017e0af560d90083d8a9a7978c94dbf664a92206f34a34c2d88811c996622d0a850df17b6de6a5b4f848fbb228b517dced62999341d6d9f7a258e92ee9d7401e8a5df85927c311bc72553e46d0c31e80a05f5c70b9c933a514f75cf0ebb87a0346fb71835dfd121ed8825c763974e537f163b7c05afd68409e930cd480a65d3d9f8eddb139dccf244db2cbd1a59e69d0ca88a0794e649d72b08a4391651067cdb75e3db870e6dbddbe5b66386f9f564e273037358758e00491d98686319e646d69238cb2ed228c9e9329f0407d087354adad9b5b5eecae513d8d9b172df54f07c4a8d2d249e286a4f4f8930a13a9f2a4578fc42b416e5800f3f85c6627d68b8e9a8318bd0021d2c11112fc03c5be093b89c50a088dd7eba83b840e839c26fa3a36848d9f5115b08a422b6e50ef0fb8a320a65a9fd0c9a4b8d205ca16cae28e5b60fd80dac50426427568da2a5b3dbfd0d5712d58fb89872db4c3c01f3d93a14e50c76e0fa14c6cdbfdc699b0fd28ed609f46675755ffb55f467433ee2c96fa71f8874ddefa28f8300f1f3db3950fe3f6b24f04228ef417536ceae7237c40618647fe2c9c2c71273137328b7aee17a84ae06d376b410ca881fe4c3cbcaad77d54e32f9d1a0f7e0fc60f00f48f31ee1facf5cfb48fe4ae451c5b3c9ed5a6a8a4aeb70d9370f7412adbfb7b4e9c6a8338a5cd27a384ae1960bd041260d8223acd8372520f7aec695f3b1be9767dc49777a9203e0f7e4590ff4cae317d76b731a03fd7325f218905b9a58e4c617169ca3602cf3968608f4e20f10052896e25b14e559c583453c1f8d91398ef32fd1f20fa31efe7619b5cebfcc875a7f04013d90680a04399ca5b2ebfb9621b5b17e7e118ed10649714dab2bb57d22d36dab50c72221ee51c5b4d00564d2523a7d3dc4e8d569ba0bb99ddc3e803005f6df8401abb83ad106a0d814de6b8e061388d86a7d40af09c52846fe1ff2f62895cec912a3e05539a567bed0d1dbf4e1d4187b30514753cf70440599383b70b43369fb6e38d007f3c0ed15942366bfc4bc0400b99d426935a0b47934340b28c3831050ccb9e91a2b20c4207a1449a5ca83f5defd3316fa698273e34a482444c514206cb3328119d7ef70a27ab2f9473d869293eb271caf7a432be3fc795efddda944e5e46672688bf3d756ac8514aed49da6b3bd5d1a12995b8b5418b076790770216bf5f7bfad0d965be63e7ebc93a21aba5afc288a52b7909c4f1c30499d65d2645444b35a4a713f977055b3d4ab73feab5efea49ae275f44ded529875841d8b3a6785f2a228e5f0407ffee536c9db05a67a8179c11173375644d05c8b4138c4086bd96cb7f903486209b34bf99959fba40f6ce522def07642386cfa2e44e322eef1f0222878e1d7bce735291e92d3f2bc75c368d5c1eeb5ab2b48384e22a552876a08e1155dec6542584ea9a6f0fd3956ddfcb62900236ebf44bca28bd72f3ac45675b83c242a1047e347e63bea151d144a1b27e80fa983a056269b91bdb4524f51ab0ccedc3e872107764c573f6604d3b68d7178f359632e76d2fd7f2ad0f1f7eb3aa16527263d95c293e08b0a96318f202ff3f60afcb1281c54687203f661fed368a38a9eb4d3029ec6829ef7b4a0cdfaa6f6cf5da31e0c03bd0e79243e384ec40a56e180795f22a0a91fab91f5cc2cee1d7f9c160e34894b16f33391d49533850fa455fd0c010adc80438fc5e1eb7985c9b2312166e1a0c56c51f9d091b235b8607b026e2a4a8b82a6322fa0bdefaf4f5c54458602a3af132e5498b9f944db7a8c3dca9fd49fbc7562c43aadfe2766393f600510b4ab0797ea0a59491d14982fd932ab6ef9fdc41abfee739b83ad315aa4be0e547b9cab3bd8ff33e38a7a133d1654ed4a68b2bf652b734322b6d735948c7e83e30b922e02bcc06bc05880244a4a36de5d158aac4aaf23a88d6b7f086854afbe327f3b0239362cb153aa4fd7ea50af0df1227e8182a500ef8e52550354c8d70754591ee1c9d0987c74c517cdabcd27e2617dc5112478c5e20ba0d75dfd622d8245385ec29229826ec5e5790f2d62285a9f6b4e6e60c1e46747543c1555da4c72dc8d19a5c306c04b25526a675030309db051ff42f04466167244890635fb7b0402042acbb600e3745e072c2a6ba9fa5dc3ba6c0d08b0864e56d69a1920050e4d6f02800752a7982510026183166c43e72221658b90b90d352f70009ebc5e73aa36476c2ddb3921d600f4f957a1b2518315aba1871b619a1efa34efe1c39bc3e161990ba9eae1725673bba9df886e6e85c5d805a910c687f3085b4be850f10232ec46a27949aab289d2c4c240d55b9a0b46f53ea264aedc50a0dd9d2c41a90fa77984e289ff2edd49a75926aae886c9e0b3e8dd93c960da0cc6c27b1eddc07788a93a65d40dc51aec6e3446a1086f5fb6ab6532781d1af0fa36cb88df71526bf17f31393cebdb9acd735d1c87d488897cd50b954a7b1faca3ea044b10a929eae1ba263d4527a8b78e71fd6a66113abf81a097a11ee1e76a173a64cd481331b6df773eec6f1d791e7967c24cc5a8a40d85960c0b04eadd69c673951cc47f0a7fb249c377d402d1d9854ef6602dc6194d9f402edb78f79aa28fc25f53480899796124e2c11d7d216e0e6e6cc918988a7fc1c6c37c7a0a88406874b866c4b05390fc3c15953e97156965f1cc2cb3b29bf42fa4a4b41d8dabac2a30c67eacb0917e548456868cfbbd62496301f5be30f0a409253f1897722e76bc7c258d3a7fc74688d194f7f0bafa17ae2bd93ec241a139e32979e61d495580ef21fdefd92467d7d15a6660f97d68d656972b0db5a68f31e7f4402c65d84819b44a5de1981fb12d855ada952aa3be44c4707e467e731a0c959e3b4c226b2f8127539f8e026ba60526c9aa3df77192326447881fe597de58b24c5bbe8a1e22b45a0cb4692cf6baa6fc46cd1689333edd7a40785e70991a77bc6a9d5542c7e4661c8339b705ebdf13a3eeea77a0288bbcc1e1ca12579e1bc4ee3e12f2ae1fe1b67e0a5c0b765e8d421fc6ea30886ebbe4d7d7d64e31539f93cda9ada4d80dce9b9ef94cd62e8f04553a87bc2f5521542a136e634162fc00a4102cc689989894ebb5317960b0a5e39cf9adeaf31ed26ccdded6ed1e3c056e6f2c5b6fca3cfe4eaf182895609cbd12444a13dc6dfaf71db647c46cd8955cd6fa452c0deea102eb0b55ab1661bc3a437aff298bbf253d6fcf923e73b034973650c2493faa6ab436444e16be1dab9fe4f82fa781aa3d41df06967092368b38b75a28de669b2d2b095ab2e715f97f35165ac38f43ef8d6ba7873a29db6b772d8b35259247e6fdb0c32486f36461368944f150fa5e878e70dbeb31088407f964011f8722df4e9481bd8a4f83ca94837ee138bdd8c77a6f1794f3c6fd1082f1f31f82124d2a9377b73ac524ab64832061c23de49bacf282f34ea4b3af9f804af0639d44fe0f6219ce0bff6b703075a1e0cf3f538561f9cce19c255e0f7c59c0957a7919ea19850cb15f75a7fde4288c3201baf59d942512b674a768352246062cff3d8c8c755eefba8b5ff7ea0714cc5e7af9b345e1d7d25c1e31539a0c58c97e9bb5abaedc788f2ff45673b923bb2ce0cb05667bca6f535dca7aab55c9b7a049fe126aa203fd99cebc4694e773e750138a95a55e20dfd15a207511c8bd816a80e76d9d9dcc9ea40152c3fbb40d49f85c281f28ebfce665d98481a88f49003d53d594d6e960d07c7985e4b2ca3b0202271d03c1cf7d5f7f3b64bea9c2c22e2104a36dcbe76de40d83e3e7deed71b9de92973665bacf26e09aaf0ebaf22d7090fe19e796c34e557a089523b0505fb071553176ad3640f7b414fc825e571e2359d4551e4a54aa82990c81d57926389b530a3a6622984c05c0dd968b3e251e46033ed0b1d69794f76514217bb110759fe3129f9093aa3c2545f6ad00cf5293eb54ee6bc100b8133ae43df8e01a1cad5ab536a708a8f7be75e09c7ec86dc547b6e04f08c32aa9939d7a031f407e983bb1695c190ca429a27d5cfc90031aa7715f48e66cec06e83488c4c354bd1eb464b130b35c1210a4b4dda900f90946f7c88e5b893207f5a3aa24c662b4085fa94a133055fa00d30cb16de0741f74add916ef04059c6eecd1228ba99e36e5865d4075de545f378fc41204308eed1abd31aa3130c91eb73c7c636d4ad769484e383e9f9dbb975348221e651d0b2f3b205ce77ff26efbfb2f5e9c4162e0a959a5407372f053c70bbf9f8b36b1fd6054d0d9c43d3fdc50a4661cc4e65079233d8eaaff026145bb40e539d9645565291b75f8feb63cd8803241e284b9c5e139076ef72709217b93c9a08450adf1e0b7e7da8ff47ef2e9a46ec1f17881bb5a8d8e5cd95c8b4c2e91c2eb8cee7f241a08f21bffa39ab177033b7b7949148168424db16b456613398cd95d5c42380e599918053f6546d97e6a2d547ad2d5ec28b6cd9bcd11c6f0535231e8e13dec8b95c9e7c1ed50d2f035a4602a1862ba6b8795f4275e54f0c1f951b96e4d5c0d28cb98a188d9838a3cbf27a5c7449fedb0f1349d8db3113f9c0dfdb3bad24dd108f0d3d89e307bf170feacd793dc648b9ff95e1d342ac6e0ac273de7975ba5c28f5061842197b778076a1385b148a8debaa504a873e608b1ef13eb2cd9128edb2a36171b3df8b2a56ac1d42b9da7a39bcd70ff3b0e51f881e6624cfd8c7c53ba7f0b5c236312e23f2021a4069f61a64a1e497bbb7406e4b31e88795472ba89f3328329cadc5ef2c076da2ce03e1771b71d43ade62c19ce5180992d5ce80904a42b74fb4a93397b71f65010687bbe7dbd532615e8b8140cbadc4c7a535d7ca5d5302a80564c7a09aaaeecfb47127ffd97142442da9fe4ae225bbbd9c8ca11e4d3d1e397c08e61e7c149221ea9454962244ab94025b70a78dc13c05269104ab94b5973341e6afe91ad17710eb06a04dab7f7066b876aa828bf71a7d9f78f80e3c4c3a26d6840ad49006c697abc184cf9af89b2a036d559eb2373c2d12868efec125f06f19eca438fbd2f45d5474673c81bc319b43d2a70ab1b71d99f13fbf311e3d1f498844eec8cded74384639a6fb9924e1a3551373596ddc72f44eaaa366493032e1eb66fe8f46cd6c6261e7e12d0d71220f401df69e57268c76f25b806171fd29dc547089a19890a073dfc407ed807becaf3dfb908a1cd064cdb6b1f45450582fde916b6eeaabe11732ee004852667db2800a3664d325e6e81057260ff6cfd32f164e0296d41f917626221dbbbd77a6648de0b9bb27a6977a35445c3aa5702a26dba97b5fad6f64a0af6aa84f1ac8ac879de4b3e0b47423b1fd681c5022b6615f8f710d8a270ad78266e0c8d96c5d69283f5dbca58fa834bdda34b1bc7a732a0e596125a6e57dcca7699a702626432f67c028e8419f98af61eaab3b7fbb1513b71d6fc0fe143b18fc517bb9d6ee49bd5c9c22caec2104eeb10d05d8b2bc6f2dd8671a4eea732971a30e2972bdf05a568fd75b40f7a4c0b053640a690db03bbdccbd9788ba8a43575ddf28bac32ee27f0d049c0e51c6af45db09f1d28d930c07a89b918f8c4b52f0f5c1d74f8f8e96d99f2f0917f320b05dfc32ef45c31e38cc85b5b672cc9214387aa8baa3b924cee0099a94a41f92e18be77b679b5dc08e2131502773bd9e906785f1161e9ae51b2ea0b4a56c050ab8940a64bae711202d0d1bb99effef8bb85f8069319d378e17abc0cfd19c81f3e92cfa4709d4b47e44ea3793443f668ea87a299ec9ff23215d5469734a777d87bdf81d0748d0a26cd1d372becd8c1bd9b879b6a5141f479237b98516be7d70402bf2e1dbeebf8ec6188459fd16e9204868f6d46f9ad22cff302ce1221136ecac80fc51f1042756e3309d1f3b91e54ccbfe413eff06f78fec7f11ed9bdb2ff5eb7303bed24734778eae140c6f1b6d8237b5fdf8940c87d7d920f5cb85e3a3da0a554727402c893ea400b231a75b26e033f1f3614085ff744fdbbfd416ad2735fdc4c93b2c30bb3a473e2485f5ab7aca79bd28877784d071b7b2199e90c19cae97c33def6ed0b30a2b388d6e126f23c1d8551ea3c23a78041fbbd9d7745fe8c41ad783f58d0a09c219ea4c5df6e4904cc360454ce6f1a8a7da69127d1302cda2e65a89b5b7b734c48e95dc968435ec1ae617bf02c719bc708eed22fec06fc71cd469afb471cee37d2e63bab2e1b3d39ebd3e6406ec1aeff6e1bc4515cbd5c39570f7cd58264bdb8dde1ba59babcbfff7683076bce77a4b20d764028c5569227ce2d829dfcd2992426c27e450707617774ce6ac58dccedd111b332b1202a7699209cc648c85a94668a4e907153eeb5874da0972f3fa5caacc61ebb47858f0cc0c762b23513efc0ff6f8d2eef0c1f5fa5b188aea37765c0cc19a27fdf300745cc94ddb730c6bdafd3eb346c9dc0f04d47643670e04e4105d7031f9d195f608ab87a66284d8ad25e1cb5ec9f21755c5f29616303d4941969ab0d057587fb8924d3653ba3b08e3a91109a0c1c3a43b78efc95e22ab7193a8eff991b9f5a9d15b102e5791fd76002283cb23c405e874aa9213d173ebf674e00336c7f4ce81902b4fc1f966567c5ea3bc523e943b035b50b8c9044e1395bbe2c249ffde8bc5748c39fb6e1163f26e4694ba7207f8c765bbf60d0b87202b4f354d612c8e0ae4f51048041afc01bb80902b75d345fd846be9c0fd62aff59bd913032c6647d61b7c7147ffed25751f619aa0ff08934d278291869f864b0d7c9778d42690ed70df6c9ea9c927ccad0b31e57e02db8eeb3329f52b05fa4bd154186cf8931adbbf228057333e7cbbaa6df04392b1f84ddc7ea12fd30fe8826948d55fe2f99afbde549eb486906be05e3b5b77e384f702827c9340fca6fb32d4840a793da8a2a6e15b5c32bcda34a3769960c8208c7e4c8947c4e4f9c2846ba380c6aafc6e20315848c5afd40510085d874b9e3f0436be3a5b52ae5687690fb99d073fcd9900fe6b3add33b7fa8233fd4fe0d39e0a28a275ea6d04472cb7207674ba8004f6f2921b797c8758823f6d1072979fe7526832c0aa712cc9ec2bf7a119ce8c05f179e1b995fdcb735738050c5aac7f18f4c52e08c22a4df281338ab2675366033cc731f083c02a1b3adc6539b618c36d0c019ae49782dfedb4b677be1e813ba8c0521da6955a54ee1d33be61aec13534a0fecbeb61994effba55c8a95046736ae27ba0ec6d7bd401835575730ec21198f3ba153e6b98554da012cbdc9fc1ef8aba33724cc67c7b0fb092bc0d20068b86669ba4583443ce7e32202a413778c39e1f0d0a58cd7ead416205739e9c3a919c06d6a64cd11a784d7c9ed4cec8d39b663d101e7ea1991b8b19c5db163c199631e4ec7799e8e82217a7667bd3bfd6fefcb67abf099c4bfd954528152ca886199c26258efb961fca3fd1f5daebb5403ee40cf59a8c86592e23003247320e2400b970e4934e9a1a3d766ba4daf4383322f1c5af271267f6f8ec72a39a5aa1c099c404329c8cb0be2c58af3e7be25cd65438dfa237955caee288edbf4e20ab47a80284f1a2527b1cb35456d64b779aa04bb2fc48bbf1e7e400453aa337eec36138050015c34dece588d614511bb35472e24f762c3e57869504fa801e9ea6be888f492c519e92fbf206410a3e1a0818678e5865392a7ecf9a489b312cdc5a28a062ada9fa9e8eb6ca661dbe729d7c20133948a0a949d78bc7efc501456ecac70e2363843e48e194f1b5ba69c1043c6abea67522978ee5dbb610c818b88af4a3fb4f8e23471dabae518ef77ef31eb889d44bf2c2597a4397481b6c674e8d4f9188ed0d6fbe1d526d8b848cf1746f7cc73018860686a8d8a017c9444d7979cdec315741a8931697c46e88441e0c1b5e359bb591cf58bf40931c534167cffa082e613065c249a192520492c57699dccc5f914de5dfc508639f641fee0f9c7587ed16fea79f861748a61a943ff8a2b4d0f053d630bfcdaa26f66334ce591f591bcbf7a248572a3cfe579791626826f483c1b5b26e44b6fcf82f9b639307278b8e1cee5b014a1fcb85287e4bedd7c491cd06e7fff208fca87a57a40fac6e251ec10b2947c521f2be65db240e183e4ea049de1efb7709067dde4b230e821a206790af7be6b26d65360e15af8c6bf311672f660325e6fd1b13891afcd45aa937dfbb53ac52d6ce60dc754f4b3e2f5f631f32aae82563f3b22dc2818f0e2dce2e54bc55ecfe6104b208a3a2736a58554d1e8db552a072dd2c9546b13aae3c978cb34e6ea731865cd5b5a3603418bdfbf804cdad202169fe6b96bf3ecc21e84c5a5d97d6275d815e1db2de7cfc326a7ea2087524b4e25f798df530f38640389a4c8a2bff316622e0010110797d4143f3c39b680fd4c2e6a758213867b54e2942802012dc8e08f32c0a9c7e9be2cf910ad59e0bb8d89357d7e2b8c0dd4d51087638105f9282e92a5c48717b1676f7b5c79d864f7a0092dad2721e8b5589ab7ed5c4dbfa56b3f88216d513df53015054b56e5d556a0887386ab10bb898ebc76abfe50eb3e182ca651b0e1d3d25ede5db389d292026b3186942ad277e639071d44d18088e41d3b71f500308a8786a487a180292799962abc71984bcd2006f70a36d1fcc03547f2eb1b856b9df1994b1324c1f15ba603e64f4973fce36d55be4aa6006a1e75a7ba9bd3a7c5964330b4371591b776fa8b0b00d63376e73d0b45db5707466096fbe75ab5d2b8f23ba7248a27d1bbcb8137104c84950f093bcd3ee1ef4a7d04e10db4ca6c5d55bc087611c0435c81895e61380b23558c203da84f5c68d73ebe5b01702ef2a5d1af1f0b64fb3f683e4ce1c87c25beed197877ccfb64a1c3cc3f3d69d5ad72b376566fb8c5fe889f01d1c468061ab8bc2974e3d3844aeadb635fc69179fbdc6d4fc69f582a6eae451e2ad26624f01c6faa0e652a818c9bc61409354b8352995df618793865c5fb866da9d66a4f45b993e11b6665ab63ccf939abfd1520ff0ed644351f663888d4394b669cf1eae207d687cb899a1d711ba76b3e066eadc40b177baad79b728412e081b076c62b147b2e4b5467a91d9bc381df984dd8fbdd7e9bf06db7b8e304acc7dd73f960ff24425ebfca37c99bf5066b75b1d26a50fed98bbcd3360469ea1c6ac91a6f02adf64756302fb1ad055b2ae6825b7507b0bc784217f00a2d0d4a8e4058c14ecf9fe15d19f812476e70ef89bff06ab94d8783e41e83d23d8a326688241b10dbba847da2f86a1eee32a31eca175610ceca00ebcdeaa150f1a9bc6b262070b88b29c38f72da4af78af9bb02d4654ea64a11e179951f01af2922cf3cdf7dc9b9ae8a8217f64e2e7cf0c03881a097cef9fd57308b61ab0abf64cd8f5226ff8af778526a1dae6d059a3b935f250b458304cea8040ee3622a267af4c3958d18780e1f81a373580202a5105386fbfedfbfd3f916471b64676915179e68905f2e0a46df909ed37e56eb5d2e32f42fdb3987fcdbc11a478f404310c77578e8b27ea9969806cb44721d000092e6bae8b77f037b394f1271e5b7ef562c55dcea02362d3d83a373d448728b0a05eeec7068a685a88c69362b77d5187079e242df4e5a7a0a951b6fd2fcd5caa842ecd01b69c34560f6e312182297e575c206d234663e27bbccf8ace304392f6fd833df7e9861fb552d9c3b343d12964f15215dd10420893e3983ef50b2a0e37c6fd5c1adc375857801d63b84641a9781aebeb6a92dca6e757fd6b17b6dc38177e24e4d1350b8e9135e7b8c7041302776aea83245f1cdaeb2cbb31eb88337316433c8ed480dbaae2ebaa8cfaa9ac7fadde8332dbdd9fb6fbec7b1e808170f06189dfbf0231726e96dc8732e1785a7ada1716c7aabf864a7ec8c62fe2e80847ece6360b19ce1bfd3f50d4e19263885f2a6d6e1541268e772533612add97f421704a879f332a174c8d61b2fbdad4be103a6dd03d6dcb6980a46afcdd2908f5f049da64fc4ec6a54b85b6df56ebfd86e1aa23fcc0421279c23ce150cd855431c1ce2f71138f32a95a4a000530a8d5ad3601625b6715a9da7f2e9da3f58a8db04fbf77294c111a25561cecab50e16f89d65b5862ef500e9732fbd0cbb00a55f70f4ba727c4f886efcfbac09e6afc132e93306862e37155ff8383848fc297464c8e3722f918982610131617f5d104bdae9d745b14f21f89c1d7ffe15d27e43ee7c8fdd7b0d04a6d9c07bbfc4f075ec424885833531ac311f97e528b3c1a78d37ca8146da159a25ebaa4252a96d917ed15f40224488d2e339b3e4a7659614fe694705ba53d8ff10636e0c2d0b7cd3ea07f3959f780695a8227bfecf55d74f52bb86a450da5756bfb531fd64c9309bdb5485c42505452be883770ca545f6071068925e1f54a7a1b1c01680befe728f186739e8df0e4d6d72328b2a24f922b2addbe092abce9e05837b6c5b05076175ea47f3e8a683cd71517d2d9ada7827294bf1784f05c3c38ba7340a2f6db8fa7a6d0a6526fb317e458169fb2f746b98938d2bc638500a1c0ed9b196f4e1f887da2859bc6cb5a6e59e5e9e8db2b2bc8c1f3c5f41c1b05256f89f03a1db3272185d979fafa3e379ec3ecca4371e4bdd26fbc845eb260a3362f29b7b9b676a60ad98f06c912bc168d0f58ef737f3b21e691238373de4492160b56f51727a96cffc81e2e84888aadbfb5d98829aa5c53864865ce1bbc913a48e81a9607dbf13594af23f7e0006197a908bb69052e48d98ebdac453c028ff2b6ee5f82c2aead65090e1195f1cdef8979de41d20f4fae854f2a1ec961c5e70d969dfe2893fc6e898af42e54b45bac3b7ebfd93d32a36158f759815d6f414fc7e48cb92c8619d9fe66398c89a14259ef5375142f64727f74448e2d120d92687d4de3f97a82c1e79ba0f23412f32ed72ec30840cc0fe2836698ae3d5be5512ee939c6c0d98a0553bddcecb31b00ebc2861689d0884ae0a0b25e6b41a380ab9d9c639776a2e3a4cf6bcc6d13232340443ac816fce969c674245deb50171169c46039b8bc513d9d9ab283877603ded24b887effae1ef8f6e6b75fc5ca8f391c791968c3792b894057a3b4a81daf092060cce0173b5ac45fa07303cee47ee45d8d6d4d445e369213088b6778c25d3156a75641209bdfbf3cc3a95e95c8cd608a7e52559c4bb950b3808dfa182c884bbac048a3f0271f7cfac6010f67037f6f740688a5fc9e372847f92e6d4ec40edcd26f2f1680ee522357ad80b37d584737fd9e59ad1f6e5407c8eda114a49a40cfeca542146075abafd3442cfaee185ce1cf8c3bfd20ec71bc3d8953aeaa00d654c4f7be91f55abbbf344646927f7afaf5f596f965310242e6a0a9f803572e5b1614bc7940656033809f6b6b9ba93367d9fedf2b33a527d6c87f6e7f773a1de863d2efd9804422d30d5171a7cb89fa38372062b61466974abdc1a08ae779ab8a10f0a2d4d27dc0fdfee1bac23377d15a78f086bd309bfc1b097c12a5107c83fd28b21ef753db1af73df75361f851047b10b292b6687809464d5538bbe5931214b03c58a47fc9ad8e8d57adb67167b8f62f25e5194afcb028ca966ce4a5a5ec91ccbc3faa0aa9ac0878794acc4847975f7bd70d80e1048fa783120b3f91f1c5cfe53d0b798f3223660762456dd4ac4cbd2b9be27923ccca05a67cbcaf4443011003bdc0d849920702eb8809819fb4c88e01b2f8bf305c1ba2d1183db3095e703d00f0d700f14517b3e3d507014bd0188b4d3626602862216c3cefc99141b7f7505d8f596871ac758913d4729b77d0ea1ce9e721434b066b58a4b3f671b45cec742d9140ac6f5750eb93529d25de223ff9f095269d629c125341ab6691ee892881369ccd32a6094893299ef20268fed3c18930feef8e14f0e87de7bb62b2ce91bab7fc465cfd51dca2127dcca97655af1ac8924c2d457cf8838d3f85f5a993d6d18d4042ff97014d946b4c609cdcafa5f4e485cc2511055c10fe85ebd28c17eda38c61df5346a77c5e47dc32aa95b7385158a255d418558f03073458f0ab102853a88bb06dce654ed8e340acc38378f1abaa6935e9827fbafb7f38d103e982448625bdc105f8312e51f367bcc807c6c062996db679f0f60682a2aec80816fada95351f1003ec03591f930f0f367529cb3e2534d7a4daf586273686795e70c6050b66957a50c2bb42b4490b6a9a9201c9b7d40918474682ebc03c82caec5d2c431f3789d5a910c52cc1fd2cf76ebcf82f9fcbd0400cacd779d0f2fb1c99c180d758261abbd419d2f3a410b5b70e59f5f3053a8ebc349271c30514be0b0f88e5b2ba45208ac9736bc3eae5ebb5cc64e07786ee78470db02d4e7b57e1cf1dd6435aa21bb213987090191c8c915a8e1bc8c32334768f2b6718d8215202cbda63f79107d35c4ef00a4469afdaaab3e3f581418a6851ea971db6687c7ea4192e8d6c21d81ab764f2dfd89e1bc82553d4fc8f0f75aeab7b987f3d6b24f9c27abb53f96df02cebffecd27ef5b24bc1522479793fb0eb1784ba633d7c46e47a3cad922451390ba923d2e646c6d5d2e7e60370957c835b412e34a67778c7e29c5fd1f3ea9747d3e30c248293c49f164787c4de9f0e72ddfb47df5d7f782c0f6c54fff9bbf932a715c6e57a89d4eddfb8f172daa6b524e25edbf6bd9386ba56099b404f7940ba479cae2ecaf3a281ed87225e26e08d591a628f0fbcdaabbce3bf3921af8bcafcd599898fc15c9a9164d578c9b84de00681f31d396b64f4089e274677768dc2da34e0d5057fce3db75173a84f59b4583b2531d6d262ebeca989486c3cfa9edd5c8ef70c17cdbaf6eded334dd4f8ce9e4ab8b136f2ab61c860008451e066a089c7524b77167c2f6dce51365e0c02d1ba410d585f19f3564ddd8e3b9f338f43f053df8550ce9c2aa16ffc863dda073b3f31c8b64b41d8119f932514d47198947656a8cfc086f659f928635bfdb0e4ea8ae1552b278da61fb73423068abff245cf2af0f2bfaa5950a95a0dc9a335b7dd01855407cd8df089684c11aa4a1d51fdf838e71829c275df5a3a358aec2c9e74742a607d42e3e69392f248b9d9d71f3f17f29c8cd160c94f8f5cbb15d6074ddedb7da540b8022218c3e1bbb7d83757e3b6ac22d0695aa3d7b4214a90eb3530eec213fd6e56237d9ef33977c54e832d1915cf6b211ae65b0c93e5c32d6543f14180ec47cd4957fcd292b626d141604b36b862c1f0695dabe65a365bf7452e0139b016579bfe48540a3d28fffac5bf8bf362e3654a0ce99bfe9e4d90554c5d38573cbe0fdd175818fbd493965a51ed51d6f7844aa39c22c565c13597d881eaa5ea1753033e13d14ea4cde1de010d0ab60f6d0c289f146e709f211a59114ce3e94a9f1e6dc86adf5341964c2826b409666630343c9cc9c68fb9b9247c2ebcf6e3e81501add6ff4637fd959e4620a8bdccc11c0786ae64c22286242af7fe090f5e5a000004c392e327faa9636b9152b211fc9559d31c0a038e57792aa37426094b6f3e19b03d4a2aa8cbc2a52ac26949dc8939a0a708afb68a4cdf0c08550c536f38af7f14a6da2aa5bba980321b647cc79cca797c25d5b2a9ae50538f65a66f17008e04c43169d4636f4426c1980b79643d734f309b12f533152ba634f0894e882404eff7d8186bfa2be173244d98e98e9a7e27c8d10c0d7a287139868fcf385b78a1b876352b91641d05e74b68979b96eac1dd0437bfffd171929c7e9c78ebe0f0328f335810191d0ad5e034a087cc03360ffba4ec6822e17e61320415e3ff4b8b924ac2688603a7cf26f1e60440797bb726af31cb6deec2f8cfa4f4c24dbd9b47f85f4ec9b453bcc68c3cfc67858ab6297a3e0cf60d32466389ae315eb6091b348b017e06f691e1a8f8e20d9844a702c5abe6d983d7ecee2d48efbf279b7161994e1d246c7726ad933610c8c85826339fa59facf50643b6a127e4f84439d944279c15529b67cc56d0f1aceb9708bbc789acbd2e6444c745462c431af779534d83bf8ac648b688dc2a61fa381769dfdefd417f388c18aa35b4e09c91874bc51dd6c6b1a7be467c8a3b9a1136d79c1935c227a9fd6a8159fae3b2ec33999b5cc79ed014b197ec64bbeb666b9026ac01ef9bbb753386d1bc122c202712606b88d7c4a0dedf5b40fa1f52b04696583a46ed20d3d350f00f59da686e985473267693b18feedbd45c281f6a7e60127e4bb3a37d2344969d0c60af2fdb16e3bcc1f498b7e33aa0abe6c363083539af85b9c9ff33363c22c5388422ddfe3ca2016441fe23d97e63c86bf0025d66247e07dd069729db077cdf61be3643056738bda24796ba7f711e7d5b2e498d51588dc04438bba66eea615ff3f749feda5f2a32f89d51c818535c6eb51cd183096b519d0f8082e9f2a0b7cac876a3c43ca38b9b8332e4f5eb179f1b0c51241116d35c97f80a573e59565e73bd5a1bbb0747194933356ddc23be525d9433a5e2294c695cc42111976ba52a4fc9d541d42ac173fc348d3b61248f34ea52869dbbaa7951c8d46738961f4d34f3b27da66d121c19e76296000ce86006147ed364a426e0c5307a830de010247f96a8b589ffe38e0934097c8abdf79307d0e1eca821b23300ced525076013debeeb3e657387ccf4c718d255dfe15580f78e25866e91a0f47f6caaa98b46f144a820d7a8ebb9fe33c575323d129c51e19851f2e7780f0bb52d9bc27fc8a9f31038a1a4aeba04be677d736f8797fb1c6d784ee1a07751931d0401e4fcd2c1857759f33514a95c1c588a3c40cd31431afcc1c0f0a90cb02ce8808eeb7753a025f2316cbf3271569e55bfba1ce7b95dee48e81908cbc10a39b5ae96da10afdec8701cd427c0bcac63e157d4f3e4d42d23ac8439b94427146088c1ecfaac69a0bab0cde3b3dfa768260feacccdae95809320cde111fbb60957fd7eea7427130fb3ead0a2d8f1bdb8ab9d93e2e841b81f491662807bce5e455de3036933c1d35be19472913611c5ebb99cadd706fde6e9c13e6f000a7eeb2250405efc7cacc888deff6523ef7fc22645823f067000edde51e11989f6cfdd4ff09ef8eab8ab1f37f3559f7834a77be2cf53aa308ce1db2a8e1dc0871efed2d7e6f093a39069b684ec17b1d80d487eecba7c45459c99bf7ee188c3abfe220d78f01f3486dce5eddd78c2f752a8cfe13715e8acc7ca521c53ce85285f9c8c969e1f18dbb4a85894909c19415da2177ac523ecd42943132f2f4b7a37d0fdc8312b4f9ef4394214a467e23f4188ebe94821b84dbe4821fa7ba8553b958eadcc7d385bc56fcb7037196996a8f1f5bafad443a4ad7b7c593c5c1edd9a47da852cc127491266bf51840cc6cd8187d6bd76ff135f65a99d091b3d964f568bb98a1588d2429ae5141c0568eb1810098d0c386d2b9046118c4ebbb6f350f8416ff8db13ea8f0e1042acc55587ba3ee3f3674078feee1c4be25945be38e142d44a2d70020ed3f13b08a4ba710e6afebfb8d1f268e1285608489e6bcc69616b07b106c2c5fdd29f6c4774151b362ae6a62851c0a0cdde59cbc860e1635bdce96050a336404a5202130eee38a7615be3171b07409919de1df88d97a81a081d40e710f630fec7652d59e48109b2f9b148dd4ed333cd3365d09de6665f915283d0a35f78db2c88b17f6d50c7735c432445aad9dc9d69db336b1b22410867fe2a639fb181296f827d80e05c7435e077b1fcc8d4442c165f004856d79ca31005fa67f8a603ab269677f043cffffff31f19a057d5fb78945f0ea7f180a46d0665af1e00c314e91c2014ade08daeaab2f72c846a4f631bf7e0c5a377705bf5a0d04b3437e224f987e112d8e1bab4632a421490723ee931cdce4668b507fbc603690b3e8cbe272e7a73a7deb9aa2826170483b66ab057e4c4064a1d9fa2f411125c681cb96e89bbedb4176220cd39c6d89524a17184e15f4c583369d780e8987a00755dec84a0b2de06eb2d4a4973a3f7722013c9cc99d67d9e894ff2aff7e655df0dffb34e1d5a22556fd4e87d0cb732b94dac75546b0b2189f2626dd86267e7121626fe0754a60531b38f5a9910a1a7f897f676e28dfd5e805cc995e8cab1fe67ab402e2dfb95d132ebf700ea1fbbb221a987be44fbcd3a0525438d4e6931dcf516b888f544378871b477f68d1d4ca99caba6b034bc91a9257e0466d8ad291e956a63aac7e144c25092e02fb1e91ead0fc1aa4546229748dfef52237b00c1e8ae67631ed0d5d1f85e620d119883efff5efebb51701f04b1d3c1212a28168e8d9b1733ed95598864c862d0e39910903a5e55818a59e3cb26244988dec4830fceff37028fc18ca6fd393bd3034b2e2707e4926bb801b9ba364988f940191df01a43261a0ef7e549ab72288393af5ff23fb4399c337b58b2e474fa9f66ed1540c634d0df9758c2983ce064ffc28e5a9736377c5cd6fbe5143b14cb32cc82578628fada82c95aae15b3cbc940af180c33a4414238aebec21b6034b2f6eb4a52cf8e32f20a08cafe35062837433e503c7098ab6e4dae6975eb68d9fee899e2658550aee50cc8d2c2fae7ce034fddd0ce6108d44e8f0496d3a763d87065194fa819fa4fcd73ba2ded3a9b775b7a1e2a7f7cf5bd644d3f9174b2b0217dd33ce9fd7b2166c282dc8e8a93e3e2c44aa1cd5462f7030892cd7ac92e8f390be8b36cd40ccb0431d347200a9ee4c776d3e2af5934b74c2716c5bd9d2330de01a900f7264cb544fe49938afbc47b74078454663d74b40d6daf291e8a948fce84099ec4fa8b46c1d52409021bbb81f841b6d185472de9fb7782f642e6d43b40c75c4e713e6ca6d764d6b1c53a7375e6b1893f00b41930a6b55f795f0f04b96632796a82bd66c5347334a65b0d2108498d295f56092991f0f2776a9af2aacdfa782a358c3d7eddb04d9cfb7bb0489ac6720a846ebaf8e5a9b535d27beda2701d0d139ef8bad80c1ab09a6111de1ef0cc7a143b1fa36882ce0a76c67445072f8f5e5ee4c29bd511af6ce2e8eb295cb92d3cc6bbb25ec4e244de48d47faf93f03514cb72eef4f964f57cb53367708f16697bd3fbedd6abda97c5bb160df6f2be75738f3d2fca615b70bac47c65767082d3c1051744aceca4c8b1f18045f7def21373e948ba9b43ef45a5c1aed96f3a1f782f5a29d88245c4e5b376cc373e0333ab8e95902f31f62a2fc3219e2a0e3ad3e0d19b2b9e1ada56e0241f2ae60aeb7ef92b335c65c6369cab9bd73603442b7295aae884b960121f183bbc3e4eddbfff16198b85c543ba98f0e3c983e2625d9226a9cb1db31633930afe089dab92569ffd9cc55272a1f4af3c03fb0403116fc8612637db22b1b5a959dca3c1f38a77be9ae05fab8bff6baadafd2044c8d1639dc8ecb4999cdf78afd7f9b376c7cb5b91b314e21fc74be39d481b42fea433397e8aba5bfbae592e493aaf6e8dc1cedb4d49f7c54a398fa905ce0d04314fb1d32535eef64a2e27d3129b0ca68e703bd188c78ab79f38ebd7bf542288b95f81d8d2b5537bb32be976ced391017d320c5a3644143f97067d6c6a5ca9446701e8487c4dbcdfdf49c699cd72fa882e90f4e089cf2b08111f4e6ef014a2b843e249d83834616e99dc3386b0ef08e7eb7718fa15d6ea1b919447342acd53652ec6569c693e85e2b7ce87584291a907deb5feb57c13d2cc6bee369b48467e932e84b3d48aeea3bd998578290f107eb09e89bca4c05e8fd46a192ab00e530c0728095eddcbbb86a1352d50d71839ed3515c4d1ee41c6263d6143508aad83d99d6173f6a9e982f3aa5b6d83acf2ca9acb80f6e2053ac3f8910a1ea04e0eb4d64071ecd469f720e38881e7952ae117a3c15d271b44d6b81ca32699629bdab0a36939370156c38f6cbea5cbf532b5a06b6c32c07e7eadc6d83d1f24dec591bafe397282b9de26ffad77eada1ee44fb1250ee0fa540087f93962064653a312783f79633ffde244a003879a5008c4a066cf6b45d94c402765e56f68747ef0c19a4fc3e414dee11d606c140b0c63010710c9e409738840b4531a4889929a77d03efe47c780565635e0bce8fd88b83a217745b1a844757aeb49581a9f96c46f6c29549196afc9f7307115251b1dc8844cb3a2415e2e63affc61745c54aeb4462189b141f7723b89d06bec18bc1c997ed6de39221780de04f919f8a56ff0144de17d942a92809c7a45437a39307693d0b797e5427ecc8df6bccbf09aa32586b9c4d880319cef04afbd03c84ac160b39fc9ebd3020a0cb5258f1980b9145862ffec0afbbd85c1505c44456666e6a1c185b77ba04954f3fd6da6d5e64a65b3f74d97d925ef84dab9e5dd5fa9d83c17a6c834ac50ef22ce8e8f855b7fe6578851f2f7589298fce7b6ff8bfcb47dc609956effc9ed2a91f0ed256de754b365ae794dd4318b8e3ff275009c715e5fcb14c296364f1c701fc496cb2e8dbc789386c1d80bd20024c3c14f6b1ff6a1b471f10da184b11df3727dac4f6d60786869b6ddd18ae528b0562fbb024bc9f03794dd91daf35adb97182b94a8e975d4755abd896429d35e061a70d52cd9cbc894b94275c75cf1843955083b824ba0c5f00f8558e996fdc3520685cd0169d2859a07474d3fb63f293c297d282b8177b703de032f0c44379f2fbe913578018c4fd74e30dc428df7f42d824ba99d3e99fdee3ea5f6d784fc6fd1877777efffc9745287b716c95e899591357a953880ed3cfed633423bc9c32b5a2a442a6e296de1c0864f6d4fe15bf46fb8abd371d645e836779135b0a2d912db378a1d17d29b4d12ab13077e394974493d3f9db26b94d3e386e388038d51abf542b45ccab6d2ab0fecc1d829ec458454eda7ce5c0da6f39f2d4b471e550d9da3a8be6efadd05a4a587ee8287e004dc48109c88c5060a607f56a18eb7b6d69da0d1c752115f0f64bd81cbd390da6dd6b736d5ec6e644f1265fa13b8e10b9a33ac350c279510ba018bfaee706503bb2e98cad6df4161960a541e50ebda6a905744e50d422ed53382172ec6ca8adef2666efff72f038edf0256195fa849ec2e2f7b55108f94afed4890792af0c8eca0e484fc1241bb84e719c27c14398796bfefe5a70990164b21e60485b89362b414b0af6fdd42fe3ff0e8daf257f977ef28a0bc61d34be0e0e4acd86546f42580faac6308e488afb384358730c7cf48e860d85368667380fe29734c281c0c1134027abf0d4d30aab17835d7fa91ed8e36f09072972eff20996c3a55ab58fc88898f4ad4401a7844a704678a0e4b222835e972f0bf6749d5f6329979fb2574b66378be17262a5c099642458fc02660db5178deb65888bf2fd228f8173ab6015d1cc232dee8a3938282797ff3f604016cb18fe8dcd8b2807ea1045db1b905624b57ac5e03a70884d55cb52b64c876eedd61815bbc8bafe4bcafef7fe5e2be9c5674ce15a2f82b01c83baccbec2226dc8df45a55daf74ee283018b083a72cf8b6cba8c19053c3f927f0e1a60d856249423073789144e36b97c92d1fc840b027504a5258682c11f72c10108e5ff11b07984f4d177bf6871f783e64a8b4377b76a456e931024ec6200ea341d1b5a7cc433e1d23f1a826d193e613baeddaceea36096a388ba7d9725e3fff188c8d1da9354d26e5e5590f39884f47b4d709ac5023e0a1fac7035cd4f0c44c3986ade5503093be1e2de558e1a25587f7aa4cbb916bdea3dbd753a74bd5c42150e248c575d5701157e3b7da428e18cf204643bc1ca71b7d68ccbed8a8c847edf89564052eabd51ff199a0ff32ed0fac02c6f58c844cef952da00e349d9efd58687fa0f7e2f4e248af92194321ceeb118b68f477c32798fb60615958f13e144960fd62e432f600df9b7efdff177ec1413fd38f09ff227f7f5edcca2bd53b59c6a543822290ed48cea5815ec4319453844f9a5c2c429a0373aad39e4d7f4530042dd1f659d0cfb642bb712bb803d6c7749227b61a38ca29de70907409ede250a7f3ffc3614c679a9a5b48623d8c533914943661c4a9d712c73cdc7a13340e177abb3dec26798370cce7ee98a68c91953ae2b35c28f6e49ce97700e0d6e23bcf5d343f13a249ebdf31a8fbd615fe00b089e52adddb3b502c7b4514ce00d3bf8ae05fcff41a88f57e58fed35bc10b504c5aaaeaf2964bce6ad47c4ceac958e2d7619daef03eac2cd38480c76c010b96deb31a0a90b7597c2426588d8b36d41fcfb92a94599a401e5bf6ef6e93c8d42f895495bc3a722553f323113e0f27d41b457242a4a970a6868ee979ba37156168c1cf01a1bdc7c8904d6638f275f30be45a2ebae1175d7f2c736cc51ce6e1572fc52fcb4176526df0424c07e4b291945fa8020eb444fc820f9496046281ceea81ff6de77bc609aa49920db6419375ec11d3b6069db9d65d3bfceb062791e1de6b5b0de394c156693af9013338eb85fe09f2e762416a7d4cc8812b26478eaa05aca02b060d776580c724ef7411c01090387a08a3fc1a0e7498c92ea7147fb54dd2c066ec4f29ffa4997f7c59928e53bddc3479c7a3cd79fcbac364abde96834422bbdb62db7a1f16ee64c867989f68727069f7abc3059f72fe57af35a0ea8e5fdeaa73c7055a618c04bcb15bb19bdfe31e324f9baeb434b1756150c4543725015a1769045368ed00e109889842cd187404c7dfc2c58bf728527f9a4103739110b7d72434dce2714953c2bf52c1e91e46ed3ac456208fbc7fec7073700333f826e1e6277fc2105f1d346c23c034fb73e0f2228b31174c1490be07426e67d97fdb9ce4ad6379a8dbb50bc44cee0bfb996d82c6126ab9c6437760cdef4c1c5ca8a75adcfa44f0a85929b67f93b316d7eab32dc3d7a8a858679fff81d51cd0be5c91751fed471dc1da02080632ef38836d868d71fef54dd213e03c61dbaca677302bd17de413f7145bcd7c06268f26fa93f8b9caeeabfb9968c5aa3dca9e967e6a3512e13d4431ff4cb0ccc5bd4fe428da792b26201f9fea8c7985a36eb5c6a1b473198cbd71532bb260b378f586c8f4775daf5cfe9cef6d8babdc638e340a5a14d591688987e9bb28bbc2c50955cb3cec0ce94f7be323ee4368127808d6a597a4c1715ae9ea11f2ace4a2c8e87ac87cf29012fa62030acd907c24ca124d0bc606e627355dec598c634bc73e0946835e25beae8a2f0df0ecf9736b050ddcf0d43fab16050a8be5f7eec9eb37bea1b31d9bdf12f101e091eabf6312e389579b4784896204628b6629d957aa8947f872d21ef12e7b18e823b85bdbaf4e01605f721952e38e82667465e76b6620794ffce5229a691418791ae6865b9afe58199dd26b22773f7714d210298d367f5d53c3351bc8ec39715a3cfecd2eb5d2fade0a77717fcb1c82c24323b00ff1295bc90b68651f2d26ab7ee58047125f3e757c86a8fdcbf97e0b2972aaa20c39b99bbe8e9b7cd23dd91d0e1b7ebd06fa444a6fdc48060d36e79037df6e3c21d679d899fa37b5dc8bc8ff082ecae014461a996ef5ecd46be64706ae98b755037c4ada5361c632b9a3ce46fa2f9c04e996dcb71ac9156786416483c77b5ce5a1137a5da0e4688a6edb038d9bbf67bb73cdc7205aff68cffd1ab476197e340cf666ab77a1b1a8923c1bb6ba3d198a425592d4925c9ffe243f0843f870f2a510ec8fb5e23d88ee2c59836dc2bffb526882ef7e140e6e813b6c2f8f6ffd991e2ee75cee81c74ab236f349d920f6d42011d83e0525169005aaf1d4455c2b573323d8705b22339a0165b07b46b7f7947874da39dd3069f06b056fa7f75d01ed0545cbb0f347810c743980b803bae82ecce19c49d977ee963399dd13b86e168f3f27824b87c9c81c67ec68d0361b55875ff0ec4f726b286e6474a7837290b921e08156262c4d96d7e506dda7802e46c2962a6cebdfd4a3c8b6ed92c7c078373211b5bdffcd7a482cb59f32a2cea0289c176767c72d94a9f643b8cd29e7627321691f8dfa83011fc2ae3948a63411700df11cf5eb5e35b0ec6afcffe959a2e4f6493e654e07a6ef77ddf8cb324a7c27e77b545ab293db23db9e220a066adb4f455bba5207da94d4515c0bdd1a57ac844a31b3502890e71d599968cf5ba96ef0f9ab15cb007138829859a3873ebd2fc09450cdfef17c57abcc10fa54ca97bf96fd27910097715eb79bcb275320c95b37e870dac309a2d275b6be5f7e881db80f6416268d00c42a1ec405c3c07b0434084a9ccd5905d6b6548beeae1529e34bcb845fc5bda99de5aa5b3913ae7b0a4eeb4298bbfa9f4adf4e3a0b80907ecc72de1cb1490323d574d00baf5f808de13ad777fb3d6f50c5e4ad0d09ad4b58f50e2fd0321a46bd1fd1829a1071f66259130937854f8e81c418f2b7feb92263cc45d7dcfbb7d65fbe3a6781543b681e9d93b527663e1416f9226a6a5f715e903aba6cffb6ee4956b1c07547cb694f6d2f2c1a35383b49144d8ac4f4df6aa4fdf31d75166a51f51e9163df8d78725b2f90cf41d90e56d2696e4120dae5033d27ee74298423347ca88d8f109acc42634845332f3d3cddf81aafff19e7bd290ce26225c5d7acc53082a44cd970c240d8cb9cde3b3d10c0137a2b0f3544b5bcce53f7919fa66ddaf77b58bd49cc8349205f79c45e62fde08df7c07d19eb576bdab35c479a9c14c41ee6048dec124ab4bdc3baa9be1b448933bf6bcf6a57f73d4fb928df4fdf41e2c0f7be61ee3cb89bc741022cdf695f1de1cd74500dc3c62fd07122b3d8d0b3a5e04e206f6e77332bdce3654a024c613089589ce4374c853e784f2fec5fe64bfa4a3411a66f25877d66ae57372da436223d4e8b5731670de4f4fed289930e6c2bad41b6ab7ef2c42dff672ff4c8d292669df0f0a1040b9841ab8035090e8b1474056a335f7b55f5fbd82ce4c55b19f1515ccc702cda83aa89f2bd85b7c0f0d6d3a423dbe015035881688677871897409270668143ffcc2ae5371d0d30ccf01c53ee2ce6f92d4863373562c3596cc5e24731807235c9d9c55205f072b557f9c07c50a217385b58c94179bf4a979e82f7981a371f19f7755b5fc890b7d27933044286ff27b0c768e5a0cb97d1dbf1f94625dd1f806a0f2a49560da661a3788a27b06c2cbbfd1ec162b18ed8fbc0b3e34d9d6407b68727974804470476407041ac8690b91f8d742470937f95b76a0031d0b6a15e4bc5364101001840c87a7d4de5f4c673e1f5a079d6eaa677d5885383578f45148f94a720b2429fc060dc4e0cb3911e6c84e662a93b0a8524c9f854d50baae64a2e7b93e6c70dd2f5583ee2934cf8b8f7c8899ccb5a514d5a3e554ee974314abf231524f0362563ec297cbd6ee11a9b84cfbd9ed17fc53cefe53b39099c7b5e454cc4cb8416232475bb8fea307f8a6a8c47976c97374892482832e97fb9dc763f516d200a4faaa48e0d649f36d5ca5fd8351b305e432071f4fc1bea92038a3546f4fee9d6ab67df41583f4af8628a7a26a112dfa207b83966d8f9f22e8f143363f83235e7866f9226314f05ce879b164cbe3cbf8afc4779944a23c6cac44f187e5dbb001886a1d0722d032630fa6a9d862660ef12215800bb2539e982924a95825470f3593badcb297771e21236880bd6a90d491f87389c78310b8dea553085eb57425420dde8718d6d1518d41ade96fc958bd9cf679641d825ecca1f3323932f8c5cfa1ff1e54ce399a074c1f025dfa9ab9ec0ec414e0090db0aa4d893bb16eb8ed471ef84accabdae04c1b122f2d98651e291e059f1d725ea4e0bd9338e58edacf767c17c40da97a0a7c5fc8aa0f27bcc34736a563aad8d603e1bffd60b11f335d7d77e02fde20ec5d8c0d7d73927e04fb8d54e51f9c47750f82df2c39bbd028467c36b5d521a954f7d2f959fdd4d1110592dcb2337b2ab7fce456bf5291c8e4b794de7e5f2aa47c1a4b81edf38914a8896de5dd3fef247d272a8355522e5d91b498b99e3e5b0b31b4e8f20f5ca6c4a0688d61e32d0b20efeaf3c158e98b06b1ba4cc246b4cc29857a8aa0c52c892069d9232dd6d9f3049e94878858fe623e48d4bf495d1d58464f86ee0c645f2d8b65d69550e870c0480cc510767c0a14a97415813ef198813fdfed495e69ae887cd391f8c69355e0535692dbfec8907a0760e59a5efe1736be0e1ac3ed3f2b636ed8ee2a2f84d6344a9c155f10127795d5a0bd4fff633bdd6717f4ddd5f971bc144de61b4343ae06b19570c2501e38ae1e33d9c337b72f71d565e5e6cb3298ab5356ab21c1a4c5ea51c3cb382b2f5ea2ab83f98dca3772170487d69ddb6a137f0778e669e84c8d09bfb4f7c44048f2c849821556a23b07a89e11f0969d3281312bff503de8c1d3a5c2d58c3dd3c9fbf662f33d73732da7fa45fa7c101f949d4686c95151c3d580cb57778752948d70a34be719fdcffcfb913ac2606bb44e65dc285ad6bfe328141f6925f646cc1d3788407b7130c3ccf5aa667f061efd65172e419474d98daac7d70dbcff2a0cc4cb4cfafd012bc16ec28634ad21b8cde26a9726663f9744b659039163d49a9eaaddf5682a7923d378c9e1d57f0bad6a8dccd4f6e259d7052b2c5da6976fb6b88a8d520f816fc6b07c8a1d47c152e588b538a2d89f810f9b5db69c8af516653ab1df462d4b10ca6b4bfb97f085f5b8b0309ae11223637fc3ef08e795650aa0cee2c98339cf70baf4606b12b5a43060ae88e08cb6401aebbb47a9cd1ae201b9236129c402c42d5c3af8a45a964faf5967b555a0d648f157f347f30dd02768c4e20797e1fb45e55830fc09fdc686a449f1cfcbfc72a02155b21d2b87d6f114ed795855983813ac112b1c60223b8d335083f2b409f33137362082e70e9d9c8c1325daa18314936bebe24c7eea638b17c2cb89c38e57408a32ec835b96cfa4253b354557c95251218bdc49349f56cb5826cedb0b04a1e829f4beb28d7277c727202c35299ec73d968fb2266ed295ede1a2bbf218fa436a0073d147a06f44a3603f4ff281e86b43002f15c327af87420dca6e17e29c10cc92e7649148927a2f053afd3675f51df2357e6f52fd63ecfaff9fa4c5ce090b46a490b9703ef888462b7a67606c9c40f71d7a3f7ac22f94cfc32bad3750c7486e2dbe5d0ed8ca9ebbd5b33c85c1181e5408508c296b5912784e13063d1539698db28534a5e9ef71b867f53962ebb6684ad1f21d11475b9bf8948b876bce81f8b2e20ff93db5e92e482aec9d5f06ebfbab39fad351f384b7ce4aee1a5ace9b14b967249dcfd2a92394a55d783de70f7907b551a65f6918d27bb3854d0a1e519f16f9284270bf6d94073689588bbc13aa30af3cc0b647c15a50e1ef772e8f98e9d973e6fe41172b454cae01a9fea1190898f5714467810853a5d00a0e52f56123b143947f8e3c8747ab44385721d52fc6743bf82a35bc9d03905eb153082f2932afd2fd52585d7adc52177c198b80e9527d17b0a94bd0e3a4bb2431c4a695a81633de1d1ab8db3cc81aab71e2f4fe1389b59971443fb8e3cd9278877cb3670c96095a1f4e910bb4198ae8d95ed96f5a41d9a53603ce9c78fc3673319b611de8e3d1d3d927e7886cf68651f49fb81b03bed878f0a6611bf781d6abbc47684c931dfd61e3ebeb45140d62f36154a66092e57bfc51e2b506fb8674e3f462b6e56d8a45e0b5b629f01eec439391d244a42572d66c0ea4a20f1e1b977be5d586c78f80c4b454dd7da6a585ce0f34f02076440457af44d576c1a62104fe75808c85070f3cf0b5219a2602c7c6087391fd596a00b55641594b5613ba17ea6acfc511736059bab9c90621529c5911243e787fe5360eaec24c6b44260f774d295bffa246df9e1ae928f4908d14d7cf9ecd1d3911acb2d9cdcce8496ca18c4ba7271c390786a92400a432a1240e8d3cc3ca8b31f8e0940fd39e9d9c71d6ded178c1580982f155f8a308683e6885076425e3eb90bf4a82ac07b2b82a055e71bfd61d8f613ad9b95c6639dd503b3b4787eb4cd0d9f3885d94134cc0dcbe16dddcaaab50ec68cc891f0f1f033d2de3f95443e1716a0c43795f908a360e2fa9c6a80a7da829d392d4ddd551247fee413cef0d9a090ec2e61ed6e08da4a718a013fc1d8b190e769b03b73fc631069592137584260cd3419f185d64453d8d1a47b73e77a3e66a80bf893bd53e7b97b5f0fdaaca1c7b7164738bc6a2db1d72d42407ba61308a6297a86548b397cbb55bad02e478d3976db4821e9919ddcaeafba898f038845cb372f3a0c64368ec7cb59d9e8c6cd6e5ebb4dfc6d33c1b4d82d06b259c55ae3183e248f91c6349e7ec33527d82931898bab098959a4c33ec7918205924e17de73bcec55756f61ab09139ab7ed49622c7b0bc4ca84f7332bdf7ec55e81b15e4db7ad7b38cef87d1f5b1aec0bc25b1380d254f2f256adbd2d691629cbef25541d2405544ebb76e86064d7bdcc9bebef3593378a2a15ea22f4c7d3091425ffb2ec35d01c310d1f326b0961e68a60d0c99fda625f462e063ad930ef5523ae8ba1487150f6e4588c6a172c66d98617e65754a70f741f98d95abf641ac8f81fab40e39c1a08ab3d6031319f08c0642a72cd69279f28fe7dd304741deafe693584e7f8d1a49b0a3e361371c3bcb63de090ece69d3dd02a4a5b0b68c6bbfa5b760bf577567e0882f05c520e5bbf7ddd5707031450fbd50afc7d196b91e1dea28716674689636530cd7d6b5c1fa32d47a92f8045257a3d8de76abe5b4b197528ef10c7dbdc47df4755cadc9b2abb93945fbbe7fa9d0e9afb69060f3d48e4dc6384c19ed2ade685882bce7d6b3b12adf56e50acf3dc52c00d0c93b9d56421bfb8f3d0b08238c84a5dc1a8ffd45001b9be56dd26f1b278dc9be2a6e67f7818a475fd6112d8e4f8c97f911d26be91c48745f355dc1f365f6db05bfad76ecb29d15df61fc22d59f24ca880590ff79b993edcebd31e66c615df3c45222b3ab0660578518ba7211f41445a89859da21ef501908e7bd801525e885a6573cbe483d67c181f7e0d0127072881c2396824e0213b23c8bfd8b71bfb32ac808920416d802eb3e7ed4a8bc0f48cda25083b6c9ee168f549a34aa55e049e1dbcc5524566066d95bb0df825cce804d0ec034a5e11e42ab96a89769954fcf268df11e356d8947941c0bde784c93b52494ccb1384dd7b1ffc34e81ea209481272b5c37bf1a8caa04b3bb29d88ae14f0ffde78027912647a33f929d2ac43480324b7d93e21e7029fc74200aab65cfb6299e36c0e72dff56ac4ce953f2ff2ca60442541b3ae2e16d10902572720d86d58f53060158491a796ccd4d009aee4929771d85cf5efccaaaae378a11a83b0aa8ae43b8011a8320eae697b29f5458b7888d185ec89dd5dc840ac236806a544e0c64b2cc5bf72183d70b15b89b09ac13ecafc08e7bc0bb07bca8fd588c19e0dcc5e19be8a0effe07a61645c69d20b9eb0ece882dce50381f789b5effdccf80066480327c74824ac13a6b633b4bf3be2f4ae7bd74794a9861ed616868cc1db127ee9464b541e23a508cf2d1b9779e4f6e1f5043209ddf0c279923a68271da7b4820733ef9f43c35655d243afb7a29d1cff62d121d7a0e2f3cf9ca33cf4fb6db239fc9700dc8fad9d5336f829ca1cc2b2185d171e86f002f3d0039103a453b3ef6561a74f1d6ac4a882ff5beb34d15d17fb087fd57d9dbdabe5671ac16ecf02f47cdc41e7fca21fdd3902363722ce460692b8b65397d4c2cbca89fa2362232b88adf050b84ebb90e4cc7bf5135437a811c6d9073e2d68e7529cc9a19d73ddb404e784477413d5c3f1470f1a96deb361fc3034701a70998d0d4d40ed9adad6681197bf896e85530d8066955d4cbb26112e0bab103b0f67d813cbbee96052812c8a2599a62d01bbc3d937b85b4f5e3c2581d264154baa14297faab450d52668569f1456c82c7a5d9a344c282549feda051986dec9dac72c817f23c93600fe55c984d9867a628c95fd4592517ae17c262803f70943ce71d124e6b84bce67b50f4f790009afe8df51fd17684cb4cda9fc70fca138c8fd882344713903aa5389d1fed5dbeabcfb5655a4d6ec3eda4d130f511d1276381ddfa99d9ba3ec81b1b83abd1def46334c299af8f246643ef784857d93eb159e596388cc98587c5a489aaed53025695408ab4b7080943c0632018e9bead8f5302375ec6c12d85dc1984dfbe7269820f5addb18b1171a1b2f6d5a5c22ad0a4653c072328c7d1e5e1fdbdebc57b3afb24fd16082ae0c74525527f8a8eb409267225af70ae7e87c436b3a41e885d5f81685f951da36e28f5306bcc3ab1308fe792f17a3d30f38725948a4e5668730b96fbaf2f1b97d79b902bbd13f5dcf4c7cfdfe83ea9a016a1cd1e414e49aaec0d27a8a3231a1e45b098d8ef37d1c11d9c059d5322dfbc4d460c326b77e1d8269c53eb1511402cc57882ee007073d4b75f10ffac32225318c5379d2f423ef94abfabce9ce2ea4362ebf6d1600b41e94e675410621942689ddbacf4a50462caa1538130f40fb52bca7a28fdd835af127814dd12bdce607f112614ca2b6242cd1dff5b6e8bb52993fe565065e2fdd3da48b89e678cb62d3c4c11883e315014a090fa87b2a8febc0a4660ff350ad4c148408e4e9c84634761444e0f84998b72cf22b676b99de977a5ff712c073e6e7c1cdae534fe1b034d8f2a1178d944958001a9ef2ed6dffa28ce237be79aa8b41422914ebe194c000b233550912d926babb2ab47752a8dce3137df5175db6ca503416abc2c953d885b8a07b46742cf8d9985090e0be79f7bee4c75ef74d703d33447243d4511677246d55faf7b98fcbea168ff67f6b67604e0aaa59ece0f7542941e668edf88141e35a91fb4dca3cd849ea022b99ff41c2035a9867a568a37e43c46e85726a77d42029cbd481332656a3157dcd09e9d80abf120f1a59806e4e6c14e85987c893ecd06c0fc45c4a356b4bace550b29bf1a90f139c9e79dda8f0042263ebc1f5bbcc0cea2ccf9397290e2aa757b7b84ad65148a7269d6a90c2d701bd8674af4d80699719954d9e15d14cd270823e7e7799a74b789bd340f25df5bb63f36e07fbf8d17e98ebe52fce8b8256c71e76063dd64d8118988ebbd5c2297621ade0f900d2913c2f5d3a85b9ab730092363f39430a5f32b835d9c6bcb72c894ddfe2a44351a336b1aeee5ba25ffe817c265ee3960b08622690c0d54944add6f9a5940a5a0694132f94a99e7a5e0b524254f6c593b4ba82f19b8fd54a0de29f4d16f9fa4caa7ab5bfa00be3ca12012efd5659724ddd0711b74af994804d2178b7e8855eacb2da1614c24024b8c8cc5289ff4e03b14eec9451bf769ad4771e52598d74987f0fc71ac8866ab166c4e1bd78c4dce345e2417d2ebf456d4f30e3bc70c898b8d5beb112bdb19cbce737b758dcb34ae738db34a2c304a7234f5d359d0ad3ce811282e5c8ce34bdef7a465bc644c9ba5ab5bc0fd479bed6f27ad21391f7b74acad48e4cb68a3d19f75ff6aaef6f90ce55610fe099ce0e9354c7a516d08af7a6a440ee9f83ce7a4c8f9998da04b4ea894fe48cf9072e7d78b9b44fa1444cf5ebd4ba54efb0b2e03296081625df1823946189413651269344871ce066ac1e5ddacc092c59913c4d8a97fc80fca9f4948f6cb57adc95660c0731905a36ccea0d81a49dd4f0a473d4d3ade8083abda88d7cfa1c00cbf55908756742f5574c7d2bba94dd329d9ab5489ac31c6115183eeec8a3424a3c8f2fe1625b423fec1f8c00e4ec0b49185d30a8b555dba922af4ccb8280d1f8ee05594804fd8d709f8b7af11ebecc8d5c7a997d7b99fa63c4c60dff93cd6c749ae9b2dc4bb239d9cc317fd5355b10f733c7cbead8b2da46c1dcc2830881849d3fdf16be78e618e49a9bf4401ebb0259b03a166dfe467726d8765c21303fe4b893bb963db54798ceec9c0cc405bd463f0881b9b0236a95f00230de62efee001a080c725ac1932f1d9b571e04efa93049506681db1d132f0940690c1c22294cd2543b7cf27143a745332cf837aa405e24d24ab22f30848fe57f7998e7420127f84ed8537ebbee6e0d9109e9345b594127b1a74528514c5b8f961102ce84a79cacd0741de05ba47630e7e6b2e08521720ed8ee2cf4d8d5a4247faedf844262f66b553184cc9772ecc9d94e20002d177298663936ce91d973373c5431345edefad62081e01cd784cdd74b68cad08ec4faad55e7b3525685b94c2500f8171cf44a7639ff30b498c796f2d60fd72e4c2e05c23192c08bf7859e10b80bc6d1a1c412a806083a8231ecd7740bf208af16a2c990f5222b2084ee9163276dd9389f663f3ffd15d5e6aceeb66eae933a8f6ff9fc8ba9c8c03138f4472c37d848ad4734afc34f9f3f2dd54ba0334ad5e8cf8687ec505ba4950595e807c5be8a21b9845ff9b48e68cec094d7f2c4fa862e719b9b1c275b886ba98d1302aa06fc2f023a26e2199aa0d5101bb1770bda086e6ecd1da03829a6e5b8eb6766b2e6a07783e0254ef9759f3f8ab5086944290bb7992dd93ebc397b386ded274eada03074a279247cf3c40972190f80429d9b937d7bee157c298c268531adfe517b04d7023e5542cc8e5b1ca5dfdabc59a47d74cde884d21186528ee3706412d1cb776802b572fe97f54176c54513f940810d9b2f03bfb026828160784004c1f26938a078ac8d4bc17ee3735bafd372d9007559f6477100d1b391ec9c48243993adb95c9e78de7d8913f1ad7652e53067ce36d41d9fbc9f971c9e76ba3a945658484390b4002d29b2523c7c61ca633a28cd5d1e195425774af384d5e76e86fcb397dfb7cdede5aac67fcc3e04db6812edd0d77f3b7cb4de214551c80e871f81311ff9e1692c36861cb58d24a82da50e5eb5399871dcf992683e879009dd4e44037e3bad977a29862d9a316e7527761f9e36ffc14e19c2d30ad0c68108c4889d44ee3ff5d9642dfab99425571ecc5b776f970ac8e1544fe8a9f0453fabc5607ec7c225406b26a7c82c4f824df27950e0680f9d76d6da6643e1bc5b457a66a89df71816e25ffa5c9abb9b9d463019add733a5da432e3ec23ac9d771597e441490b64b69b75282c2f6aec69741f051b54873a05b706c70d862c5879f9f58c3be90bdd9208b5d8715745278763856fb85b4523dbbfc71ed403219c14c045199b60b13a2d057a6e27f0018230b9a860989ced781c4f182f814e819c5e1edf0ed1ea3d83c42abfedb36909f8754af0763cbb7c5b95e1134d277cab40269e0d09f2464e0ae7f470b753d1f4489d19dc4c5c4a54dba54f9de0be49e1e68520aacab5d1acfdc91a1ff8a40b249d31fb7173d0bcd74b4f1810e2cae05bfe0d835228e4137ecd8b157eeff994a305eb8773019b8da573472889f30651928ced8a3d907c8662571a1101536211856f5aa68361668f30107a9159a36d9eb354e02eec67074a8b84392b4016f97020dd4b552e8a71e1d9e9d1d5091f71971057c2d78416b8088bdefad010eda3e5fd261240985a569f365b7b6302f23608350a711f190897ec080dc8f15bb148853d557a1b756ecb206d0195dcbcfbb465ac136579933f5027cacc80dc63849973eddb6ff9505b061b90856ae217a008d74fe2bd599f7db01c67678c563788ae8007aba9453902549bd79aa8500ca989ed52a8edf264b7a8b6acc1483d939a1229a477d37caccd8f671dcb64f6f43984d18e7e200acc6e34d1ac9874914f660a06757eff3bf10b3dbba7a9150cd507303fb7ccd76af2e311fff9d50b4ddbd1ac12d93751e326794d359282c0dc1f00fd536cc81a30d40e5ad895afe695e82d8b284c48228470ca85077894d01411afa4ac6be261f40b2e2b4ebd85dca890203dcef02e488f3be8be0d9ce7b13d8948cc42ba78151f887ab0cacb1d18eaa7f213a67ddd7a7631e7a597ca74b362bc559badc0e2112e8511e8c079c0eabb9f57f6df23e1d87a2d495a5e6055b85ae0a4c2725aa86afe0b127e2d0743c2bf9ab32523a540371ee8d5dd48d381a30d47b36e0670174f52f8a47de2a91878fcad26cc2c3b3890a19de3f775fa927daa6399ffa5518308c328e77a94614f93d0355bc76f99e2a445cb3c724bbcfaf8b856925fd6d133d74ad6d756bf575e4c3060ba4385cb4334611182783c34ae79cbc02c987fb8134847df87163cf46b552a9f8a8d41e3bcc42fc47c7196ff29b6ad24ba162fb3b22d43cbcd0eea485fd3bb91a6ac07a61faa84b0fefdf6efc52d1f13be66c1beda1abedcfb156287f9c64d4d1daee546c804260e24d91b677bab3653eb754869f42a7860868a2feb25a15ed3d028fbf72a22ce0a4a5ebbb3049d4c7c6fff3ab77ef1b6154ec36418b92b17a791deb9fd14385307aee4d6b18f3887672d0eff0901a5add357232b0c9cd29f532bc799767b49a90459ccd839e0ff8bfc9a7e818744ed7eb6266e2b4e67d8143d3eafc51a7cdd57febabbb3a40ad344b54e1f8210900a1783b46dbf3f9901b35ac9b44c75e1aeefb3faa34b4dd8df7420151edcd0b27ac55f705133f7d79eb528937cb50113bf445b206e53fd3cfac1381fdd55b3310c2fa5d3f54318fa8ef0adc8c9b3de90f72f9fb0e95e1382c0f4ff45da8a18ea46fe24d2b02a9605a9f3797338414a91440acee6ecbd78f1ab9b7f339860cac057a949dab83318b9966c6c4b2cba25361efe5d44c465637e2a5d4c6213c2eec89ab3e5fd8abbdae65c7ca71c680c6e111c23f927dcab194ddff81dbcf4223c978fc2698f35917acf27c9ef6a488fd1a3052d4f1e6d8c0298197a944b18d1f081750cdad9009813f6d2f6b2b0b3ad73437264e63dda1987192f76c3cbde30312d4fcee5c9113cd21418b682b01f63e67e7ff46f2d3da2545dacec761a067e8885def6843ea9743c049d1401d8f1bfabe4463d59a2d86fde560d4197d5268410b1391f9a79cd6d8f51583995dc1b2c893447b0d3e69c4880670aa8f2b41644fa8844ff93013e5465f96bb9b8d9080913ff7bd762937496d3a12b3907b4707ebe0f4235455645b117cf9549b39c029aed92fc0df59a1561da2b096e2c9c935db96f4f86b922e06683681c95aec1298eca2ac5df13a21b72563b9d63574e43fd3c130262d4d6f44aab19adc04af7a1ddeaf73767846cdf4746d56bc0b2e49fe459b0cb7e44921c53dd433143222ec41b7bd9eb3a7e37d6bda098d42bf49769806af9c2d85f7619143fb3923514fc3f2f4be731ed14e84e67db4825ed0de7bcf147a999b434232fa0ba2886d2bb2c93c79e2c9d89e08c7490bec367311ea6239b101660aeec37c3cc0a1e968b3cc5550aaab30db4641eb179d69dde53438f1877c29da3f66e7c4284067bba0c9276aa280b2f2b7a2705f5a4c821348b7697ce454b12d9c5a8e4c07b16ef99e357d9f9556c84b33be077edb468ca52fbaf9fcfd1f650d09ea809843ef3adb18e6a9ce6b0e9d774621920953265b5e117ac495ce697f51ba6bb77e63cc8b1fe968bcf02cbe0c07ba12951a5203d3254f7d45c606129d9968c6c5505a3404c2527a6bcfb1c81f56c23ea4e9147065402648e97e3190da1e732bf2d82a03585813969a5f52ebf06f5c0f9edc90dea4ac57a32e0dc014004df3984a0be3852b80111d96eb13b5c8533cfe8df11248ee7f82314af249a079db2d635ccdf9a381b6f81e3fe722c3f5c119928b85d4e5e7c6b8c7aa38d99a170dc02343ad6d785464a6cbf0eeba9d05bb59a3adcecdd69bd226e7b57e3df69fafce1184f3d4c98f6564ed7398fee6411cab3b87b688be36ae3878c0f0c94d7052393477553bf68d3c3c032765ed426d773d74a94bb9c95080dcdd94a1a7a33d05899503fbdfd57377170a63a64e0233d5e52f6b3ba1334e9fe33324b5ac500c6d23c1307036798d21546a2a5bb6bdd6364ca1f3ff7cb4f08f52089614cd4bc80b1feb5bb276c5d07a62ed868b1661b97129a7e2aa755d3ad1e222f557a2279411938144e9be1640acdbf9ccc01a73a75784d44068347051978e8c778940721e30009689c612d8e5ee34cfc466a4e9252ad286bfaefa91c0dcec2a790a1d44a52eb9906501415c3bf6d5d3a03977f8bd8b10ce9ec12b984057a6b5adf22d2b899c4bd043da985444ef39a3c6960e763f45cc0d5c62d4e044184a82a5940746eb81c3a10bddeb64b9744fcd0986b20d2d497e7e4ae458f72908974adc638f5f19268a10405a980fec92ee7b0fb75a0c762069c358c186ee7439315b39b9e7903269e8b73f4883e984ec893e51d9f0aedf42fbd8caf8710649b2d053f0242b288b57cfec8bde2db6f49312877b06ba9b1ae2e4c0287d245dadeeb9057255abd59423b2849cb961e0e1580915a64b40ae4773e1fa90515f902f6a8bd9c969167b451cbbba4b010c326ac7d2e96bfc1b62ae79f4abf18852490d55ecc2005eacb747db9a24b96d0fc696c0fff2081c8b38484fc45a1c103717b9b547f3678cc979265b74d11a49beb158b98bdf03b5f36ab83111628d97f8fc31ea756a0aeae865e806dfbe1d9acdd7dfac4f7ad3584a5988854bcc9513a60aff7d41ab8f2305a4f3addb66549b3789583aea09829fa1863d159b348f73b2b221ea4a2e91bfc040da791fe33ea40cc84bfc917dce6fa35ccfb500161eaab9ed869af5ffe26715a614e285c914a43d7103da79ffdfdc9a817e7d9781377cb21c494f5297298b45bafdfae42409f0eb7a5d7f476bed59ea22b18fd370cd9ebcfc370579601316a9f5786c281aadb24c80dffd33168eabab716f89af5fed1f7d5d03d677a982cbfec7d4ddced33d95fceceee73639f677a927f83af6fb5fa38e2ab6f4d4863e196be7f07fa7948d151c1fb17019faafdb28afeef80e03e07118785e21b7d388099b5873fdca9fa47a34ea2726348ecdc9042430b5fac6d37190e2d8e9133428f0e32d4bc9edd56cd30b2b808ea09831f466a28686eb8f6922603ce04d5d6ee99db9ca4c234275e9492f01ce45d43b11e2e95e95f675336b0187eb92e3be3b2c69950df48a9ab87607e94441d429216724e8ae43172a4de2ed0bf4196845e16e395cf4b2b2dbb9ab64e62dceb77b2b57e3cbeaa2ae62e8bf8c139324ebc657082a9351243312a9a1e4e43e729dff983172afcbc8824e5307b8f610100c1834b24edd382a58c5bdbb56ab6de1ae800f6989e58bf22156e864fe4abebba010f533d51416a412d85471264438fd083a0e70eccf325e4dd8e234f3aca13dc53fe5bc314bbd1b0a2206446b306e09b03a5f75849b7a1cf123dc1de3aae4f1fb5cbbfd5e93151d98d83ff7de94b2b89bc92134539c899c88c40c709c6d1ed44c561945c82152a1ede7efed6383847106e77e3ac35006b60e9eb08d7b517cdff379eb9d2a420193d3d832ceddf9a2657db168aecbac7ad24544abe7c871b64dfddc70279f8e34aca0383d4f9feec926a47d492985fb2f68f3fbcf59741e51401cd8e998e01d84676cb42947993126dbbe1b1da4492efb6f9ccb676d2e0df66693b30adc35cf86cf622742bcdba4644cbef126d7de6bdf7d9730989cdfd4a2106d6177f61119217a91fb885f5ec65a329545b6f1b65b3865dd23d420a564fd8031a2f2c346a685955a0e727d641f8ea8a955b870bc965c67d2552c259349316fef3edbf4bd4feb38ac5d5060315486e7604f4830c782bf9db52a02eb985feafa8de7bdfbed5b07a26cb8d92ec8edbf39ff367c1b6a30e3c4fac62c56b12c739823a39d41b95234662c6dfd0cbb108353b140456b902000bed83cb8bf1c0958e2d5db56325f21e4e62a02291edc48c2b4d71d122c5034ce1770f85046f96ab94d68f329f2cfe0283cb1c5dde48ef1d54dfffca97e285d4ff504389d6928550513f84f2b91b0bb8e63582265700905858c2f3fd506f282c6fb208bd25c671e40fa40399994375366c30dff2106c798da6a648f76d5b6a02da7a8b2f8593a309897144eda7c3a920038baccf20ce3338a786e155e82d62ea710d5ea80dae7786e687c0d8e655ce4c71e2c51aca527ff2b22984ff0d61de8a1af916e93e812334fc00b8e016b6ade43f8da36136944be33c74ffaff499b8832eeab613d91f11c1bf49ddd2f7f22d500ebd9a99db0cbdcbf2bafa82881a97e6aef023c4b520e8d31f8d441fa218281b1693731c2a34be9f4d46bebaa5cc2299867612890220f15179af19cce414590f436e1fcf65b11574864e8485f55fe4c11168ca09b7a93d8390099549631a72b19944cbe28aae920135459531da1f6cd6dfc2a098cd48accc11f6252890b0246db53ef1cec0d1c52e22f52da93cb4ae7405ad21c371cdedfca0f7f4ee0ae2d6a6f5912bcb8f65102134cf12aa5cd765d9f173eb2852f11e8ccaf39a70d792e626d9210e774762d4de4e9b3e9b7a4c612fdb840ddba5ff3236f4e084968eee21f8932c268874cf48d916ca2a9c6c801c7c4e73dc9534211353f9915467bf109635ffbf00546ad709865cb3ae50b8540261a92be7d9784d52e8e3c1ce2c0e78b8d4bfa6506419554f06a857d436aa9d3df196fd277678194a35f2d8ab084c10af0ff1092757baab330df8c08a280e122c6ce742800232fb2d5830805271f0806bdb49a8804e05a140c55784a7266c80d2dc23be662e2692d47f43869ff9447dad1e003f96945befcdd1d294c55fbc41eacdd1e1d3fa81be4cc51ce7e1c71727d96aad789a59032d2acc31fb259114b2d8fb9e3814bbf7a3ab2879f82f631e5d90b708d2f731fbc37158ea884e3dbdef9cc1b66e613ff30224fe62573d7d0bc2c23b87b85653a3e931e6e58e09982d0f9bf322706e5f8dcb9187f6e5c3e9af6efe5a19047abaad875963a88a19f6cb3caa5a492d1d5a49c6296fc5edf85847c951bc96b8ae41c35d7c5abbca0604b8b5d09325e1ad9ea633119fb921aff4bf269c760360503ecbdfdaff02928683b884fcc3d203a5f8eb09341ac915c7bce8258901ea4aac93c1983eeb3bef68876b821018f5ec43bdec041c39e4a2d52b384eb2463379bb1ce6b62eecc050b2350d288a07f92ea32f061bd43593d0ecfb5fec2acbf38c67ac4996b46f24ff849c74f1ddde9e331df902393fc72f700dd3f275ee642e8b36250573d944758b1b69d52fea437b8148fb09f8ea117675723d5b85468be3b9e25faa3b00afb7ec5b807a8ac680cc88e0ce37672f6ad82d32ca3cc4de28c232a5f795149082a909f12a3c2dc0a2335eb05ad22e146ade1e74ad5e0116bad71b31ad384004d7c4a077a7618e7a760cbd13ee6da72ad74bbce1e12d9f399cb4faa71735c3d2d097682450f79b1b0812f38fe393148fde845ec2d40c97a8c277af7a3d209a34382218477526132949b2e0257261e238a3a293d6d715dae3ec5c38cda600d5ceecfe8f2c618c78e71f391b674ce8e949fe9dbf73872cd71503c302c9f18cd457ace9fb9cebaa07b9e2edec7a439082aad8067c6ba9767009a9e645bdbc7b54c79c4bf4e5a51e9d3454a6896fe2ea3ce5f3a9332c35cd528f7fddfaee493a8b5d9846c78075e400f251ebd79bec9900f8570b45b90af2c9ff626d21bd1f77ecc57bdd0ddd18d87b8fde1607ee7e0412778f0c17c25844cbbc69d1eeea7304ca3ad4e942e77c30c278076261c9779f6bbc4b8002435e15d259a4b4576b9cb1cef23bc6ce20898778855a9b278eddd0cd77aae6bc0a8fc55e69658a023b5682c69b6086e95b3d83a3db8de7879b3e244290157bf7dcb7ae9077c2a642f51bbc314b8c1f29fca092cf3a6590ec27538c7e65c1d7ad4f3e0904a3e4b1bcbd511dc15ddff437728322b142ef5e40373503535c4b5f22a21f4b93c09b309d8a3708e894769f875b55be3689980329c0ea6083642a98cd97fcf2014cb7969e1c8a047fd45f4ffacae29c648684c6d2f1a3f3c53e73c9e660adb38f95096b77000be6122ecb9d5580e406746c1185ab51339d9fb14ebae99e4d2d976f437c99d1d0823ea3d3fe75748e527788d4ff7223a40189f16524086deffa218223a6a255095b1ec5b3d9329243f4df479e62a9388c2f0db5125f92c9a08377d681f8fcf3befa85de177eb10f256d4e3eea8ee3283d4265fe6c65985a77cc0ea2d597670ce7fef5d715212e1af91173e2d6e5778a24ec8025d189e452999a49a2fea2df6bf45034dddbab02683aaf0b2e00599aa48daf553c17cdfcbc4bada2453ef02f6a54b6c62635bd0293840d369f40f4b010b0dd3b7f0f491858a1c5a506995429926cb90ac383d831ed71f0d49680480e1791f6df21b5edc91d95b16e71652055e01251639902be25ed3574e0f51bf2b45bf87e2b3e504f9f7be8943bf44f2cce032deeb3eb5a1a71dd63f87ac85f745e66dc080ea597d7a39a028315808ed6e3d3a8c7608506dceaf7be41c288e41a3fb075dcb36203d8f3dddd7f66b7d0efddfbfa69263f27d2f81bddc663b7d13c49e1ae189c16e9d41bb4fba9370c08b6a573189610809bc66e45dff2b895e</script>\n</div>\n<script src=\"/code/lib/blog-encrypt.js\"></script><link href=\"/code/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h1 id=\"Week-9-DLC\"><a class=\"header-anchor\" href=\"#Week-9-DLC\"></a>Week 9 DLC</h1><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>有些內容筆者本來想要放在這週的授課內容中<br>不過一來是筆者的期中快要爆炸，沒有空做簡報<br>另一方面由於授課內容偏難，放在影片中可能會讓影片長度暴增（像是變成三個小時）<br>因此決定另外寫一篇文章來當作補充內容，並且發在自己的部落格</p><a id=\"more\"></a><h2 id=\"線段樹-Extra\"><a class=\"header-anchor\" href=\"#線段樹-Extra\"></a>線段樹 Extra</h2><h3 id=\"持久化\"><a class=\"header-anchor\" href=\"#持久化\"></a>持久化</h3><h4 id=\"老樣子開始前先看個題目\"><a class=\"header-anchor\" href=\"#老樣子開始前先看個題目\"></a>老樣子開始前先看個題目</h4><blockquote><p>給定一個長度為 $N$ 的序列，並且有 $M$ 條指令，指令內容如下</p><ol><li>修改其中一個元素的值</li><li>查詢查詢區間 $[l, r]$ 內的最大值</li><li>回復到第 k 次修改後的狀態</li></ol><p>$N, M \\le 10 ^ 5, k \\le$ 當前修改次數, $0 \\le l, r \\lt N$</p></blockquote><p>1, 2 都還是基本的線段樹，那麼 3 呢</p><p>感覺可以每修改一次就開一顆新的線段樹，要回朔就複製回去</p><p>所以需要開到 $M$ 棵線段樹，所以要開 $4NM$ 的記憶體…先 MLE 了<br>再看一下時間複雜度：$O(M(N + \\log N))$ （先複製一遍 $O(N)$，再做單點修改 $O(\\log N)$，最糟糕要執行 $M$ 次）<br>從各種方面來看感覺都不會過</p><h4 id=\"先觀察一下\"><a class=\"header-anchor\" href=\"#先觀察一下\"></a>先觀察一下</h4><p>對於每次修改，會修改到的地方只有從根節點到要修改的點的路徑而已<br>也就是說 <strong>其他節點沿用舊的資料也沒關係</strong></p><blockquote><p>這邊記得放結構圖</p></blockquote><p>但是用陣列寫就要另外維護節點編號，從實作上來說是幾乎不可能達成的事<br>看來我們需要換個想法</p><h4 id=\"Hmmm，指標？\"><a class=\"header-anchor\" href=\"#Hmmm，指標？\"></a>Hmmm，指標？</h4><p>沒錯，就是指標<br>只要紀錄記憶體位置就好，不用把整個 node 都複製過去</p><p>所以現在線段樹要改成指標版本</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\tnode *l, *r;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode ( <span class=\"keyword\">int</span> _val ): l ( <span class=\"literal\">nullptr</span> ), r ( <span class=\"literal\">nullptr</span> ), value ( _val ) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">up</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">\t\tvalue = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( l )</span><br><span class=\"line\">\t\t\tvalue = max ( value, l -&gt; value );</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( r )</span><br><span class=\"line\">\t\t\tvalue = max ( value, r -&gt; value );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; *seg = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, node *&amp;o )</span></span>&#123;</span><br><span class=\"line\">\to = <span class=\"keyword\">new</span> node ( <span class=\"number\">0</span> );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\tbuild ( l, mid, o -&gt; l );</span><br><span class=\"line\">\tbuild ( mid + <span class=\"number\">1</span>, r, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\to -&gt; up();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, node *&amp;o )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">\t\to -&gt; value = value;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( index &lt;= mid )</span><br><span class=\"line\">\t\t\tupdate ( l, mid, index, value, o -&gt; l );</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tupdate ( mid + <span class=\"number\">1</span>, r, index, value, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\to -&gt; up();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, node *o )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l &lt;= nowR &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o -&gt; value;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> query ( l, r, nowL, mid, o -&gt; l );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> max ( query ( l, r, nowL, mid, o -&gt; l ), query ( l, r, mid + <span class=\"number\">1</span>, nowR, o -&gt; r ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, l, r, in, type;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">\tbuild ( <span class=\"number\">1</span>, n, seg );</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">\t\tupdate ( <span class=\"number\">1</span>, n, i, in, seg );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// type 1: 單點修改</span></span><br><span class=\"line\">\t<span class=\"comment\">// type 2: 區間查詢最大值</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; type;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; in;</span><br><span class=\"line\">\t\t\tupdate ( <span class=\"number\">1</span>, n, l, in, seg );</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, seg ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"持久化-v2\"><a class=\"header-anchor\" href=\"#持久化-v2\"></a>持久化</h4><p>因為要保留舊版本，所以對所有需要被修改的節點新開一個位置來<br>並且把左右子結點的指標，指向原本左右子結點的位置</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\tnode *l, *r;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode ( <span class=\"keyword\">int</span> _val ): l ( <span class=\"literal\">nullptr</span> ), r ( <span class=\"literal\">nullptr</span> ), value ( _val ) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 新增一個建構子，可以直接複製原本的 l, r</span></span><br><span class=\"line\">\tnode ( node *o ): l ( o -&gt; l ), r ( o -&gt; r ), value ( o -&gt; value ) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">up</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">\t\tvalue = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( l )</span><br><span class=\"line\">\t\t\tvalue = max ( value, l -&gt; value );</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( r )</span><br><span class=\"line\">\t\t\tvalue = max ( value, r -&gt; value );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; *seg = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, node *&amp;o )</span></span>&#123;</span><br><span class=\"line\">\to = <span class=\"keyword\">new</span> node ( <span class=\"number\">0</span> );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\tbuild ( l, mid, o -&gt; l );</span><br><span class=\"line\">\tbuild ( mid + <span class=\"number\">1</span>, r, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\to -&gt; up();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, node *&amp;o )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 把需要修改的節點在修改前先開一個新位置出來</span></span><br><span class=\"line\">\to = <span class=\"keyword\">new</span> node ( o );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">\t\to -&gt; value = value;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( index &lt;= mid )</span><br><span class=\"line\">\t\t\tupdate ( l, mid, index, value, o -&gt; l );</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tupdate ( mid + <span class=\"number\">1</span>, r, index, value, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\to -&gt; up();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, node *o )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l &lt;= nowR &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o -&gt; value;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> query ( l, r, nowL, mid, o -&gt; l );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> max ( query ( l, r, nowL, mid, o -&gt; l ), query ( l, r, mid + <span class=\"number\">1</span>, nowR, o -&gt; r ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, l, r, in, type;</span><br><span class=\"line\">    <span class=\"comment\">// 紀錄版本用的 vector</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span> &lt; node* &gt; version;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">\tbuild ( <span class=\"number\">1</span>, n, seg );</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">\t\tupdate ( <span class=\"number\">1</span>, n, i, in, seg );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 記錄初始版本</span></span><br><span class=\"line\">\tversion.push_back ( seg );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// type 1: 單點修改</span></span><br><span class=\"line\">\t<span class=\"comment\">// type 2: 區間查詢最大值</span></span><br><span class=\"line\">\t<span class=\"comment\">// type 3: 回朔到版本 k</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; type;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; in;</span><br><span class=\"line\">\t\t\tupdate ( <span class=\"number\">1</span>, n, l, in, seg );</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 修改完紀錄版本</span></span><br><span class=\"line\">\t\t\tversion.push_back ( seg );</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, seg ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 回朔到版本 k</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">\t\t\tseg = version[in];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h5 id=\"有修改過的地方\"><a class=\"header-anchor\" href=\"#有修改過的地方\"></a>有修改過的地方</h5><table><thead><tr><th>line</th><th>修改內容</th></tr></thead><tbody><tr><td>12</td><td>新增一個建構子，可以直接複製原本的 l, r</td></tr><tr><td>36</td><td>在對節點修改前先開一個新的位置</td></tr><tr><td>69</td><td>記錄用的 vector</td></tr><tr><td>77, 88</td><td>修改完成後，記錄當前版本內容</td></tr><tr><td>94</td><td>新增一個操作，可回朔到版本 k</td></tr></tbody></table><h3 id=\"非簡單操作線段樹\"><a class=\"header-anchor\" href=\"#非簡單操作線段樹\"></a>非簡單操作線段樹</h3><h4 id=\"我們還是看個題目\"><a class=\"header-anchor\" href=\"#我們還是看個題目\"></a>我們還是看個題目</h4><blockquote><p>現在給定一個長度為 $N$ 序列，以及 $M$ 筆操作，操作內容有</p><ol><li>修改一個元素的值</li><li>查詢區間中最長的「好序列」長度</li></ol><p>定義一個「好區間」為：每個元素都是前一個元素 + 1</p><p>這邊是一個題目叫大龍貓的濃縮版，完整版題目可以看 <a href=\"http://toj.tfcis.org/oj/pro/365/\" target=\"_blank\" rel=\"noopener\">這邊</a></p></blockquote><p>現在有點麻煩了，RMQ 我們會，但是這種該怎麼用線段樹實作</p><p>我們可以在 node 中紀錄目前最長的好序列長度，以及其開始位置以及結束位置<br>每次合併兩個區間就取兩邊紀錄的最長好序列的最大值</p><p>Emmm，但是感覺好像怪怪的<br>如果合併兩個區間後，交界處那邊形成一個更長的好序列，怎麼辦？</p><p>尷尬，那我們只好在每個 node 也記錄從開頭處到結束處的好序列了</p><p>聽起來很複雜，但是其實一點也不</p><p>為了方便編寫，我們先定義一個 piece，還有如何辨識兩個 piece 是否相同</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">piece</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l, r, sz;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 檢查兩個 piece 是否相同</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> == ( <span class=\"keyword\">const</span> piece b )&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> l == b.l &amp;&amp; r == b.r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不想寫 operator（或是覺得太麻煩）可以這樣寫</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( piece a, piece b )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a.l == b.l &amp;&amp; a.r == b.r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>$l, r$ 就是這個區間的左右界<br>$sz$ 是大小，可有可無，只是寫 code 上方便</p><p>然後是 node</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    piece front, back, ma;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>$front, back$ 分別為是記錄當前線段樹區間內，從左邊界開始的好序列長度，以及從右邊屆開始的好序列長度<br>$ma$ 則是記錄當前線段樹區間內，最長的好序列長度</p><p>接著來寫合併兩個區間的函數吧，因為沒有內建的函數可以用，只能自己寫一下</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">merge</span> <span class=\"params\">( node L, node R )</span></span>&#123;</span><br><span class=\"line\">    node res;</span><br><span class=\"line\">\tres.front = L.front, res.back = R.back, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( basic[L.back.r] + <span class=\"number\">1</span> == basic[R.front.l] )&#123;</span><br><span class=\"line\">\t\tpiece swp = piece &#123; L.back.l, R.front.r, R.front.r - L.back.l + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( L.front == L.back )</span><br><span class=\"line\">\t\t\tres.front = swp;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( R.front == R.back )</span><br><span class=\"line\">\t\t\tres.back = swp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres.ma = ( swp.sz &gt; res.ma.sz ? swp : res.ma );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>合併兩個區間後，要回傳的 res 內容如下</p><table><thead><tr><th>res 內的 piece</th><th>來源</th></tr></thead><tbody><tr><td>front</td><td>l.front</td></tr><tr><td>back</td><td>r.back</td></tr><tr><td>ma</td><td><a href=\"http://l.ma\" target=\"_blank\" rel=\"noopener\">l.ma</a>, <a href=\"http://r.ma\" target=\"_blank\" rel=\"noopener\">r.ma</a>, l.back + r.back 這三者中的最長好序列</td></tr></tbody></table><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>這篇文章寫的也挺久的，主要是文中的內容大部分都不常用到，在寫的時候還跑去翻了一些文章</p><p>正因如此，內容上可能有些錯誤，如有發現，請聯絡 <a href=\"https://miohitokiri5474.github.io/code/about/\">筆者</a></p><!-- rebuild by neat -->","encrypt":true},{"title":"Golang心情隨筆 #1","date":"2019-11-08T07:28:17.000Z","_content":"\n我也有點忘記我最初為什麼會接觸 Golang 了\n應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現\n像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？\n<!--more-->\n而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她\n其中好像就有一本Golang的語法書\n雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了\n所以我就開始翻了起來\n起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱\n像是我可以在 C 裡面 #include<stdio.h> 後，然後就直接用標頭檔裡面的函數\n不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( \"%d\", &n ) 之類的\n（嚴格來說應該是 fmt.Scanf ( \"%d\", &n )）\n但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww\n明明就只是要 print 個 Hello, World! 要寫 class ww\n\n.\n\n最近比較有空，所以想說來複習一下 Golang 怎麼寫（？\n論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽\n或者是拿它來寫程設作業\n什麼？只能用 C 寫喔\n沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ\n\n不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器","source":"_posts/gd-1.md","raw":"---\ntitle: 'Golang心情隨筆 #1'\ndate: 2019-11-08 15:28:17\ntags:\n - Golang\n---\n\n我也有點忘記我最初為什麼會接觸 Golang 了\n應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現\n像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？\n<!--more-->\n而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她\n其中好像就有一本Golang的語法書\n雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了\n所以我就開始翻了起來\n起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱\n像是我可以在 C 裡面 #include<stdio.h> 後，然後就直接用標頭檔裡面的函數\n不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( \"%d\", &n ) 之類的\n（嚴格來說應該是 fmt.Scanf ( \"%d\", &n )）\n但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww\n明明就只是要 print 個 Hello, World! 要寫 class ww\n\n.\n\n最近比較有空，所以想說來複習一下 Golang 怎麼寫（？\n論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽\n或者是拿它來寫程設作業\n什麼？只能用 C 寫喔\n沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ\n\n不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器","slug":"gd-1","published":1,"updated":"2020-05-03T10:27:23.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndqy000vf19p1n9k5t7i","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>我也有點忘記我最初為什麼會接觸 Golang 了<br>應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現<br>像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？</p><a id=\"more\"></a><p>而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她<br>其中好像就有一本Golang的語法書<br>雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了<br>所以我就開始翻了起來<br>起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱<br>像是我可以在 C 裡面 #include&lt;stdio.h&gt; 後，然後就直接用標頭檔裡面的函數<br>不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( “%d”, &amp;n ) 之類的<br>（嚴格來說應該是 fmt.Scanf ( “%d”, &amp;n )）<br>但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww<br>明明就只是要 print 個 Hello, World! 要寫 class ww</p><p>.</p><p>最近比較有空，所以想說來複習一下 Golang 怎麼寫（？<br>論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽<br>或者是拿它來寫程設作業<br>什麼？只能用 C 寫喔<br>沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ</p><p>不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><p>我也有點忘記我最初為什麼會接觸 Golang 了<br>應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現<br>像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？</p>","more":"<p>而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她<br>其中好像就有一本Golang的語法書<br>雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了<br>所以我就開始翻了起來<br>起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱<br>像是我可以在 C 裡面 #include&lt;stdio.h&gt; 後，然後就直接用標頭檔裡面的函數<br>不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( “%d”, &amp;n ) 之類的<br>（嚴格來說應該是 fmt.Scanf ( “%d”, &amp;n )）<br>但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww<br>明明就只是要 print 個 Hello, World! 要寫 class ww</p><p>.</p><p>最近比較有空，所以想說來複習一下 Golang 怎麼寫（？<br>論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽<br>或者是拿它來寫程設作業<br>什麼？只能用 C 寫喔<br>沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ</p><p>不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器</p><!-- rebuild by neat -->"},{"title":"[ITSA] No.66 詳解","date":"2018-09-13T00:20:50.000Z","_content":"\n## 前言\n\n簡單來說就是我特殊選才的資料不夠\n所以只好來打這東西，不然備審有夠空QQ\n<!--more-->\n\n## problem 1\n\n### 題目\n\n這題就是給你一行整數（數量不定，但是保證 < 11個）\n求該行出現率「超過」一半的整數\n\n### 解法\n\n看到數量不定就會用 getline + stringstream，這很直觀\n然後因為他只有說「給整數」，並沒有限制數字大小\n所以我是用 map 做，而不是陣列（出現負數就尷尬了）\n雖然比較慢但是也比較無腦\n\n為什麼我會在題目那把「超過」加上引號？\n。。。因為我在寫 code 的時候耍智障把判斷式寫成 >=\n然後我就吃 WA 了\n我還跑去問如果有多組解怎麼辦\n結果超過一半的數字只會有一個QQ\n還有把 NO 打成 No\n就多吃兩個 penalty 了，虧爆\n抓到，澪人桐不會寫程式\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nmap < int, int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str;\n    int in, cnt;\n    bool ans;\n    while ( getline ( cin, str ) ){\n        lib.clear();\n        cnt = 0;\n        ans = false;\n        stringstream ss ( str );\n        while ( ss >> in ){\n            lib[in]++;\n            cnt++;\n        }\n\n        for ( auto i: lib ){\n            if ( i.S > cnt / 2 ){\n                cout << i.F << '\\n';\n                ans = true;\n                break;\n            }\n        }\n        if ( !ans )\n            cout << \"NO\\n\";\n    }\n}\n```\n\n## problem 2\n\n### 題目\n\n給一個簡單的一元一次方程式\n保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除\n並保證所有運算元與運算子之間只都有空白隔開\n並且求出 $x$，無條件捨去到小數點第一位\n\n### 解法\n\n要寫字串判斷很麻煩欸 = =\npA寫爆了先來寫這題（？\n手速不知道為什麼爆快\n快到我自己也嚇到\n也沒出什麼 bug，很快就 AC 了 <3\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n\nstring str;\nvector < int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int opt, len, x, a, b, ans;\n    bool flag;\n    while ( getline ( cin, str ) ){\n        len = str.size(), x = 0, ans = 0;\n        flag = false;\n        lib.clear();\n        for ( int i = 0 ; i < len ; i++ ){\n            if ( str[i] == '+' )\n                opt = 0;\n            else if ( str[i] == '-' )\n                opt = 1;\n            else if ( str[i] == '*' )\n                opt = 2;\n            else if ( str[i] == '/' )\n                opt = 3;\n            else{\n                if ( '0' <= str[i] && str[i] <= '9' ){\n                    x = x * 10 + int ( str[i] - '0' );\n                    flag = true;\n                }\n                else{\n                    if ( flag )\n                        lib.pb ( x );\n                    x = 0, flag = false;\n                }\n            }\n        }\n        if ( flag )\n            lib.pb ( x );\n        a = lib[0], b = lib[1];\n        if ( !opt )\n            ans = ( b - a ) * 10.0;\n        else if ( opt == 1 )\n            ans = ( b + a ) * 10.0;\n        else if ( opt == 2 )\n            ans = ( int ) ( ( double ) b / a * 10.0 );\n        else{\n            if ( str[0] == 'x' )\n                ans = ( int ) ( ( double ) b * a * 10.0 );\n            else\n                ans = ( int ) ( ( double ) a / b * 10.0 );\n        }\n        cout << ans / 10 << '.' << ans % 10 << '\\n';\n    }\n}\n```\n\n\n## problem 3\n\n### 題目\n\n給定 $N$ 組字串，請將字串以 $':' or ';' or ','$ 切割\n並輸出出所有字串\n\n### 解法\n\n啊就水題水到爆啊，多開個 string 紀錄就好了\n這題沒有難度（蓋章\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str, swp;\n    int t;\n    cin >> t;\n    getline ( cin, str );\n    while ( t-- ){\n        getline ( cin, str );\n        cout << \"Tokens found:\\n\";\n        swp = \"\";\n        for ( auto i: str ){\n            if ( i == ':' || i == ',' || i == ';' ){\n                cout << swp << '\\n';\n                swp = \"\";\n            }\n            else\n                swp += i;\n        }\n        if ( swp != \"\" )\n            cout << swp << '\\n';\n    }\n}\n```\n\n\n## problem 4\n\n### 題目\n\nzj 上面的是羅馬數字轉阿拉伯數字\n這次 ITSA 出的是要把阿拉伯數字轉羅馬數字\n更水 = =\n\n### 解法\n\n直接按照位數打表輸出就好\n。。。雖然這麼說，但是我還是出 bug 了\n我把4打成\"IIII\"，正確應該是\"IX\"\n垃圾是我QQ\n\n### code\n\n```cpp\n// by.MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstring lib0[10] = { \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\" };\nstring lib1[10] = { \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\" };\nstring lib2[10] = { \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\" };\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, in;\n    cin >> t;\n    while ( t-- ){\n        cin >> in;\n        cout << lib2[in / 100] << lib1[in % 100 / 10] << lib0[in % 10] << '\\n';\n    }\n}\n```\n\n\n## problem 5\n\n### 題目\n\n給定兩個字串，求出這兩個字串所有的 LCS\n\n### 解法\n\n本來只有丟任意解的 LCS\n然後就吃 WA 了，又多一個 penalty\n問官方官方一直沒有回應\n就想說先寫所有解的版本好了\n等到一回覆馬上 judge\n\n然後這就是裸的 LCS 啊 = =\n\n### code\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint dp[105][105], ma;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string a, b, str;\n    set < string > lib;\n    while ( cin >> a >> b ){\n        int szA = a.size(), szB = b.size();\n        lib.clear();\n        memset ( dp, 0, sizeof dp );\n        ma = 0;\n        for ( int i = 0 ; i < szA ; i++ ){\n            for ( int j = 0 ; j < szB ; j++ ){\n                if ( a[i] == b[j] ){\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\n                    ma = max ( ma, dp[i + 1][j + 1] );\n                }\n            }\n        }\n        if ( !ma ){\n            cout << \"No common sequence!\\n\";\n            continue;\n        }\n        for ( int i = 0 ; i < szA ; i++ ){\n            for ( int j = 0 ; j < szB ; j++ ){\n                if ( dp[i + 1][j + 1] == ma ){\n                    str = \"\";\n                    for ( int k = i - ma + 1 ; k <= i ; k++ )\n                        str += a[k];\n                    lib.insert ( str );\n                }\n            }\n        }\n        for ( auto i: lib )\n            cout << i << '\\n';\n    }\n}\n```\n\n\n## 後記\n\n在第 37 分鐘的時候就破台了\n（那時候師大還沒有破台）\n那時候我跟師大的 penalty 差 67\n也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了\n。。。然後師大只吃 66\n80 抽抽不到術師匠的非洲酋長正常發揮QQ\n\n下一次沒意外就會去打 PTC 了\n不過是英文題目\n我覺得我會扛不起來\n在此誠徵英文好的選手一名\n工作：只要幫我翻譯題目就好\n\n然後這一篇的題解我居然寫了 330 行\n喔，這行就 331 了 = =\n雖然看起來很多不過大部分都是 code 就是了","source":"_posts/itsa-66.md","raw":"---\ntitle: '[ITSA] No.66 詳解'\ndate: 2018-09-13 08:20:50\ntags:\n - ITSA\n - Full Contest Solution\n---\n\n## 前言\n\n簡單來說就是我特殊選才的資料不夠\n所以只好來打這東西，不然備審有夠空QQ\n<!--more-->\n\n## problem 1\n\n### 題目\n\n這題就是給你一行整數（數量不定，但是保證 < 11個）\n求該行出現率「超過」一半的整數\n\n### 解法\n\n看到數量不定就會用 getline + stringstream，這很直觀\n然後因為他只有說「給整數」，並沒有限制數字大小\n所以我是用 map 做，而不是陣列（出現負數就尷尬了）\n雖然比較慢但是也比較無腦\n\n為什麼我會在題目那把「超過」加上引號？\n。。。因為我在寫 code 的時候耍智障把判斷式寫成 >=\n然後我就吃 WA 了\n我還跑去問如果有多組解怎麼辦\n結果超過一半的數字只會有一個QQ\n還有把 NO 打成 No\n就多吃兩個 penalty 了，虧爆\n抓到，澪人桐不會寫程式\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nmap < int, int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str;\n    int in, cnt;\n    bool ans;\n    while ( getline ( cin, str ) ){\n        lib.clear();\n        cnt = 0;\n        ans = false;\n        stringstream ss ( str );\n        while ( ss >> in ){\n            lib[in]++;\n            cnt++;\n        }\n\n        for ( auto i: lib ){\n            if ( i.S > cnt / 2 ){\n                cout << i.F << '\\n';\n                ans = true;\n                break;\n            }\n        }\n        if ( !ans )\n            cout << \"NO\\n\";\n    }\n}\n```\n\n## problem 2\n\n### 題目\n\n給一個簡單的一元一次方程式\n保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除\n並保證所有運算元與運算子之間只都有空白隔開\n並且求出 $x$，無條件捨去到小數點第一位\n\n### 解法\n\n要寫字串判斷很麻煩欸 = =\npA寫爆了先來寫這題（？\n手速不知道為什麼爆快\n快到我自己也嚇到\n也沒出什麼 bug，很快就 AC 了 <3\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n\nstring str;\nvector < int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int opt, len, x, a, b, ans;\n    bool flag;\n    while ( getline ( cin, str ) ){\n        len = str.size(), x = 0, ans = 0;\n        flag = false;\n        lib.clear();\n        for ( int i = 0 ; i < len ; i++ ){\n            if ( str[i] == '+' )\n                opt = 0;\n            else if ( str[i] == '-' )\n                opt = 1;\n            else if ( str[i] == '*' )\n                opt = 2;\n            else if ( str[i] == '/' )\n                opt = 3;\n            else{\n                if ( '0' <= str[i] && str[i] <= '9' ){\n                    x = x * 10 + int ( str[i] - '0' );\n                    flag = true;\n                }\n                else{\n                    if ( flag )\n                        lib.pb ( x );\n                    x = 0, flag = false;\n                }\n            }\n        }\n        if ( flag )\n            lib.pb ( x );\n        a = lib[0], b = lib[1];\n        if ( !opt )\n            ans = ( b - a ) * 10.0;\n        else if ( opt == 1 )\n            ans = ( b + a ) * 10.0;\n        else if ( opt == 2 )\n            ans = ( int ) ( ( double ) b / a * 10.0 );\n        else{\n            if ( str[0] == 'x' )\n                ans = ( int ) ( ( double ) b * a * 10.0 );\n            else\n                ans = ( int ) ( ( double ) a / b * 10.0 );\n        }\n        cout << ans / 10 << '.' << ans % 10 << '\\n';\n    }\n}\n```\n\n\n## problem 3\n\n### 題目\n\n給定 $N$ 組字串，請將字串以 $':' or ';' or ','$ 切割\n並輸出出所有字串\n\n### 解法\n\n啊就水題水到爆啊，多開個 string 紀錄就好了\n這題沒有難度（蓋章\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str, swp;\n    int t;\n    cin >> t;\n    getline ( cin, str );\n    while ( t-- ){\n        getline ( cin, str );\n        cout << \"Tokens found:\\n\";\n        swp = \"\";\n        for ( auto i: str ){\n            if ( i == ':' || i == ',' || i == ';' ){\n                cout << swp << '\\n';\n                swp = \"\";\n            }\n            else\n                swp += i;\n        }\n        if ( swp != \"\" )\n            cout << swp << '\\n';\n    }\n}\n```\n\n\n## problem 4\n\n### 題目\n\nzj 上面的是羅馬數字轉阿拉伯數字\n這次 ITSA 出的是要把阿拉伯數字轉羅馬數字\n更水 = =\n\n### 解法\n\n直接按照位數打表輸出就好\n。。。雖然這麼說，但是我還是出 bug 了\n我把4打成\"IIII\"，正確應該是\"IX\"\n垃圾是我QQ\n\n### code\n\n```cpp\n// by.MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstring lib0[10] = { \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\" };\nstring lib1[10] = { \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\" };\nstring lib2[10] = { \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\" };\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, in;\n    cin >> t;\n    while ( t-- ){\n        cin >> in;\n        cout << lib2[in / 100] << lib1[in % 100 / 10] << lib0[in % 10] << '\\n';\n    }\n}\n```\n\n\n## problem 5\n\n### 題目\n\n給定兩個字串，求出這兩個字串所有的 LCS\n\n### 解法\n\n本來只有丟任意解的 LCS\n然後就吃 WA 了，又多一個 penalty\n問官方官方一直沒有回應\n就想說先寫所有解的版本好了\n等到一回覆馬上 judge\n\n然後這就是裸的 LCS 啊 = =\n\n### code\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint dp[105][105], ma;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string a, b, str;\n    set < string > lib;\n    while ( cin >> a >> b ){\n        int szA = a.size(), szB = b.size();\n        lib.clear();\n        memset ( dp, 0, sizeof dp );\n        ma = 0;\n        for ( int i = 0 ; i < szA ; i++ ){\n            for ( int j = 0 ; j < szB ; j++ ){\n                if ( a[i] == b[j] ){\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\n                    ma = max ( ma, dp[i + 1][j + 1] );\n                }\n            }\n        }\n        if ( !ma ){\n            cout << \"No common sequence!\\n\";\n            continue;\n        }\n        for ( int i = 0 ; i < szA ; i++ ){\n            for ( int j = 0 ; j < szB ; j++ ){\n                if ( dp[i + 1][j + 1] == ma ){\n                    str = \"\";\n                    for ( int k = i - ma + 1 ; k <= i ; k++ )\n                        str += a[k];\n                    lib.insert ( str );\n                }\n            }\n        }\n        for ( auto i: lib )\n            cout << i << '\\n';\n    }\n}\n```\n\n\n## 後記\n\n在第 37 分鐘的時候就破台了\n（那時候師大還沒有破台）\n那時候我跟師大的 penalty 差 67\n也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了\n。。。然後師大只吃 66\n80 抽抽不到術師匠的非洲酋長正常發揮QQ\n\n下一次沒意外就會去打 PTC 了\n不過是英文題目\n我覺得我會扛不起來\n在此誠徵英文好的選手一名\n工作：只要幫我翻譯題目就好\n\n然後這一篇的題解我居然寫了 330 行\n喔，這行就 331 了 = =\n雖然看起來很多不過大部分都是 code 就是了","slug":"itsa-66","published":1,"updated":"2020-05-03T10:27:23.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndr0000yf19pe0r9623g","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>簡單來說就是我特殊選才的資料不夠<br>所以只好來打這東西，不然備審有夠空QQ</p><a id=\"more\"></a><h2 id=\"problem-1\"><a class=\"header-anchor\" href=\"#problem-1\"></a>problem 1</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>這題就是給你一行整數（數量不定，但是保證 &lt; 11個）<br>求該行出現率「超過」一半的整數</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>看到數量不定就會用 getline + stringstream，這很直觀<br>然後因為他只有說「給整數」，並沒有限制數字大小<br>所以我是用 map 做，而不是陣列（出現負數就尷尬了）<br>雖然比較慢但是也比較無腦</p><p>為什麼我會在題目那把「超過」加上引號？<br>。。。因為我在寫 code 的時候耍智障把判斷式寫成 &gt;=<br>然後我就吃 WA 了<br>我還跑去問如果有多組解怎麼辦<br>結果超過一半的數字只會有一個QQ<br>還有把 NO 打成 No<br>就多吃兩個 penalty 了，虧爆<br>抓到，澪人桐不會寫程式</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> in, cnt;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( getline ( <span class=\"built_in\">cin</span>, str ) )&#123;</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ans = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span> <span class=\"params\">( str )</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( ss &gt;&gt; in )&#123;</span><br><span class=\"line\">            lib[in]++;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: lib )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i.S &gt; cnt / <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; i.F &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">                ans = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !ans )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NO\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-2\"><a class=\"header-anchor\" href=\"#problem-2\"></a>problem 2</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給一個簡單的一元一次方程式<br>保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除<br>並保證所有運算元與運算子之間只都有空白隔開<br>並且求出 $x$，無條件捨去到小數點第一位</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>要寫字串判斷很麻煩欸 = =<br>pA寫爆了先來寫這題（？<br>手速不知道為什麼爆快<br>快到我自己也嚇到<br>也沒出什麼 bug，很快就 AC 了 &lt;3</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> str;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> opt, len, x, a, b, ans;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( getline ( <span class=\"built_in\">cin</span>, str ) )&#123;</span><br><span class=\"line\">        len = str.size(), x = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'+'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'-'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'*'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'/'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( <span class=\"string\">'0'</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class=\"string\">'9'</span> )&#123;</span><br><span class=\"line\">                    x = x * <span class=\"number\">10</span> + <span class=\"keyword\">int</span> ( str[i] - <span class=\"string\">'0'</span> );</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( flag )</span><br><span class=\"line\">                        lib.pb ( x );</span><br><span class=\"line\">                    x = <span class=\"number\">0</span>, flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( flag )</span><br><span class=\"line\">            lib.pb ( x );</span><br><span class=\"line\">        a = lib[<span class=\"number\">0</span>], b = lib[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !opt )</span><br><span class=\"line\">            ans = ( b - a ) * <span class=\"number\">10.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( opt == <span class=\"number\">1</span> )</span><br><span class=\"line\">            ans = ( b + a ) * <span class=\"number\">10.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( opt == <span class=\"number\">2</span> )</span><br><span class=\"line\">            ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) b / a * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( str[<span class=\"number\">0</span>] == <span class=\"string\">'x'</span> )</span><br><span class=\"line\">                ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) b * a * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) a / b * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans / <span class=\"number\">10</span> &lt;&lt; <span class=\"string\">'.'</span> &lt;&lt; ans % <span class=\"number\">10</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-3\"><a class=\"header-anchor\" href=\"#problem-3\"></a>problem 3</h2><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定 $N$ 組字串，請將字串以 $’:’ or ‘;’ or ‘,’$ 切割<br>並輸出出所有字串</p><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><p>啊就水題水到爆啊，多開個 string 紀錄就好了<br>這題沒有難度（蓋章</p><h3 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str, swp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    getline ( <span class=\"built_in\">cin</span>, str );</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        getline ( <span class=\"built_in\">cin</span>, str );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Tokens found:\\n\"</span>;</span><br><span class=\"line\">        swp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i == <span class=\"string\">':'</span> || i == <span class=\"string\">','</span> || i == <span class=\"string\">';'</span> )&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; swp &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">                swp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                swp += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( swp != <span class=\"string\">\"\"</span> )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; swp &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-4\"><a class=\"header-anchor\" href=\"#problem-4\"></a>problem 4</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>zj 上面的是羅馬數字轉阿拉伯數字<br>這次 ITSA 出的是要把阿拉伯數字轉羅馬數字<br>更水 = =</p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>直接按照位數打表輸出就好<br>。。。雖然這麼說，但是我還是出 bug 了<br>我把4打成&quot;IIII&quot;，正確應該是&quot;IX&quot;<br>垃圾是我QQ</p><h3 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by.MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> lib0[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> lib1[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> lib2[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, in;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; lib2[in / <span class=\"number\">100</span>] &lt;&lt; lib1[in % <span class=\"number\">100</span> / <span class=\"number\">10</span>] &lt;&lt; lib0[in % <span class=\"number\">10</span>] &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-5\"><a class=\"header-anchor\" href=\"#problem-5\"></a>problem 5</h2><h3 id=\"題目-v5\"><a class=\"header-anchor\" href=\"#題目-v5\"></a>題目</h3><p>給定兩個字串，求出這兩個字串所有的 LCS</p><h3 id=\"解法-v5\"><a class=\"header-anchor\" href=\"#解法-v5\"></a>解法</h3><p>本來只有丟任意解的 LCS<br>然後就吃 WA 了，又多一個 penalty<br>問官方官方一直沒有回應<br>就想說先寫所有解的版本好了<br>等到一回覆馬上 judge</p><p>然後這就是裸的 LCS 啊 = =</p><h3 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">105</span>][<span class=\"number\">105</span>], ma;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a, b, str;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"built_in\">string</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> szA = a.size(), szB = b.size();</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> dp );</span><br><span class=\"line\">        ma = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( a[i] == b[j] )&#123;</span><br><span class=\"line\">                    dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    ma = max ( ma, dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !ma )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No common sequence!\\n\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] == ma )&#123;</span><br><span class=\"line\">                    str = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> k = i - ma + <span class=\"number\">1</span> ; k &lt;= i ; k++ )</span><br><span class=\"line\">                        str += a[k];</span><br><span class=\"line\">                    lib.insert ( str );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: lib )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>在第 37 分鐘的時候就破台了<br>（那時候師大還沒有破台）<br>那時候我跟師大的 penalty 差 67<br>也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了<br>。。。然後師大只吃 66<br>80 抽抽不到術師匠的非洲酋長正常發揮QQ</p><p>下一次沒意外就會去打 PTC 了<br>不過是英文題目<br>我覺得我會扛不起來<br>在此誠徵英文好的選手一名<br>工作：只要幫我翻譯題目就好</p><p>然後這一篇的題解我居然寫了 330 行<br>喔，這行就 331 了 = =<br>雖然看起來很多不過大部分都是 code 就是了</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>簡單來說就是我特殊選才的資料不夠<br>所以只好來打這東西，不然備審有夠空QQ</p>","more":"<h2 id=\"problem-1\"><a class=\"header-anchor\" href=\"#problem-1\"></a>problem 1</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>這題就是給你一行整數（數量不定，但是保證 &lt; 11個）<br>求該行出現率「超過」一半的整數</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>看到數量不定就會用 getline + stringstream，這很直觀<br>然後因為他只有說「給整數」，並沒有限制數字大小<br>所以我是用 map 做，而不是陣列（出現負數就尷尬了）<br>雖然比較慢但是也比較無腦</p><p>為什麼我會在題目那把「超過」加上引號？<br>。。。因為我在寫 code 的時候耍智障把判斷式寫成 &gt;=<br>然後我就吃 WA 了<br>我還跑去問如果有多組解怎麼辦<br>結果超過一半的數字只會有一個QQ<br>還有把 NO 打成 No<br>就多吃兩個 penalty 了，虧爆<br>抓到，澪人桐不會寫程式</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> in, cnt;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( getline ( <span class=\"built_in\">cin</span>, str ) )&#123;</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ans = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span> <span class=\"params\">( str )</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( ss &gt;&gt; in )&#123;</span><br><span class=\"line\">            lib[in]++;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: lib )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i.S &gt; cnt / <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; i.F &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">                ans = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !ans )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NO\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-2\"><a class=\"header-anchor\" href=\"#problem-2\"></a>problem 2</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給一個簡單的一元一次方程式<br>保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除<br>並保證所有運算元與運算子之間只都有空白隔開<br>並且求出 $x$，無條件捨去到小數點第一位</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>要寫字串判斷很麻煩欸 = =<br>pA寫爆了先來寫這題（？<br>手速不知道為什麼爆快<br>快到我自己也嚇到<br>也沒出什麼 bug，很快就 AC 了 &lt;3</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> str;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> opt, len, x, a, b, ans;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( getline ( <span class=\"built_in\">cin</span>, str ) )&#123;</span><br><span class=\"line\">        len = str.size(), x = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'+'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'-'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'*'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'/'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( <span class=\"string\">'0'</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class=\"string\">'9'</span> )&#123;</span><br><span class=\"line\">                    x = x * <span class=\"number\">10</span> + <span class=\"keyword\">int</span> ( str[i] - <span class=\"string\">'0'</span> );</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( flag )</span><br><span class=\"line\">                        lib.pb ( x );</span><br><span class=\"line\">                    x = <span class=\"number\">0</span>, flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( flag )</span><br><span class=\"line\">            lib.pb ( x );</span><br><span class=\"line\">        a = lib[<span class=\"number\">0</span>], b = lib[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !opt )</span><br><span class=\"line\">            ans = ( b - a ) * <span class=\"number\">10.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( opt == <span class=\"number\">1</span> )</span><br><span class=\"line\">            ans = ( b + a ) * <span class=\"number\">10.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( opt == <span class=\"number\">2</span> )</span><br><span class=\"line\">            ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) b / a * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( str[<span class=\"number\">0</span>] == <span class=\"string\">'x'</span> )</span><br><span class=\"line\">                ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) b * a * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) a / b * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans / <span class=\"number\">10</span> &lt;&lt; <span class=\"string\">'.'</span> &lt;&lt; ans % <span class=\"number\">10</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-3\"><a class=\"header-anchor\" href=\"#problem-3\"></a>problem 3</h2><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定 $N$ 組字串，請將字串以 $’:’ or ‘;’ or ‘,’$ 切割<br>並輸出出所有字串</p><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><p>啊就水題水到爆啊，多開個 string 紀錄就好了<br>這題沒有難度（蓋章</p><h3 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str, swp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    getline ( <span class=\"built_in\">cin</span>, str );</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        getline ( <span class=\"built_in\">cin</span>, str );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Tokens found:\\n\"</span>;</span><br><span class=\"line\">        swp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i == <span class=\"string\">':'</span> || i == <span class=\"string\">','</span> || i == <span class=\"string\">';'</span> )&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; swp &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">                swp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                swp += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( swp != <span class=\"string\">\"\"</span> )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; swp &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-4\"><a class=\"header-anchor\" href=\"#problem-4\"></a>problem 4</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>zj 上面的是羅馬數字轉阿拉伯數字<br>這次 ITSA 出的是要把阿拉伯數字轉羅馬數字<br>更水 = =</p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>直接按照位數打表輸出就好<br>。。。雖然這麼說，但是我還是出 bug 了<br>我把4打成&quot;IIII&quot;，正確應該是&quot;IX&quot;<br>垃圾是我QQ</p><h3 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by.MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> lib0[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> lib1[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> lib2[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, in;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; lib2[in / <span class=\"number\">100</span>] &lt;&lt; lib1[in % <span class=\"number\">100</span> / <span class=\"number\">10</span>] &lt;&lt; lib0[in % <span class=\"number\">10</span>] &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-5\"><a class=\"header-anchor\" href=\"#problem-5\"></a>problem 5</h2><h3 id=\"題目-v5\"><a class=\"header-anchor\" href=\"#題目-v5\"></a>題目</h3><p>給定兩個字串，求出這兩個字串所有的 LCS</p><h3 id=\"解法-v5\"><a class=\"header-anchor\" href=\"#解法-v5\"></a>解法</h3><p>本來只有丟任意解的 LCS<br>然後就吃 WA 了，又多一個 penalty<br>問官方官方一直沒有回應<br>就想說先寫所有解的版本好了<br>等到一回覆馬上 judge</p><p>然後這就是裸的 LCS 啊 = =</p><h3 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">105</span>][<span class=\"number\">105</span>], ma;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a, b, str;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"built_in\">string</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> szA = a.size(), szB = b.size();</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> dp );</span><br><span class=\"line\">        ma = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( a[i] == b[j] )&#123;</span><br><span class=\"line\">                    dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    ma = max ( ma, dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !ma )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No common sequence!\\n\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] == ma )&#123;</span><br><span class=\"line\">                    str = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> k = i - ma + <span class=\"number\">1</span> ; k &lt;= i ; k++ )</span><br><span class=\"line\">                        str += a[k];</span><br><span class=\"line\">                    lib.insert ( str );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: lib )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>在第 37 分鐘的時候就破台了<br>（那時候師大還沒有破台）<br>那時候我跟師大的 penalty 差 67<br>也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了<br>。。。然後師大只吃 66<br>80 抽抽不到術師匠的非洲酋長正常發揮QQ</p><p>下一次沒意外就會去打 PTC 了<br>不過是英文題目<br>我覺得我會扛不起來<br>在此誠徵英文好的選手一名<br>工作：只要幫我翻譯題目就好</p><p>然後這一篇的題解我居然寫了 330 行<br>喔，這行就 331 了 = =<br>雖然看起來很多不過大部分都是 code 就是了</p><!-- rebuild by neat -->"},{"title":"[UVA][00459]GRAPH CONNECTIVITY","date":"2017-12-27T10:49:17.000Z","_content":"\n## 題目 & 解法\n\n[原題目網址](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=400)\n\n簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。\n\n喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）\n<!--more-->\n\n最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\\le 26$) 所以就直接用 set 了\n\n後來發現。。。就算重複了也無仿啊 = =\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\ntypedef long long LL;\n\n// define tools\n#define REPP(i,f,s) for ( int i = f ; i < s ; i++ )\n#define REPALL(i,n) for ( auto &i: n )\n#define MEM(n,i) memset ( n, i, sizeof n )\n\ntypedef set < int > si;\n#define CLR(n) n.clear()\n\n#define GL(n) getline ( cin, n )\n\nsi edge[30];\nbool go[30];\n\ninline void dfs ( int n ){\n    go[n] = true;\n    REPALL ( i, edge[n] )\n        if ( !go[i] )\n            dfs ( i );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str;\n    int n, u, v, ans, cnt = 0, t;\n    cin >> t;\n    t++;\n    while ( t-- ){\n        GL ( str );\n        MEM ( go, 0 );\n        REPP ( i, 0, 30 )\n            CLR ( edge[i] );\n\n        n = str[0] - 'A';\n        ans = 0;\n        while ( GL ( str ) ){\n            if ( EMP ( str ) )\n                break;\n\n            u = str[0] - 'A', v = str[1] - 'A';\n            edge[u].insert ( v );\n            edge[v].insert ( u );\n        }\n\n        n++;\n        REPP ( i, 0, n )\n            if ( !go[i] ){\n                ans++;\n                dfs ( i );\n            }\n\n        if ( !cnt++ )\n            continue;\n        if ( cnt++ > 2 )\n            cout << '\\n';\n\n        cout << ans << \"\\n\";\n    }\n}\n```","source":"_posts/uva00459.md","raw":"---\ntitle: '[UVA][00459]GRAPH CONNECTIVITY'\ndate: 2017-12-27 18:49:17\ntags:\n - UVa\n - graph\n - dfs\n---\n\n## 題目 & 解法\n\n[原題目網址](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=400)\n\n簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。\n\n喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）\n<!--more-->\n\n最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\\le 26$) 所以就直接用 set 了\n\n後來發現。。。就算重複了也無仿啊 = =\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\ntypedef long long LL;\n\n// define tools\n#define REPP(i,f,s) for ( int i = f ; i < s ; i++ )\n#define REPALL(i,n) for ( auto &i: n )\n#define MEM(n,i) memset ( n, i, sizeof n )\n\ntypedef set < int > si;\n#define CLR(n) n.clear()\n\n#define GL(n) getline ( cin, n )\n\nsi edge[30];\nbool go[30];\n\ninline void dfs ( int n ){\n    go[n] = true;\n    REPALL ( i, edge[n] )\n        if ( !go[i] )\n            dfs ( i );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str;\n    int n, u, v, ans, cnt = 0, t;\n    cin >> t;\n    t++;\n    while ( t-- ){\n        GL ( str );\n        MEM ( go, 0 );\n        REPP ( i, 0, 30 )\n            CLR ( edge[i] );\n\n        n = str[0] - 'A';\n        ans = 0;\n        while ( GL ( str ) ){\n            if ( EMP ( str ) )\n                break;\n\n            u = str[0] - 'A', v = str[1] - 'A';\n            edge[u].insert ( v );\n            edge[v].insert ( u );\n        }\n\n        n++;\n        REPP ( i, 0, n )\n            if ( !go[i] ){\n                ans++;\n                dfs ( i );\n            }\n\n        if ( !cnt++ )\n            continue;\n        if ( cnt++ > 2 )\n            cout << '\\n';\n\n        cout << ans << \"\\n\";\n    }\n}\n```","slug":"uva00459","published":1,"updated":"2020-05-03T10:27:23.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qyndr10010f19pbkq7b53l","content":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=400\" target=\"_blank\" rel=\"noopener\">原題目網址</a></p><p>簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。</p><p>喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）</p><a id=\"more\"></a><p>最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\\le 26$) 所以就直接用 set 了</p><p>後來發現。。。就算重複了也無仿啊 = =</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// define tools</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REPP(i,f,s) for ( int i = f ; i &lt; s ; i++ )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REPALL(i,n) for ( auto &amp;i: n )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MEM(n,i) memset ( n, i, sizeof n )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; si;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CLR(n) n.clear()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GL(n) getline ( cin, n )</span></span><br><span class=\"line\"></span><br><span class=\"line\">si edge[<span class=\"number\">30</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> go[<span class=\"number\">30</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    go[n] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    REPALL ( i, edge[n] )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !go[i] )</span><br><span class=\"line\">            dfs ( i );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, u, v, ans, cnt = <span class=\"number\">0</span>, t;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    t++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        GL ( str );</span><br><span class=\"line\">        MEM ( go, <span class=\"number\">0</span> );</span><br><span class=\"line\">        REPP ( i, <span class=\"number\">0</span>, <span class=\"number\">30</span> )</span><br><span class=\"line\">            CLR ( edge[i] );</span><br><span class=\"line\"></span><br><span class=\"line\">        n = str[<span class=\"number\">0</span>] - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( GL ( str ) )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( EMP ( str ) )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            u = str[<span class=\"number\">0</span>] - <span class=\"string\">'A'</span>, v = str[<span class=\"number\">1</span>] - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            edge[u].insert ( v );</span><br><span class=\"line\">            edge[v].insert ( u );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        REPP ( i, <span class=\"number\">0</span>, n )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !go[i] )&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                dfs ( i );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !cnt++ )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( cnt++ &gt; <span class=\"number\">2</span> )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:17:23 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=400\" target=\"_blank\" rel=\"noopener\">原題目網址</a></p><p>簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。</p><p>喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）</p>","more":"<p>最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\\le 26$) 所以就直接用 set 了</p><p>後來發現。。。就算重複了也無仿啊 = =</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// define tools</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REPP(i,f,s) for ( int i = f ; i &lt; s ; i++ )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REPALL(i,n) for ( auto &amp;i: n )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MEM(n,i) memset ( n, i, sizeof n )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; si;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CLR(n) n.clear()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GL(n) getline ( cin, n )</span></span><br><span class=\"line\"></span><br><span class=\"line\">si edge[<span class=\"number\">30</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> go[<span class=\"number\">30</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    go[n] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    REPALL ( i, edge[n] )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !go[i] )</span><br><span class=\"line\">            dfs ( i );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, u, v, ans, cnt = <span class=\"number\">0</span>, t;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    t++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        GL ( str );</span><br><span class=\"line\">        MEM ( go, <span class=\"number\">0</span> );</span><br><span class=\"line\">        REPP ( i, <span class=\"number\">0</span>, <span class=\"number\">30</span> )</span><br><span class=\"line\">            CLR ( edge[i] );</span><br><span class=\"line\"></span><br><span class=\"line\">        n = str[<span class=\"number\">0</span>] - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( GL ( str ) )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( EMP ( str ) )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            u = str[<span class=\"number\">0</span>] - <span class=\"string\">'A'</span>, v = str[<span class=\"number\">1</span>] - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            edge[u].insert ( v );</span><br><span class=\"line\">            edge[v].insert ( u );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        REPP ( i, <span class=\"number\">0</span>, n )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !go[i] )&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                dfs ( i );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !cnt++ )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( cnt++ &gt; <span class=\"number\">2</span> )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"}],"PostAsset":[{"_id":"source/_posts/GCJ-2019-QuR/pB.jpg","post":"ck9qyndq50007f19p7paw14jr","slug":"pB.jpg","modified":1,"renderable":1},{"_id":"source/_posts/GCJ-2019-QuR/scb.jpg","post":"ck9qyndq50007f19p7paw14jr","slug":"scb.jpg","modified":1,"renderable":1},{"_id":"source/_posts/APCS-19-06/img.jpg","slug":"img.jpg","post":"ck9qyndpx0002f19p0jsj5rry","modified":1,"renderable":0},{"_id":"source/_posts/APCS-19-06/per.png","post":"ck9qyndpx0002f19p0jsj5rry","slug":"per.png","modified":1,"renderable":1},{"_id":"source/_posts/APCS-19-06/score.png","post":"ck9qyndpx0002f19p0jsj5rry","slug":"score.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"ck9qyndpk0000f19pe238gjai","tag_id":"ck9qyndq10004f19p2hvd0eds","_id":"ck9qyndqh000jf19p0kn2fimk"},{"post_id":"ck9qyndpk0000f19pe238gjai","tag_id":"ck9qyndq60008f19p7itu00jv","_id":"ck9qyndqi000lf19pg0a031mm"},{"post_id":"ck9qyndpk0000f19pe238gjai","tag_id":"ck9qyndq9000bf19pa58v2yoq","_id":"ck9qyndqq000of19pgmrf4hm1"},{"post_id":"ck9qyndpk0000f19pe238gjai","tag_id":"ck9qyndqd000ef19phn8hcdji","_id":"ck9qyndqv000qf19pbqqn6khw"},{"post_id":"ck9qyndpx0002f19p0jsj5rry","tag_id":"ck9qyndqg000hf19pgyircnkx","_id":"ck9qyndqy000uf19p978k7vqx"},{"post_id":"ck9qyndpx0002f19p0jsj5rry","tag_id":"ck9qyndqq000nf19p3zwraso3","_id":"ck9qyndqz000wf19paoz11ke6"},{"post_id":"ck9qyndq20005f19patj4164a","tag_id":"ck9qyndqw000sf19pdj0hdt27","_id":"ck9qyndr1000zf19p9yeubcyn"},{"post_id":"ck9qyndq40006f19pdaur866r","tag_id":"ck9qyndq10004f19p2hvd0eds","_id":"ck9qyndr90014f19pa1b7atsw"},{"post_id":"ck9qyndq40006f19pdaur866r","tag_id":"ck9qyndqz000xf19p8b9z0w3f","_id":"ck9qyndra0015f19pgkg6hnlz"},{"post_id":"ck9qyndq40006f19pdaur866r","tag_id":"ck9qyndr20011f19pew279xa7","_id":"ck9qyndrh0017f19pfaqbdae8"},{"post_id":"ck9qyndq40006f19pdaur866r","tag_id":"ck9qyndr50012f19pdmwlan3b","_id":"ck9qyndri0018f19parmmcr8w"},{"post_id":"ck9qyndq50007f19p7paw14jr","tag_id":"ck9qyndr90013f19p59q492oz","_id":"ck9qyndrj001af19pcr6v80gg"},{"post_id":"ck9qyndq50007f19p7paw14jr","tag_id":"ck9qyndqq000nf19p3zwraso3","_id":"ck9qyndrk001bf19pend5dvid"},{"post_id":"ck9qyndq70009f19pec401d4i","tag_id":"ck9qyndri0019f19p09exf7bk","_id":"ck9qyndrm001ef19p3hkw4kye"},{"post_id":"ck9qyndq70009f19pec401d4i","tag_id":"ck9qyndrk001cf19pb0zi2lai","_id":"ck9qyndrm001ff19p43n6h6uk"},{"post_id":"ck9qyndq8000af19p8wm32wzu","tag_id":"ck9qyndri0019f19p09exf7bk","_id":"ck9qyndrn001if19p24rm09bz"},{"post_id":"ck9qyndq8000af19p8wm32wzu","tag_id":"ck9qyndrk001cf19pb0zi2lai","_id":"ck9qyndrn001jf19paw1ddh3l"},{"post_id":"ck9qyndqb000cf19p2og99csm","tag_id":"ck9qyndq10004f19p2hvd0eds","_id":"ck9qyndrp001mf19p5kfbdopp"},{"post_id":"ck9qyndqb000cf19p2og99csm","tag_id":"ck9qyndq60008f19p7itu00jv","_id":"ck9qyndrp001nf19paiel10n8"},{"post_id":"ck9qyndqb000cf19p2og99csm","tag_id":"ck9qyndqq000nf19p3zwraso3","_id":"ck9qyndrp001pf19pfkn3ezvy"},{"post_id":"ck9qyndqb000cf19p2og99csm","tag_id":"ck9qyndrn001kf19p9dh3d0h1","_id":"ck9qyndrq001qf19pd6k72260"},{"post_id":"ck9qyndqc000df19p9y6cezcz","tag_id":"ck9qyndri0019f19p09exf7bk","_id":"ck9qyndrr001sf19p0seoa4s9"},{"post_id":"ck9qyndqc000df19p9y6cezcz","tag_id":"ck9qyndrk001cf19pb0zi2lai","_id":"ck9qyndrs001tf19p1zoy9zbp"},{"post_id":"ck9qyndqe000ff19p80rcddvn","tag_id":"ck9qyndrq001rf19p39b7gxa3","_id":"ck9qyndru001wf19p0qj32cy0"},{"post_id":"ck9qyndqe000ff19p80rcddvn","tag_id":"ck9qyndr20011f19pew279xa7","_id":"ck9qyndrv001xf19paepme6cm"},{"post_id":"ck9qyndqf000gf19paoq2e8mj","tag_id":"ck9qyndri0019f19p09exf7bk","_id":"ck9qyndrw001zf19p19u6dwhr"},{"post_id":"ck9qyndqf000gf19paoq2e8mj","tag_id":"ck9qyndq9000bf19pa58v2yoq","_id":"ck9qyndrx0020f19pgsup6se8"},{"post_id":"ck9qyndqg000if19p6i1sbz4b","tag_id":"ck9qyndrq001rf19p39b7gxa3","_id":"ck9qyndrz0023f19p0fidh3ay"},{"post_id":"ck9qyndqg000if19p6i1sbz4b","tag_id":"ck9qyndr20011f19pew279xa7","_id":"ck9qyndrz0024f19pfqcpayxg"},{"post_id":"ck9qyndqi000kf19p3a0x9bzx","tag_id":"ck9qyndrq001rf19p39b7gxa3","_id":"ck9qynds30029f19p1nnd8s38"},{"post_id":"ck9qyndqi000kf19p3a0x9bzx","tag_id":"ck9qynds00025f19p3xgbhsh4","_id":"ck9qynds3002af19p2azwagqb"},{"post_id":"ck9qyndqi000kf19p3a0x9bzx","tag_id":"ck9qynds00026f19p5d4f8chz","_id":"ck9qynds4002cf19p0ynl2ih4"},{"post_id":"ck9qyndqi000kf19p3a0x9bzx","tag_id":"ck9qyndrn001kf19p9dh3d0h1","_id":"ck9qynds4002df19pecalf38v"},{"post_id":"ck9qyndqk000mf19p6ggk8ebd","tag_id":"ck9qyndrq001rf19p39b7gxa3","_id":"ck9qynds4002ff19pb0c52hta"},{"post_id":"ck9qyndqk000mf19p6ggk8ebd","tag_id":"ck9qyndq9000bf19pa58v2yoq","_id":"ck9qynds5002gf19p9wxk2ya8"},{"post_id":"ck9qyndqs000pf19p4i2h6b36","tag_id":"ck9qynds3002bf19p98fvg0rc","_id":"ck9qynds6002jf19p1mi9861n"},{"post_id":"ck9qyndqs000pf19p4i2h6b36","tag_id":"ck9qynds4002ef19p41tlbsb4","_id":"ck9qynds7002kf19p7qwyb55j"},{"post_id":"ck9qyndqs000pf19p4i2h6b36","tag_id":"ck9qyndr50012f19pdmwlan3b","_id":"ck9qynds8002mf19pd1m6h37o"},{"post_id":"ck9qyndqw000rf19p8cgt241q","tag_id":"ck9qyndrq001rf19p39b7gxa3","_id":"ck9qyndsk002rf19p1bcv02xe"},{"post_id":"ck9qyndqw000rf19p8cgt241q","tag_id":"ck9qynds7002lf19p62nu2exp","_id":"ck9qyndsk002sf19padia9xy7"},{"post_id":"ck9qyndqw000rf19p8cgt241q","tag_id":"ck9qynds3002bf19p98fvg0rc","_id":"ck9qyndsl002uf19pa2iv6j9m"},{"post_id":"ck9qyndqw000rf19p8cgt241q","tag_id":"ck9qyndqd000ef19phn8hcdji","_id":"ck9qyndsl002vf19p9p9x6bs8"},{"post_id":"ck9qyndqw000rf19p8cgt241q","tag_id":"ck9qyndsd002of19pf4gk5fdk","_id":"ck9qyndsm002xf19p1cpces5f"},{"post_id":"ck9qyndqw000rf19p8cgt241q","tag_id":"ck9qyndsi002pf19p3m157nuh","_id":"ck9qyndsm002yf19p99jtdo91"},{"post_id":"ck9qyndqx000tf19p2twtd8ax","tag_id":"ck9qyndsj002qf19p8d7q7vme","_id":"ck9qyndsn0030f19p8t81axw0"},{"post_id":"ck9qyndqx000tf19p2twtd8ax","tag_id":"ck9qyndsk002tf19p4w6x21mq","_id":"ck9qyndsn0031f19pdhvld7a6"},{"post_id":"ck9qyndqy000vf19p1n9k5t7i","tag_id":"ck9qyndsl002wf19p8xpqb9g3","_id":"ck9qyndso0032f19p996be5dh"},{"post_id":"ck9qyndr0000yf19pe0r9623g","tag_id":"ck9qyndsn002zf19p8x6q32d2","_id":"ck9qyndsr0034f19paakoe10t"},{"post_id":"ck9qyndr0000yf19pe0r9623g","tag_id":"ck9qyndqq000nf19p3zwraso3","_id":"ck9qyndsr0035f19pes099thn"},{"post_id":"ck9qyndr10010f19pbkq7b53l","tag_id":"ck9qyndso0033f19p5irm5l4a","_id":"ck9qyndsy0036f19pduzt584x"},{"post_id":"ck9qyndr10010f19pbkq7b53l","tag_id":"ck9qyndq9000bf19pa58v2yoq","_id":"ck9qyndsz0037f19p4aw61q14"},{"post_id":"ck9qyndr10010f19pbkq7b53l","tag_id":"ck9qyndqd000ef19phn8hcdji","_id":"ck9qyndsz0038f19pfd0i9n7d"}],"Tag":[{"name":"CodeForces","_id":"ck9qyndq10004f19p2hvd0eds"},{"name":"div.3","_id":"ck9qyndq60008f19p7itu00jv"},{"name":"graph","_id":"ck9qyndq9000bf19pa58v2yoq"},{"name":"dfs","_id":"ck9qyndqd000ef19phn8hcdji"},{"name":"APCS","_id":"ck9qyndqg000hf19pgyircnkx"},{"name":"Full Contest Solution","_id":"ck9qyndqq000nf19p3zwraso3"},{"name":"C","_id":"ck9qyndqw000sf19pdj0hdt27"},{"name":"Education Round","_id":"ck9qyndqz000xf19p8b9z0w3f"},{"name":"segment tree","_id":"ck9qyndr20011f19pew279xa7"},{"name":"data structure","_id":"ck9qyndr50012f19pdmwlan3b"},{"name":"GCJ","_id":"ck9qyndr90013f19p59q492oz"},{"name":"TIOJ","_id":"ck9qyndri0019f19p09exf7bk"},{"name":"math","_id":"ck9qyndrk001cf19pb0zi2lai"},{"name":"dp","_id":"ck9qyndrn001kf19p9dh3d0h1"},{"name":"TOJ","_id":"ck9qyndrq001rf19p39b7gxa3"},{"name":"ZJ","_id":"ck9qynds00025f19p3xgbhsh4"},{"name":"全國賽","_id":"ck9qynds00026f19p5d4f8chz"},{"name":"dsu","_id":"ck9qynds3002bf19p98fvg0rc"},{"name":"disjoint set","_id":"ck9qynds4002ef19p41tlbsb4"},{"name":"MST","_id":"ck9qynds7002lf19p62nu2exp"},{"name":"樹直徑","_id":"ck9qyndsd002of19pf4gk5fdk"},{"name":"Kruskal","_id":"ck9qyndsi002pf19p3m157nuh"},{"name":"Data Structure","_id":"ck9qyndsj002qf19p8d7q7vme"},{"name":"Segment Tree","_id":"ck9qyndsk002tf19p4w6x21mq"},{"name":"Golang","_id":"ck9qyndsl002wf19p8xpqb9g3"},{"name":"ITSA","_id":"ck9qyndsn002zf19p8x6q32d2"},{"name":"UVa","_id":"ck9qyndso0033f19p5irm5l4a"}]}}