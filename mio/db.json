{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.jpg","path":"images/logo.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/LICENSE","path":"lib/reading_progress/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/README.md","path":"lib/reading_progress/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/package.json","path":"lib/reading_progress/package.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/reading_progress.js","path":"lib/reading_progress/reading_progress.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/reading_progress/reading_progress.min.js","path":"lib/reading_progress/reading_progress.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/LICENSE","path":"lib/canvas-nest/theme-next-canvas-nest/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/theme-next-canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/README.md","path":"lib/canvas-nest/theme-next-canvas-nest/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/Untitled.jpg","path":"images/Untitled.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/background.jpg","path":"images/background.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/background1.jpg","path":"images/background1.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1588501643526},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1588501643516},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1588501643506},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1588501643505},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1588501643219},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1588501643507},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1588501643526},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1588501643135},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1588501643505},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1588501643527},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1588501643506},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1588501643133},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1588501643516},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1588501643219},{"_id":"themes/next/_config.yml","hash":"e23b74ccdeade3ea942401f4c53e35b272ed6c83","modified":1588505252625},{"_id":"themes/next/package.json","hash":"7beb79af6c974bf0397de40b5e581ee8ecd2df34","modified":1588501643517},{"_id":"source/_posts/CF-920F.md","hash":"ce7b5477678b9c023cab23bc26db6548389568f4","modified":1588505047218},{"_id":"source/_posts/CF-999E.md","hash":"368ffa44a0ad17046e4b55a15ec79d6bfe6c4baa","modified":1588505047211},{"_id":"source/_posts/C-atoi.md","hash":"eee5056041ec4408b3b3571a9bd5980aa55b7f71","modified":1588505047208},{"_id":"source/_posts/APCS-19-06.md","hash":"7d461d6718901c560c242162a18e5f116915c1c7","modified":1588505047209},{"_id":"source/_posts/CFR521.md","hash":"d978ed45de6443f0a318da48d77608e600a96234","modified":1588505047203},{"_id":"source/_posts/TIOJ-1615.md","hash":"fb5f45a2430374302062a8692c1bd6628e9c3f9c","modified":1588505047217},{"_id":"source/_posts/GCJ-2019-QuR.md","hash":"b9f2d8f11dd27508610dca6e991b373d56949ccb","modified":1588505047212},{"_id":"source/_posts/TIOJ-1795.md","hash":"2eaa4354b42a4fccf7ad4aa07ad3889903863ba9","modified":1588505047208},{"_id":"source/_posts/TIOJ-1909.md","hash":"4dcc983cda98a5bbf192f73a1724c0def71e2241","modified":1588505047219},{"_id":"source/_posts/TIOJ-1940.md","hash":"f503365db1d28499ba794a92e0fae92e5a5ba3a5","modified":1588505047203},{"_id":"source/_posts/TOJ-365.md","hash":"1fe0be97988c0a2d940606b0dbc9e39d6f8c380a","modified":1588505047210},{"_id":"source/_posts/TOJ-391.md","hash":"be8323f7e77d0a37f427e83dcb57fb5d81c0290f","modified":1588505047211},{"_id":"source/_posts/TOJ-406.md","hash":"7583b73eb18a0c3ed5b0deb31a6a5cecf5e1d2ef","modified":1588505047220},{"_id":"source/_posts/TOJ-407.md","hash":"29d2ba2448171c7f1d37580a8f7d77cd19b79d34","modified":1588505047221},{"_id":"source/_posts/TOJ-420.md","hash":"4fd8e2a68e863642742fd1fd94c3cedd39454f89","modified":1588505047202},{"_id":"source/_posts/dsu.md","hash":"0fb0050ff84aaee626aac34aa5a42557487b2e8d","modified":1588505047210},{"_id":"source/_posts/gd-1.md","hash":"b8e29aed865b3d0de9bbb2ac8c552a176d3e0098","modified":1588505047212},{"_id":"source/_posts/itsa-66.md","hash":"2b7e4673aeeacba24614348d8066dbd7a606b2ba","modified":1588505047214},{"_id":"source/_posts/ncku-icpc-2020-week9-dlc.md","hash":"80d2883bbe366b766d0530802b9458d3c917b6a6","modified":1588505047202},{"_id":"source/_posts/uva00459.md","hash":"1cd92dd988bc3dc9738f131392dcaf18e7afad54","modified":1588505047209},{"_id":"source/about/index.md","hash":"01abb2326a13c0f12ee5bf2d4af915be2262a407","modified":1588505047222},{"_id":"source/tags/index.md","hash":"e415423d44f3fdbb3ee95cde0e2611bda4bc86b7","modified":1588505047224},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1588501643511},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1588501643508},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1588501643512},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1588501643514},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1588501643511},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1588501643510},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1588501643513},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1588501643509},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1588501643512},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1588501643508},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1588501643510},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1588501643514},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1588501643515},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1588501643509},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1588501643513},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1588501643515},{"_id":"themes/next/layout/_layout.swig","hash":"00b5db80898efddb4ac316e2cadbc22464aeb0e7","modified":1588501643156},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1588501643185},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1588501643156},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1588501643165},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1588501643164},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1588501643164},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1588501643147},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1588501643146},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1588501643519},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1588501643518},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1588501643137},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1588501643138},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1588501643136},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588505613297},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643504},{"_id":"source/_posts/GCJ-2019-QuR/pB.jpg","hash":"6a31730b39a0daa043ef1e7c20890d81107660b4","modified":1588505047201},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1588501643149},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1588501643172},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1588501643177},{"_id":"themes/next/layout/_partials/head.swig","hash":"cea4a1d3e752e4e2f452e4a1b32e407295239e39","modified":1588501643179},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1588501643178},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1588501643166},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1588501643180},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1588501643172},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1588501643217},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1588501643217},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1588501643216},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1588501643214},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1588501643160},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1588501643213},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1588501643215},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1588501643162},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1588501643160},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1588501643199},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1588501643194},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1588501643195},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1588501643200},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1588501643202},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1588501643194},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1588501643193},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1588501643522},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1588501643520},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1588501643525},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1588501643523},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1588501643524},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1588501643524},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1588501643520},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1588501643522},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1588501643521},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1588501643313},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1588501643376},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1588501643380},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1588501643364},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1588501643403},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1588501643365},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1588501643378},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1588501643363},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1588501643398},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1588501643377},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1588501643399},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1588501643396},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1588501643394},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588501643379},{"_id":"themes/next/source/images/logo.jpg","hash":"cb281f7c50893405289386845c1a4a3ebc4d5f51","modified":1588501643395},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1588501643404},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588501643362},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1588501643378},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1588501643397},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1588501643374},{"_id":"source/_posts/APCS-19-06/per.png","hash":"e628aa6994da679d08a53ca74178b54ee021da85","modified":1588505047199},{"_id":"source/_posts/APCS-19-06/score.png","hash":"e8b8a2a474d33a3c3cd16b37ac71b87d910ec848","modified":1588505047199},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643158},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643159},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643355},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643360},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643353},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643312},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588501643299},{"_id":"themes/next/source/images/avatar.jpg","hash":"31c71e0c94c5616c9609d7a75e59f005499927cf","modified":1588501643393},{"_id":"source/_posts/GCJ-2019-QuR/scb.jpg","hash":"5d227f3bb095d5d1df070511cae7f7045d1b799f","modified":1588505047201},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1588501643170},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1588501643171},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1588501643169},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1588501643168},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1588501643168},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1588501643184},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1588501643182},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1588501643183},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1588501643183},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1588501643163},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1588501643158},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1588501643159},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1588501643207},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1588501643204},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1588501643207},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1588501643204},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1588501643211},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1588501643206},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1588501643208},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1588501643203},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1588501643205},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1588501643210},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1588501643206},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1588501643209},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1588501643202},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1588501643191},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1588501643187},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1588501643191},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1588501643187},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1588501643190},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1588501643189},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1588501643188},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1588501643192},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1588501643189},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1588501643196},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1588501643197},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1588501643196},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1588501643201},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"417dcf5f2bb6ee4a43f744d5ead88f086d7a9e2c","modified":1588501643222},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1588501643354},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1588501643356},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1588501643355},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1588501643302},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1588501643304},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1588501643311},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1588501643306},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1588501643420},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1588501643413},{"_id":"themes/next/source/js/src/.affix.js.swp","hash":"acf51c1de7a4af58fca94b7bc7eb65f83a34d3b0","modified":1588501643412},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1588501643417},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1588501643419},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1588501643409},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1588501643415},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1588501643418},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1588501643416},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1588501643414},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1588501643415},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1588501643418},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1588501643435},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"327241b60270e59cb10af8fc15dbbaa8f538603f","modified":1588501643462},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1588501643436},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1588501643424},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1588501643422},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1588501643423},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1588501643422},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1588501643487},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1588501643489},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1588501643485},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1588501643487},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1588501643489},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1588501643449},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1588501643478},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1588501643477},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1588501643477},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1588501643478},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1588501643476},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1588501643475},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1588501643430},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1588501643431},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1588501643429},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1588501643456},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1588501643454},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1588501643458},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1588501643453},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1588501643458},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1588501643457},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1588501643459},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1588501643452},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1588501643455},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1588501643455},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1588501643451},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1588501643459},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1588501643452},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1588501643456},{"_id":"themes/next/source/lib/reading_progress/.gitignore","hash":"09cde1060b4213a7eee528b54560777d2d3756e8","modified":1588501643502},{"_id":"themes/next/source/lib/reading_progress/.editorconfig","hash":"7d47ecd70ca58d26af4f69ff1b23034edcf4475e","modified":1588501643501},{"_id":"themes/next/source/lib/reading_progress/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1588501643500},{"_id":"themes/next/source/lib/reading_progress/README.md","hash":"9b00c4ce1a739c825df4e51977f7525d2c9f6b81","modified":1588501643502},{"_id":"themes/next/source/lib/reading_progress/package.json","hash":"7bcb3787978a0c445b1bd3dfeca6ae6016c98abc","modified":1588501643503},{"_id":"themes/next/source/lib/reading_progress/reading_progress.js","hash":"174678a8e2a24763e3fe8b9c25496fdf6ee0220b","modified":1588501643503},{"_id":"themes/next/source/lib/reading_progress/reading_progress.min.js","hash":"98af8d99819882904f9b1a9254bebf40602e1843","modified":1588501643501},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1588501643472},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1588501643468},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1588501643468},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1588501643465},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1588501643464},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1588501643463},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1588501643465},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1588501643464},{"_id":"source/_posts/APCS-19-06/img.jpg","hash":"4a9e925d48c6d56d71d9ed4c5327c51728e45e90","modified":1588505047198},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1588501643448},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1588501643198},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1588501643199},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1588501643277},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1588501643264},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1588501643266},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1588501643236},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1588501643263},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1588501643265},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1588501643276},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"e9eced3913a726945807cc7ad625e7d2caebbe43","modified":1588501643298},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1588501643230},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1588501643230},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1588501643231},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1588501643234},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1588501643232},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1588501643233},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1588501643328},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1588501643345},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1588501643349},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1588501643351},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1588501643352},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1588501643350},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1588501643346},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1588501643344},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1588501643321},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1588501643324},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1588501643323},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1588501643335},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1588501643331},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1588501643338},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1588501643330},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1588501643325},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1588501643336},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1588501643322},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1588501643332},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1588501643407},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1588501643479},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1588501643460},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1588501643484},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/canvas-nest.min.js","hash":"327241b60270e59cb10af8fc15dbbaa8f538603f","modified":1588501643461},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1588501643441},{"_id":"themes/next/source/lib/canvas-nest/theme-next-canvas-nest/README.md","hash":"bf7819cbb879bb82ec1097513d8f799df8835e0f","modified":1588501643461},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1588501643443},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1588501643438},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1588501643440},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1588501643442},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1588501643439},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1588501643437},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1588501643428},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1588501643441},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1588501643440},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1588501643426},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1588501643485},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1588501643486},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1588501643486},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1588501643474},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1588501643474},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1588501643480},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1588501643481},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1588501643494},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1588501643496},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1588501643247},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1588501643296},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1588501643297},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1588501643295},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1588501643294},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1588501643296},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1588501643262},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1588501643261},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1588501643261},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1588501643291},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1588501643292},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1588501643291},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1588501643290},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1588501643289},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1588501643256},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1588501643258},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1588501643257},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1588501643257},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1588501643259},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1588501643254},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1588501643251},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1588501643252},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1588501643249},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1588501643254},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1588501643253},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1588501643255},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1588501643249},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1588501643250},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1588501643239},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1588501643259},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1588501643243},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1588501643241},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1588501643242},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1588501643243},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1588501643240},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1588501643245},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1588501643244},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1588501643242},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1588501643275},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1588501643267},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1588501643274},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1588501643271},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1588501643275},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1588501643269},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1588501643270},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1588501643273},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1588501643269},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1588501643279},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1588501643279},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1588501643286},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1588501643282},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1588501643288},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1588501643280},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1588501643278},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1588501643286},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1588501643284},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1588501643287},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1588501643348},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1588501643342},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1588501643320},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1588501643481},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1588501643482},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1588501643483},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1588501643483},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1588501643482},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1588501643446},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1588501643444},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1588501643447},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1588501643446},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1588501643445},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1588501643444},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1588501643493},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1588501643496},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1588501643245},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1588501643498},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1588501643466},{"_id":"themes/next/source/images/Untitled.jpg","hash":"476bb58e9d29819d8449945275ce8419a82cd9eb","modified":1588501643401},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1588501643433},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1588501643491},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1588501643470},{"_id":"themes/next/source/images/background.jpg","hash":"2f648abf68704046b0eaf479d0fad47747541458","modified":1588501643388},{"_id":"themes/next/source/css/_custom/bg.jpg","hash":"f5c48c6489c14c88436ca6732080bce3dc931788","modified":1588501643227},{"_id":"themes/next/source/images/background1.jpg","hash":"10ff46465606f1e410831e1e2e3e6831b2bbb8b8","modified":1588501643372},{"_id":"public/about/index.html","hash":"edd022920afb66817f29da9991eb23205b55cae3","modified":1588505758522},{"_id":"public/tags/index.html","hash":"04c5f34843b0172c3141783521b09464cca54a4d","modified":1588505758522},{"_id":"public/archives/2017/index.html","hash":"10160281fccb5ace7ef49b7134a3cb7f86b294b5","modified":1588505758522},{"_id":"public/archives/2017/12/index.html","hash":"27a334f2193ab461f7ae6b63d1cc5fa2bd4e924d","modified":1588505758522},{"_id":"public/archives/2018/page/2/index.html","hash":"4171df15cd73f7bb44ccd57c41e3648eca3e239a","modified":1588505758522},{"_id":"public/archives/2018/01/index.html","hash":"d0dc764d4b31ee487555bb237e13df646437e58e","modified":1588505758522},{"_id":"public/archives/2018/02/index.html","hash":"37161c0c5dc3329e78b36d67607cd0b6319b2f21","modified":1588505758522},{"_id":"public/archives/2018/04/index.html","hash":"c6577fa4aeb46554994135cf0e1c4190d5091e5a","modified":1588505758522},{"_id":"public/archives/2018/07/index.html","hash":"b36e6fbb16aa72709fa4eb7b8b0b3bd133d64475","modified":1588505758522},{"_id":"public/archives/2018/08/index.html","hash":"327411b2cd2d1ce764a19c0b92183e25e4ddb042","modified":1588505758522},{"_id":"public/archives/2018/09/index.html","hash":"e28c01ade17807440901885e25d4a76811312fb0","modified":1588505758522},{"_id":"public/archives/2018/10/index.html","hash":"f3910a093657e858679dcdaa738e0387168cfb75","modified":1588505758522},{"_id":"public/archives/2018/11/index.html","hash":"50145e515addcca2d5e6b67371e407a720545cbc","modified":1588505758522},{"_id":"public/archives/2019/01/index.html","hash":"58835be36e82438a79de58a8d2c11680499d2e51","modified":1588505758522},{"_id":"public/archives/2019/04/index.html","hash":"7338ae19edb18438cb84c40e3341a45f6d5224e5","modified":1588505758522},{"_id":"public/archives/2019/06/index.html","hash":"4ddf3506b10e0a3224d18f95f09a86e30eba1e84","modified":1588505758522},{"_id":"public/archives/2019/09/index.html","hash":"5f07e16209293641de79f4aa6fc48e6f0560b113","modified":1588505758522},{"_id":"public/archives/2019/11/index.html","hash":"f5ba6ffd129cbc0248aa50381e39b5f1b73dc269","modified":1588505758522},{"_id":"public/archives/2020/index.html","hash":"3a3ce822201c9c90733c97a83f262b8a4e9a8179","modified":1588505758522},{"_id":"public/archives/2020/05/index.html","hash":"d2091516964e380d3a769333383445cf39523c6a","modified":1588505758522},{"_id":"public/tags/CodeForces/index.html","hash":"5482b91b24b8a6f04732dd34e63dbefda0d694a4","modified":1588505758522},{"_id":"public/tags/Education-Round/index.html","hash":"dc744c04ce8399d3baccc3d721e3f1438fbe5ebd","modified":1588505758522},{"_id":"public/tags/segment-tree/index.html","hash":"f699070f93e5bf28f44d0c50b756fcbba94d4970","modified":1588505758522},{"_id":"public/tags/data-structure/index.html","hash":"3121ac735ab337568b7bfa1228bd293563d1372e","modified":1588505758522},{"_id":"public/tags/div-3/index.html","hash":"acc5732aee980998861cf34100b62783df6e95f1","modified":1588505758522},{"_id":"public/tags/graph/index.html","hash":"434ddffeea2de121276f6c6c75c8a7d5fdf54afa","modified":1588505758522},{"_id":"public/tags/dfs/index.html","hash":"007a5045708b334de6829155f8730d9d50d88d12","modified":1588505758522},{"_id":"public/tags/C/index.html","hash":"855d9eb0f7ea157c2a6127bce2bf2f23d059b7c5","modified":1588505758522},{"_id":"public/tags/APCS/index.html","hash":"55ee553ebd061340940374399ec4032ea7d7e294","modified":1588505758522},{"_id":"public/tags/Full-Contest-Solution/index.html","hash":"3639538d33e18b23054dda46582dfd58792fd28e","modified":1588505758522},{"_id":"public/tags/dp/index.html","hash":"45d6216ea6e7efa3c46ebdea061453069b716f58","modified":1588505758522},{"_id":"public/tags/TIOJ/index.html","hash":"3412b8cf554f3e722bcba1bb2f09f16ad57ceeef","modified":1588505758522},{"_id":"public/tags/math/index.html","hash":"922edef14d9952c5c65f288bfb4c36f4b608eab8","modified":1588505758522},{"_id":"public/tags/GCJ/index.html","hash":"14d2000f3071a2fb796be28bce513930aa92faae","modified":1588505758522},{"_id":"public/tags/ZJ/index.html","hash":"29e2e0333ea1cdbd16c0a152f034b58b2d0faa18","modified":1588505758522},{"_id":"public/tags/全國賽/index.html","hash":"1be9c568a0005f1e565bc33638dd0cc16feae20c","modified":1588505758522},{"_id":"public/tags/MST/index.html","hash":"392799f388cdd52cb6fbac87bcd8fbe707251d8e","modified":1588505758522},{"_id":"public/tags/dsu/index.html","hash":"e099383b4c7811f4ca896e81532f95fa5c7f3653","modified":1588505758522},{"_id":"public/tags/樹直徑/index.html","hash":"b408a23941316b4c9aefe26b3c87b9aa1dc8ba47","modified":1588505758522},{"_id":"public/tags/Kruskal/index.html","hash":"e23cb7a03667c576e8fabbe67c190b2d237644f1","modified":1588505758522},{"_id":"public/tags/disjoint-set/index.html","hash":"ed607a7b4a6cbfeb7c9e26054279d03d0e02e622","modified":1588505758522},{"_id":"public/tags/Golang/index.html","hash":"ca91459c9c286aca2b2ba81d018287cdf09efe05","modified":1588505758522},{"_id":"public/tags/ITSA/index.html","hash":"fcb1a40a0bade2a91e430cf3f6e4b7bd64f115c6","modified":1588505758522},{"_id":"public/tags/Data-Structure/index.html","hash":"62b7649ac13775f00af7b1735b41132a8d6730a8","modified":1588505758522},{"_id":"public/tags/Segment-Tree/index.html","hash":"f52d60e3b638eb5df8c6a44e4574f0c6b0797d68","modified":1588505758522},{"_id":"public/tags/UVa/index.html","hash":"286cd327ea75bc9afc031452f6038df9cc150ae6","modified":1588505758522},{"_id":"public/ncku-icpc-2020-week9-dlc/index.html","hash":"6f9ff34d1f2351ac1223010763cbf7a5839d0671","modified":1588505758522},{"_id":"public/gd-1/index.html","hash":"06409655605f003a5d78c3d51925bbe11be2711a","modified":1588505758522},{"_id":"public/C-atoi/index.html","hash":"96a0c7f2b3422060314db7a75218f6999b1d109b","modified":1588505758522},{"_id":"public/APCS-19-06/index.html","hash":"84132c5ab93fe9b2e249d933d8732c42e48934cf","modified":1588505758522},{"_id":"public/GCJ-2019-QuR/index.html","hash":"a841291891e2beb9895947074b4b4c7d93e27cc7","modified":1588505758522},{"_id":"public/TIOJ-1909/index.html","hash":"cc4577e308aa2c71485860c9858b01f3a56232af","modified":1588505758522},{"_id":"public/CFR521/index.html","hash":"012c584618a3cfbbad688e6d4c46d8f9c455047c","modified":1588505758522},{"_id":"public/TIOJ-1615/index.html","hash":"92daa6f69afda07924746415284fe64ea16207a9","modified":1588505758522},{"_id":"public/itsa-66/index.html","hash":"9d1e40075819bed6483f5a243d9497dcdb7d1bdd","modified":1588505758522},{"_id":"public/dsu/index.html","hash":"754ffd2be6c177c2e68e28dfb16857c41cc7c8ea","modified":1588505758522},{"_id":"public/TOJ-420/index.html","hash":"b63f99143a0816cb7f66b49088a8e3661d06a4bb","modified":1588505758522},{"_id":"public/TOJ-407/index.html","hash":"917e57386dfe3fd5cc5f9cea9c53ad2bf442eb81","modified":1588505758522},{"_id":"public/CF-999E/index.html","hash":"5822b2a20ebbec32b5bd39e3243ec262deccd27f","modified":1588505758522},{"_id":"public/TOJ-406/index.html","hash":"7a4f49f91ba2e0e803797a953a28a51ac1905623","modified":1588505758522},{"_id":"public/CF-920F/index.html","hash":"e9402be1c829b2ab9e024adb312dd39d8f390f05","modified":1588505758522},{"_id":"public/TOJ-391/index.html","hash":"626f8135381f8d68e9ed7a4f3498d920098432b2","modified":1588505758522},{"_id":"public/TIOJ-1795/index.html","hash":"d35d7779daf236a6c81a65dfcaca56fd23b522ed","modified":1588505758522},{"_id":"public/uva00459/index.html","hash":"c1189a70c3d0b2a329a26f3383635086ac0c32d4","modified":1588505758522},{"_id":"public/TOJ-365/index.html","hash":"dcfd8b38b527ddfe708ce4764598bc8760f17667","modified":1588505758522},{"_id":"public/TIOJ-1940/index.html","hash":"89d1eb773258802090eab73e2dce362dab086623","modified":1588505758522},{"_id":"public/archives/index.html","hash":"47b37511b25c9db9e6c306f284c97314f088f0bf","modified":1588505758522},{"_id":"public/archives/page/2/index.html","hash":"b6e882bc12feb0294996a735b330b05b644b439d","modified":1588505758522},{"_id":"public/archives/2018/index.html","hash":"f59388fbc677d5a77060aabe2d69549a8c80fa5d","modified":1588505758522},{"_id":"public/archives/2019/index.html","hash":"8532ee0867b56416d4b2927d5a270e1906e67050","modified":1588505758522},{"_id":"public/index.html","hash":"1ce136dba362e634cabfc7656fff1853216ce288","modified":1588505758522},{"_id":"public/page/2/index.html","hash":"293c9dd6d80da4c6225c4651c6fce31a67a1db88","modified":1588505758522},{"_id":"public/tags/TOJ/index.html","hash":"a3f643b2c6c97fbcffc2558e0461a7de769ef4c1","modified":1588505758522},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1588505758522},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1588505758522},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1588505758522},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1588505758522},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1588505758522},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1588505758522},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1588505758522},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1588505758522},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1588505758522},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1588505758522},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1588505758522},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1588505758522},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588505758522},{"_id":"public/images/logo.jpg","hash":"cb281f7c50893405289386845c1a4a3ebc4d5f51","modified":1588505758522},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1588505758522},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1588505758522},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1588505758522},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1588505758522},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1588505758522},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1588505758522},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1588505758522},{"_id":"public/lib/reading_progress/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1588505758522},{"_id":"public/lib/canvas-nest/theme-next-canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1588505758522},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1588505758522},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1588505758522},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1588505758522},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1588505758522},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1588505758522},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1588505758522},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1588505758522},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1588505758522},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1588505758522},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1588505758522},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1588505758522},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1588505758522},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1588505758522},{"_id":"public/GCJ-2019-QuR/pB.jpg","hash":"6a31730b39a0daa043ef1e7c20890d81107660b4","modified":1588505758522},{"_id":"public/lib/blog-encrypt.js","hash":"91fda12d550323056762c5408623eb8a1d201ecc","modified":1588505758522},{"_id":"public/css/blog-encrypt.css","hash":"22e25b0d16ea053d25eb971e038c817a4c9cb584","modified":1588505758522},{"_id":"public/images/avatar.jpg","hash":"31c71e0c94c5616c9609d7a75e59f005499927cf","modified":1588505758522},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1588505758522},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1588505758522},{"_id":"public/APCS-19-06/per.png","hash":"e628aa6994da679d08a53ca74178b54ee021da85","modified":1588505758522},{"_id":"public/APCS-19-06/score.png","hash":"e8b8a2a474d33a3c3cd16b37ac71b87d910ec848","modified":1588505758522},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1588505758522},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1588505758522},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1588505758522},{"_id":"public/lib/reading_progress/package.json","hash":"e404a0bdf26df62eb89173c6fe5f5824345801c5","modified":1588505758522},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1588505758522},{"_id":"public/js/src/affix.js","hash":"85b55f035ea669572babbfa3bc7e97709215cd11","modified":1588505758522},{"_id":"public/js/src/bootstrap.js","hash":"591cbdf5c99018bd6909453fc7a6f1c7251b9094","modified":1588505758522},{"_id":"public/js/src/algolia-search.js","hash":"a0dc8847e8c952a486a72a6c3f5390449fe471b2","modified":1588505758522},{"_id":"public/js/src/exturl.js","hash":"1236951621edb4a4963a44b854d357f1ccc59901","modified":1588505758522},{"_id":"public/js/src/hook-duoshuo.js","hash":"4f73173deb79640058c12d9e1bdaeba95b274bca","modified":1588505758522},{"_id":"public/js/src/js.cookie.js","hash":"b24612da0aae7319df6f59bb751b303ec2f449f9","modified":1588505758522},{"_id":"public/js/src/post-details.js","hash":"f06075928476e2080872f7e1fdb9ee38064e6ba8","modified":1588505758522},{"_id":"public/js/src/motion.js","hash":"246d6680320e8da75b5c702908752fa724c4e6c4","modified":1588505758522},{"_id":"public/js/src/scrollspy.js","hash":"e0937b6c7ab11d4fd6202e96bb37151ae79243e7","modified":1588505758522},{"_id":"public/js/src/scroll-cookie.js","hash":"56188e16dc9181b9f57f55784b367cecceaf3138","modified":1588505758522},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1588505758522},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"327241b60270e59cb10af8fc15dbbaa8f538603f","modified":1588505758522},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"06cd12dcdf4f35f936a99774b01dfebd39568a11","modified":1588505758522},{"_id":"public/js/src/utils.js","hash":"55f4ae60a8759f57df6c3566f095e052f77ac0d3","modified":1588505758522},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"50f79511adb1f38d6ec54893295854e2f249fac9","modified":1588505758522},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"2984760ff32193c80d55f820b5d7d4eced0111ad","modified":1588505758522},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"89eb8df3303b7b64c78b7d0711ac53400abe0591","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1588505758522},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1588505758522},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1588505758522},{"_id":"public/lib/reading_progress/reading_progress.js","hash":"37afa0e549b32fc72b9aef74daf18637a00ad279","modified":1588505758522},{"_id":"public/lib/reading_progress/reading_progress.min.js","hash":"98af8d99819882904f9b1a9254bebf40602e1843","modified":1588505758522},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1588505758522},{"_id":"public/lib/velocity/velocity.ui.js","hash":"3ced945ee2ed61b2b573e135cb22f18fb995cac0","modified":1588505758522},{"_id":"public/js/src/schemes/pisces.js","hash":"dba650a334efbfa271806262e05f9322602abf60","modified":1588505758522},{"_id":"public/lib/canvas-nest/theme-next-canvas-nest/canvas-nest.min.js","hash":"327241b60270e59cb10af8fc15dbbaa8f538603f","modified":1588505758522},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1588505758522},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"9b86cf4d57f1874ca4ef50b686a58277e529d41f","modified":1588505758522},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1588505758522},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"d6cd6f643e70cc0bf289fbd70ff2fd448b8b4c99","modified":1588505758522},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"a48ccda0b3796d4c248726f791669b056208bf34","modified":1588505758522},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"66df26ca28a4db5f477e56efd97e09e89e801806","modified":1588505758522},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"9c7919d2171d3ba2a48882aeada673b685c97bcf","modified":1588505758522},{"_id":"public/lib/fastclick/README.html","hash":"3a27ee5448eaf5d5ae82dff331e06a057ad04485","modified":1588505758522},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"b0baca4aad98316264858dded0d7c173a4514a9e","modified":1588505758522},{"_id":"public/lib/jquery_lazyload/README.html","hash":"00b33b7ca0252ec5ab91a07c74599b125f596e85","modified":1588505758522},{"_id":"public/lib/reading_progress/README.html","hash":"4a1e4cef866d4de252f187fda9500c3b70f0ee30","modified":1588505758522},{"_id":"public/lib/canvas-nest/theme-next-canvas-nest/README.html","hash":"b3f8b0df34caf5c4e2e47977be543a94c341373b","modified":1588505758522},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1588505758522},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1588505758522},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1588505758522},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1588505758522},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1588505758522},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1588505758522},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1588505758522},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1588505758522},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"5535b56006bf6b8d1988bb0923489e98f327dc18","modified":1588505758522},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1588505758522},{"_id":"public/lib/Han/dist/han.js","hash":"672e85ecc20cd1324509a9104ed8fd3c186c4bb9","modified":1588505758522},{"_id":"public/lib/velocity/velocity.js","hash":"fec6f5c87dd3c11291864a9639a2b7e79b2d127c","modified":1588505758522},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1588505758522},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1588505758522},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1588505758522},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1588505758522},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1588505758522},{"_id":"public/GCJ-2019-QuR/scb.jpg","hash":"5d227f3bb095d5d1df070511cae7f7045d1b799f","modified":1588505758522},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1588505758522},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"7c0f4a0641c19a9d6bb55f979858cc7ddec28f69","modified":1588505758522},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"5ea27509327d54d1ca1575ef854dc33241a1af2b","modified":1588505758522},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"5d126633131a1a7e596795c87cf413c30eb55839","modified":1588505758522},{"_id":"public/css/main.css","hash":"1a68355a230ae85220b40b2a662e99524b46a110","modified":1588505758522},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"03ca00309de65c95ba33a98d307586ff568c143d","modified":1588505758522},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"7a6a180d436df20394664b95b04db711ba239f57","modified":1588505758522},{"_id":"public/lib/Han/dist/han.css","hash":"e386e7db04e322aac8780e60f8cc57684fe9ccc5","modified":1588505758522},{"_id":"public/APCS-19-06/img.jpg","hash":"4a9e925d48c6d56d71d9ed4c5327c51728e45e90","modified":1588505758522},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1588505758522},{"_id":"public/images/Untitled.jpg","hash":"476bb58e9d29819d8449945275ce8419a82cd9eb","modified":1588505758522},{"_id":"public/images/background.jpg","hash":"2f648abf68704046b0eaf479d0fad47747541458","modified":1588505758522},{"_id":"public/images/background1.jpg","hash":"10ff46465606f1e410831e1e2e3e6831b2bbb8b8","modified":1588505758522}],"Category":[],"Data":[],"Page":[{"title":"MiohitoKiri547 - About Me","date":"2018-08-18T05:54:59.000Z","_content":"\n原高中資訊競賽選手（不過成績很爛）\n現任成大資工學生（不過快要被二一了）\n同時為成大競技程式設計的課程助教（不過快要爆肝寫不出講義了）\n\n開始淡出競賽圈，不過還是會偶爾寫一些競程相關的文章\n\n未來可能會開始慢慢增加其他方面的文章\n\n如果有需要聯絡的歡迎寫信到我的email: lltzpp@gmail.com","source":"about/index.md","raw":"---\ntitle: 'MiohitoKiri547 - About Me'\ndate: 2018-08-18 13:54:59\n---\n\n原高中資訊競賽選手（不過成績很爛）\n現任成大資工學生（不過快要被二一了）\n同時為成大競技程式設計的課程助教（不過快要爆肝寫不出講義了）\n\n開始淡出競賽圈，不過還是會偶爾寫一些競程相關的文章\n\n未來可能會開始慢慢增加其他方面的文章\n\n如果有需要聯絡的歡迎寫信到我的email: lltzpp@gmail.com","updated":"2020-05-03T11:24:07.222Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck9qzbcrw0001xl9p3vlh1cja","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>原高中資訊競賽選手（不過成績很爛）<br>現任成大資工學生（不過快要被二一了）<br>同時為成大競技程式設計的課程助教（不過快要爆肝寫不出講義了）</p><p>開始淡出競賽圈，不過還是會偶爾寫一些競程相關的文章</p><p>未來可能會開始慢慢增加其他方面的文章</p><p>如果有需要聯絡的歡迎寫信到我的email: <a href=\"mailto:lltzpp@gmail.com\">lltzpp@gmail.com</a></p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"","more":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>原高中資訊競賽選手（不過成績很爛）<br>現任成大資工學生（不過快要被二一了）<br>同時為成大競技程式設計的課程助教（不過快要爆肝寫不出講義了）</p><p>開始淡出競賽圈，不過還是會偶爾寫一些競程相關的文章</p><p>未來可能會開始慢慢增加其他方面的文章</p><p>如果有需要聯絡的歡迎寫信到我的email: <a href=\"mailto:lltzpp@gmail.com\">lltzpp@gmail.com</a></p><!-- rebuild by neat -->"},{"title":"tags","date":"2020-05-03T11:00:39.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-05-03 19:00:39\n---\n","updated":"2020-05-03T11:24:07.224Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck9qzbcs30003xl9p3e1hbcuo","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"","more":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><!-- rebuild by neat -->"}],"Post":[{"title":"[CF][920F] F. SUM AND REPLACE","date":"2018-04-03T03:25:31.000Z","_content":"\n## 前言\n\n好久沒有發題解了，今天心血來潮來寫一篇吧\n今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF\npF，感覺很難？其實還好， 因為這是 Education\n<!--more-->\n\n## 題目\n\n不管，翻譯下題目好了，畢竟原題是英文的\n要原題連結的[在這](http://codeforces.com/problemset/problem/920/F)\n\n給定一個長度為N的序列，並有兩種輸入要處理：\n1. 對區間 $l, r$ 做操作 $D$（等等寫在下面）\n2. 查詢區間和\n\n操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 $\\{1, 2, 3, 6\\}$，共四個）\n\n\n## 解法\n\n嗯。。。區間操作？區間和？\n怎麼看都是線段樹，但是問題是：操作\n因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\\sqrt{N}$，證明我等等再打\n\n好，我們先觀察一下：\n1. 只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）\n2. 越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果\n\n接著是最後一個問題：該如何處理區間操作\n對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）\n不過有種做法叫**找收斂點（終止點）**\n\n剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\\ge 2$ 的數字當作是否繼續進行操作的依據\n\n到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看[這篇](https://miohitokiri.github.io/code/TOJ-391/)\n\n不過大概算了一下，這樣需要開到$8\\times N$的記憶體，感覺會 MLE\n所以我先拿區間和開刀，如果當前區間和 $\\ge 2\\times range（區間大小）$ 再繼續進行操作\n。。。然後我就 WA 了，請想想如果當前區間內元素為 $\\{ 1, 1, 1, 3 \\}$ 的時候\n\n有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字\n所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\\ge 2$\n\n本來不想要開第二顆線段樹，到頭來還不是開了\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 300005\n\nLL sum[maxN << 2], dp[1000005];\nbool used[maxN << 2];\nvector < int > prime;\nbitset < 1005 > lib;\n\ninline int D ( int n ){\n    if ( dp[n] != -1 )\n        return dp[n];\n    double www = sqrt ( n );\n    int ma = www, res = 0, maa = ma + 1;\n    for ( int i = 1 ; i < maa ; i++ )\n        n % i ? res : res++;\n\n    return dp[n] = res * 2 - ( www == ma ? 1 : 0 );\n}\n\ninline void build ( int l, int r, int n ){\n    if ( l == r ){\n        cin >> sum[n];\n        used[n] = ( sum[n] > 2 );\n    }\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        build ( l, mid, leftSon );\n        build ( mid + 1, r, rightSon );\n\n        sum[n] = sum[leftSon] + sum[rightSon];\n        used[n] = ( used[leftSon] || used[rightSon] );\n    }\n}\n\ninline LL query ( int l, int r, int nowL, int nowR, int n ){\n    if ( l <= nowL && nowR <= r )\n        return sum[n];\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( r <= mid )\n        return query ( l, r, nowL, mid, leftSon );\n    if ( mid < l )\n        return query ( l, r, mid + 1, nowR, rightSon );\n    return query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + 1, nowR, rightSon );\n}\n\ninline void modify ( int l, int r, int nowL, int nowR, int n ){\n    if ( !used[n] )\n        return;\n    if ( nowL == nowR ){\n        sum[n] = D ( sum[n] );\n        used[n] = ( sum[n] > 2 );\n    }\n    else{\n        int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( r <= mid )\n            modify ( l, r, nowL, mid, leftSon );\n        else if ( mid < l )\n            modify ( l, r, mid + 1, nowR, rightSon );\n        else{\n            modify ( l, r, nowL, mid, leftSon );\n            modify ( l, r, mid + 1, nowR, rightSon );\n        }\n\n        sum[n] = sum[leftSon] + sum[rightSon];\n        used[n] = ( used[leftSon] || used[rightSon] );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    lib[0] = lib[1] = true;\n    for ( int i = 2 ; i < 1005 ; i++ ){\n        if ( !lib[i] ){\n            prime.push_back ( i );\n            for ( int j = i << 1 ; j < 1005 ; j += i )\n                lib[j] = true;\n        }\n    }\n\n    memset ( dp, -1, sizeof dp );\n    int n, m, type, l, r, stop;\n    cin >> n >> m;\n    build ( 1, n, 1 );\n\n    while ( m-- ){\n        cin >> type >> l >> r;\n        if ( type == 1 )\n            modify ( l, r, 1, n, 1 );\n        else\n            cout << query ( l, r, 1, n, 1 ) << '\\n';\n    }\n}\n```\n\n## 證明（？\n\n接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\\sqrt{N}$ 的數字就好了\n假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數\n這樣代表說 $\\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \\frac{N}{i}  \\to i \\times j = N$\n假設 $i\\le j$ 帶入上面的式子，$i^2\\le N\\to i\\le\\sqrt{N}$\n故得證\n\n。。。好啦，我感覺我寫的證明不是對的 > <\n以上證明僅供參考","source":"_posts/CF-920F.md","raw":"---\ntitle: '[CF][920F] F. SUM AND REPLACE'\ndate: 2018-04-03 11:25:31\ntags:\n - CodeForces\n - Education Round\n - segment tree\n - data structure\n---\n\n## 前言\n\n好久沒有發題解了，今天心血來潮來寫一篇吧\n今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF\npF，感覺很難？其實還好， 因為這是 Education\n<!--more-->\n\n## 題目\n\n不管，翻譯下題目好了，畢竟原題是英文的\n要原題連結的[在這](http://codeforces.com/problemset/problem/920/F)\n\n給定一個長度為N的序列，並有兩種輸入要處理：\n1. 對區間 $l, r$ 做操作 $D$（等等寫在下面）\n2. 查詢區間和\n\n操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 $\\{1, 2, 3, 6\\}$，共四個）\n\n\n## 解法\n\n嗯。。。區間操作？區間和？\n怎麼看都是線段樹，但是問題是：操作\n因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\\sqrt{N}$，證明我等等再打\n\n好，我們先觀察一下：\n1. 只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）\n2. 越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果\n\n接著是最後一個問題：該如何處理區間操作\n對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）\n不過有種做法叫**找收斂點（終止點）**\n\n剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\\ge 2$ 的數字當作是否繼續進行操作的依據\n\n到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看[這篇](https://miohitokiri.github.io/code/TOJ-391/)\n\n不過大概算了一下，這樣需要開到$8\\times N$的記憶體，感覺會 MLE\n所以我先拿區間和開刀，如果當前區間和 $\\ge 2\\times range（區間大小）$ 再繼續進行操作\n。。。然後我就 WA 了，請想想如果當前區間內元素為 $\\{ 1, 1, 1, 3 \\}$ 的時候\n\n有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字\n所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\\ge 2$\n\n本來不想要開第二顆線段樹，到頭來還不是開了\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 300005\n\nLL sum[maxN << 2], dp[1000005];\nbool used[maxN << 2];\nvector < int > prime;\nbitset < 1005 > lib;\n\ninline int D ( int n ){\n    if ( dp[n] != -1 )\n        return dp[n];\n    double www = sqrt ( n );\n    int ma = www, res = 0, maa = ma + 1;\n    for ( int i = 1 ; i < maa ; i++ )\n        n % i ? res : res++;\n\n    return dp[n] = res * 2 - ( www == ma ? 1 : 0 );\n}\n\ninline void build ( int l, int r, int n ){\n    if ( l == r ){\n        cin >> sum[n];\n        used[n] = ( sum[n] > 2 );\n    }\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        build ( l, mid, leftSon );\n        build ( mid + 1, r, rightSon );\n\n        sum[n] = sum[leftSon] + sum[rightSon];\n        used[n] = ( used[leftSon] || used[rightSon] );\n    }\n}\n\ninline LL query ( int l, int r, int nowL, int nowR, int n ){\n    if ( l <= nowL && nowR <= r )\n        return sum[n];\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( r <= mid )\n        return query ( l, r, nowL, mid, leftSon );\n    if ( mid < l )\n        return query ( l, r, mid + 1, nowR, rightSon );\n    return query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + 1, nowR, rightSon );\n}\n\ninline void modify ( int l, int r, int nowL, int nowR, int n ){\n    if ( !used[n] )\n        return;\n    if ( nowL == nowR ){\n        sum[n] = D ( sum[n] );\n        used[n] = ( sum[n] > 2 );\n    }\n    else{\n        int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( r <= mid )\n            modify ( l, r, nowL, mid, leftSon );\n        else if ( mid < l )\n            modify ( l, r, mid + 1, nowR, rightSon );\n        else{\n            modify ( l, r, nowL, mid, leftSon );\n            modify ( l, r, mid + 1, nowR, rightSon );\n        }\n\n        sum[n] = sum[leftSon] + sum[rightSon];\n        used[n] = ( used[leftSon] || used[rightSon] );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    lib[0] = lib[1] = true;\n    for ( int i = 2 ; i < 1005 ; i++ ){\n        if ( !lib[i] ){\n            prime.push_back ( i );\n            for ( int j = i << 1 ; j < 1005 ; j += i )\n                lib[j] = true;\n        }\n    }\n\n    memset ( dp, -1, sizeof dp );\n    int n, m, type, l, r, stop;\n    cin >> n >> m;\n    build ( 1, n, 1 );\n\n    while ( m-- ){\n        cin >> type >> l >> r;\n        if ( type == 1 )\n            modify ( l, r, 1, n, 1 );\n        else\n            cout << query ( l, r, 1, n, 1 ) << '\\n';\n    }\n}\n```\n\n## 證明（？\n\n接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\\sqrt{N}$ 的數字就好了\n假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數\n這樣代表說 $\\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \\frac{N}{i}  \\to i \\times j = N$\n假設 $i\\le j$ 帶入上面的式子，$i^2\\le N\\to i\\le\\sqrt{N}$\n故得證\n\n。。。好啦，我感覺我寫的證明不是對的 > <\n以上證明僅供參考","slug":"CF-920F","published":1,"updated":"2020-05-03T11:24:07.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcrq0000xl9phik32wvv","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>好久沒有發題解了，今天心血來潮來寫一篇吧<br>今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF<br>pF，感覺很難？其實還好， 因為這是 Education</p><a id=\"more\"></a><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>不管，翻譯下題目好了，畢竟原題是英文的<br>要原題連結的<a href=\"http://codeforces.com/problemset/problem/920/F\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>給定一個長度為N的序列，並有兩種輸入要處理：</p><ol><li>對區間 $l, r$ 做操作 $D$（等等寫在下面）</li><li>查詢區間和</li></ol><p>操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 ${1, 2, 3, 6}$，共四個）</p><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>嗯。。。區間操作？區間和？<br>怎麼看都是線段樹，但是問題是：操作<br>因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\\sqrt{N}$，證明我等等再打</p><p>好，我們先觀察一下：</p><ol><li>只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）</li><li>越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果</li></ol><p>接著是最後一個問題：該如何處理區間操作<br>對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）<br>不過有種做法叫<strong>找收斂點（終止點）</strong></p><p>剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\\ge 2$ 的數字當作是否繼續進行操作的依據</p><p>到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看<a href=\"https://miohitokiri.github.io/code/TOJ-391/\" target=\"_blank\" rel=\"noopener\">這篇</a></p><p>不過大概算了一下，這樣需要開到$8\\times N$的記憶體，感覺會 MLE<br>所以我先拿區間和開刀，如果當前區間和 $\\ge 2\\times range（區間大小）$ 再繼續進行操作<br>。。。然後我就 WA 了，請想想如果當前區間內元素為 ${ 1, 1, 1, 3 }$ 的時候</p><p>有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字<br>所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\\ge 2$</p><p>本來不想要開第二顆線段樹，到頭來還不是開了</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 300005</span></span><br><span class=\"line\"></span><br><span class=\"line\">LL sum[maxN &lt;&lt; <span class=\"number\">2</span>], dp[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> used[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; prime;</span><br><span class=\"line\"><span class=\"built_in\">bitset</span> &lt; 1005 &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">D</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( dp[n] != <span class=\"number\">-1</span> )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> www = <span class=\"built_in\">sqrt</span> ( n );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ma = www, res = <span class=\"number\">0</span>, maa = ma + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; maa ; i++ )</span><br><span class=\"line\">        n % i ? res : res++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n] = res * <span class=\"number\">2</span> - ( www == ma ? <span class=\"number\">1</span> : <span class=\"number\">0</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; sum[n];</span><br><span class=\"line\">        used[n] = ( sum[n] &gt; <span class=\"number\">2</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        build ( l, mid, leftSon );</span><br><span class=\"line\">        build ( mid + <span class=\"number\">1</span>, r, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class=\"line\">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> LL <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">modify</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !used[n] )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( nowL == nowR )&#123;</span><br><span class=\"line\">        sum[n] = D ( sum[n] );</span><br><span class=\"line\">        used[n] = ( sum[n] &gt; <span class=\"number\">2</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">            modify ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            modify ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class=\"line\">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    lib[<span class=\"number\">0</span>] = lib[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt; <span class=\"number\">1005</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !lib[i] )&#123;</span><br><span class=\"line\">            prime.push_back ( i );</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i &lt;&lt; <span class=\"number\">1</span> ; j &lt; <span class=\"number\">1005</span> ; j += i )</span><br><span class=\"line\">                lib[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span> ( dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> dp );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, type, l, r, stop;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    build ( <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )</span><br><span class=\"line\">            modify ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"證明（？\"><a class=\"header-anchor\" href=\"#證明（？\"></a>證明（？</h2><p>接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\\sqrt{N}$ 的數字就好了<br>假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數<br>這樣代表說 $\\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \\frac{N}{i} \\to i \\times j = N$<br>假設 $i\\le j$ 帶入上面的式子，$i^2\\le N\\to i\\le\\sqrt{N}$<br>故得證</p><p>。。。好啦，我感覺我寫的證明不是對的 &gt; &lt;<br>以上證明僅供參考</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>好久沒有發題解了，今天心血來潮來寫一篇吧<br>今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF<br>pF，感覺很難？其實還好， 因為這是 Education</p>","more":"<h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>不管，翻譯下題目好了，畢竟原題是英文的<br>要原題連結的<a href=\"http://codeforces.com/problemset/problem/920/F\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>給定一個長度為N的序列，並有兩種輸入要處理：</p><ol><li>對區間 $l, r$ 做操作 $D$（等等寫在下面）</li><li>查詢區間和</li></ol><p>操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 ${1, 2, 3, 6}$，共四個）</p><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>嗯。。。區間操作？區間和？<br>怎麼看都是線段樹，但是問題是：操作<br>因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\\sqrt{N}$，證明我等等再打</p><p>好，我們先觀察一下：</p><ol><li>只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）</li><li>越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果</li></ol><p>接著是最後一個問題：該如何處理區間操作<br>對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）<br>不過有種做法叫<strong>找收斂點（終止點）</strong></p><p>剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\\ge 2$ 的數字當作是否繼續進行操作的依據</p><p>到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看<a href=\"https://miohitokiri.github.io/code/TOJ-391/\" target=\"_blank\" rel=\"noopener\">這篇</a></p><p>不過大概算了一下，這樣需要開到$8\\times N$的記憶體，感覺會 MLE<br>所以我先拿區間和開刀，如果當前區間和 $\\ge 2\\times range（區間大小）$ 再繼續進行操作<br>。。。然後我就 WA 了，請想想如果當前區間內元素為 ${ 1, 1, 1, 3 }$ 的時候</p><p>有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字<br>所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\\ge 2$</p><p>本來不想要開第二顆線段樹，到頭來還不是開了</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 300005</span></span><br><span class=\"line\"></span><br><span class=\"line\">LL sum[maxN &lt;&lt; <span class=\"number\">2</span>], dp[<span class=\"number\">1000005</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> used[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; prime;</span><br><span class=\"line\"><span class=\"built_in\">bitset</span> &lt; 1005 &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">D</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( dp[n] != <span class=\"number\">-1</span> )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> www = <span class=\"built_in\">sqrt</span> ( n );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ma = www, res = <span class=\"number\">0</span>, maa = ma + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; maa ; i++ )</span><br><span class=\"line\">        n % i ? res : res++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n] = res * <span class=\"number\">2</span> - ( www == ma ? <span class=\"number\">1</span> : <span class=\"number\">0</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; sum[n];</span><br><span class=\"line\">        used[n] = ( sum[n] &gt; <span class=\"number\">2</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        build ( l, mid, leftSon );</span><br><span class=\"line\">        build ( mid + <span class=\"number\">1</span>, r, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class=\"line\">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> LL <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">modify</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !used[n] )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( nowL == nowR )&#123;</span><br><span class=\"line\">        sum[n] = D ( sum[n] );</span><br><span class=\"line\">        used[n] = ( sum[n] &gt; <span class=\"number\">2</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">            modify ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            modify ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class=\"line\">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    lib[<span class=\"number\">0</span>] = lib[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt; <span class=\"number\">1005</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !lib[i] )&#123;</span><br><span class=\"line\">            prime.push_back ( i );</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i &lt;&lt; <span class=\"number\">1</span> ; j &lt; <span class=\"number\">1005</span> ; j += i )</span><br><span class=\"line\">                lib[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span> ( dp, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> dp );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, type, l, r, stop;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    build ( <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )</span><br><span class=\"line\">            modify ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"證明（？\"><a class=\"header-anchor\" href=\"#證明（？\"></a>證明（？</h2><p>接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\\sqrt{N}$ 的數字就好了<br>假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數<br>這樣代表說 $\\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \\frac{N}{i} \\to i \\times j = N$<br>假設 $i\\le j$ 帶入上面的式子，$i^2\\le N\\to i\\le\\sqrt{N}$<br>故得證</p><p>。。。好啦，我感覺我寫的證明不是對的 &gt; &lt;<br>以上證明僅供參考</p><!-- rebuild by neat -->"},{"title":"[CF][999E] E. REACHABILITY FROM THE CAPITAL","date":"2018-08-03T14:47:34.000Z","_content":"\n## 題目 + 解法\n\n這是 CodeForces Round 490 div.3 的題目\n最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人\n沒有意外下一場應該就會下來了吧\n先放上題目[連結](http://codeforces.com/problemset/problem/999/E)\n<!--more-->\n\n會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下\n今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）\n\n講一下題目大意好了\n首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$\n求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）\n\n有個很直觀的想法如下，首先點會先被分成兩種類型：\n1. 這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過\n2. 沒有經過的點（從 $S$ 出發到達不了）\n\n所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？\n（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\n#define maxN 5005\n\nvector < int > edges[maxN];\nint pa[maxN];\nbool used[maxN];\n\nvoid dfs ( int n, int p ){\n    used[n] = true;\n    pa[n] = p;\n    for ( auto i: edges[n] ){\n        if ( used[i] )\n            continue;\n        dfs ( i, p );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, s, u, v;\n    cin >> n >> m >> s;\n    while ( m-- ){\n        cin >> u >> v;\n        edges[u].push_back ( v );\n    }\n\n    dfs ( s, s );\n    for ( int i = 1 ; i <= n ; i++ ){\n        if ( pa[i] == 0 ){\n            memset ( used, 0, sizeof used );\n            dfs ( i, i );\n        }\n    }\n\n    set < int > lib;\n    for ( int i = 1 ; i <= n ; i++ ){\n        if ( pa[i] != s )\n            lib.insert ( pa[i] );\n    }\n\n    cout << lib.size() << '\\n';\n}\n```\n\n## tips\n\n可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？\n\n是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？\n\n又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到\n所以即便 pa 被覆寫了也是沒有關係的","source":"_posts/CF-999E.md","raw":"---\ntitle: '[CF][999E] E. REACHABILITY FROM THE CAPITAL'\ndate: 2018-08-03 22:47:34\ntags:\n - CodeForces\n - div.3\n - graph\n - dfs\n---\n\n## 題目 + 解法\n\n這是 CodeForces Round 490 div.3 的題目\n最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人\n沒有意外下一場應該就會下來了吧\n先放上題目[連結](http://codeforces.com/problemset/problem/999/E)\n<!--more-->\n\n會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下\n今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）\n\n講一下題目大意好了\n首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$\n求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）\n\n有個很直觀的想法如下，首先點會先被分成兩種類型：\n1. 這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過\n2. 沒有經過的點（從 $S$ 出發到達不了）\n\n所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？\n（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\n#define maxN 5005\n\nvector < int > edges[maxN];\nint pa[maxN];\nbool used[maxN];\n\nvoid dfs ( int n, int p ){\n    used[n] = true;\n    pa[n] = p;\n    for ( auto i: edges[n] ){\n        if ( used[i] )\n            continue;\n        dfs ( i, p );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, s, u, v;\n    cin >> n >> m >> s;\n    while ( m-- ){\n        cin >> u >> v;\n        edges[u].push_back ( v );\n    }\n\n    dfs ( s, s );\n    for ( int i = 1 ; i <= n ; i++ ){\n        if ( pa[i] == 0 ){\n            memset ( used, 0, sizeof used );\n            dfs ( i, i );\n        }\n    }\n\n    set < int > lib;\n    for ( int i = 1 ; i <= n ; i++ ){\n        if ( pa[i] != s )\n            lib.insert ( pa[i] );\n    }\n\n    cout << lib.size() << '\\n';\n}\n```\n\n## tips\n\n可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？\n\n是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？\n\n又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到\n所以即便 pa 被覆寫了也是沒有關係的","slug":"CF-999E","published":1,"updated":"2020-05-03T11:24:07.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcs10002xl9pc18rciho","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 + 解法</h2><p>這是 CodeForces Round 490 div.3 的題目<br>最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人<br>沒有意外下一場應該就會下來了吧<br>先放上題目<a href=\"http://codeforces.com/problemset/problem/999/E\" target=\"_blank\" rel=\"noopener\">連結</a></p><a id=\"more\"></a><p>會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下<br>今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）</p><p>講一下題目大意好了<br>首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$<br>求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）</p><p>有個很直觀的想法如下，首先點會先被分成兩種類型：</p><ol><li>這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過</li><li>沒有經過的點（從 $S$ 出發到達不了）</li></ol><p>所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？<br>（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 5005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> pa[maxN];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> used[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    used[n] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    pa[n] = p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( used[i] )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs ( i, p );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, s, u, v;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        edges[u].push_back ( v );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs ( s, s );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( pa[i] == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">memset</span> ( used, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> used );</span><br><span class=\"line\">            dfs ( i, i );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( pa[i] != s )</span><br><span class=\"line\">            lib.insert ( pa[i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; lib.size() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"tips\"><a class=\"header-anchor\" href=\"#tips\"></a>tips</h2><p>可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？</p><p>是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？</p><p>又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到<br>所以即便 pa 被覆寫了也是沒有關係的</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 + 解法</h2><p>這是 CodeForces Round 490 div.3 的題目<br>最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人<br>沒有意外下一場應該就會下來了吧<br>先放上題目<a href=\"http://codeforces.com/problemset/problem/999/E\" target=\"_blank\" rel=\"noopener\">連結</a></p>","more":"<p>會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下<br>今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）</p><p>講一下題目大意好了<br>首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$<br>求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）</p><p>有個很直觀的想法如下，首先點會先被分成兩種類型：</p><ol><li>這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過</li><li>沒有經過的點（從 $S$ 出發到達不了）</li></ol><p>所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？<br>（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 5005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> pa[maxN];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> used[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    used[n] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    pa[n] = p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( used[i] )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs ( i, p );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, s, u, v;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">        edges[u].push_back ( v );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs ( s, s );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( pa[i] == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">memset</span> ( used, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> used );</span><br><span class=\"line\">            dfs ( i, i );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( pa[i] != s )</span><br><span class=\"line\">            lib.insert ( pa[i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; lib.size() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"tips\"><a class=\"header-anchor\" href=\"#tips\"></a>tips</h2><p>可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？</p><p>是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？</p><p>又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到<br>所以即便 pa 被覆寫了也是沒有關係的</p><!-- rebuild by neat -->"},{"title":"C語言中 char 字串轉換成數字","date":"2019-09-17T16:46:41.000Z","_content":"\n## 前言\n\n今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字\n<!--more-->\n\n## 方法\n\n1. 使用內建函數atoi\n2. 自己寫\n\n內建函數的用法可以去cpprefrence查到，所以這邊就不解說了\n只有講自己寫的做法\n\n## 原理\n\n如果要在一個數字的尾端加上一位數，該如何操作？\n有一種方法：先把原數字 * 10，然後再把那一位數加上去\n所以就可以有下面這種code\n\n```cpp\nint translate ( char *c, int len ){\n\tint i, res = 0;\n\tfor ( i = 0 ; i < len ; i++ ){\n\t\tres *= 10;\n\t\tres += ( c[i] - '0' );\n\t}\n\n\treturn res;\n}\n```\n\n然後解說一下code中第五行\nchar之間的相減就是ASCii code的值的差\n所以可以用這種方法把原本的數字還原出來","source":"_posts/C-atoi.md","raw":"---\ntitle: \"C語言中 char 字串轉換成數字\"\ndate: 2019-09-18 00:46:41\ntags:\n - C\n---\n\n## 前言\n\n今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字\n<!--more-->\n\n## 方法\n\n1. 使用內建函數atoi\n2. 自己寫\n\n內建函數的用法可以去cpprefrence查到，所以這邊就不解說了\n只有講自己寫的做法\n\n## 原理\n\n如果要在一個數字的尾端加上一位數，該如何操作？\n有一種方法：先把原數字 * 10，然後再把那一位數加上去\n所以就可以有下面這種code\n\n```cpp\nint translate ( char *c, int len ){\n\tint i, res = 0;\n\tfor ( i = 0 ; i < len ; i++ ){\n\t\tres *= 10;\n\t\tres += ( c[i] - '0' );\n\t}\n\n\treturn res;\n}\n```\n\n然後解說一下code中第五行\nchar之間的相減就是ASCii code的值的差\n所以可以用這種方法把原本的數字還原出來","slug":"C-atoi","published":1,"updated":"2020-05-03T11:24:07.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcs70005xl9p02a47hut","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字</p><a id=\"more\"></a><h2 id=\"方法\"><a class=\"header-anchor\" href=\"#方法\"></a>方法</h2><ol><li>使用內建函數atoi</li><li>自己寫</li></ol><p>內建函數的用法可以去cpprefrence查到，所以這邊就不解說了<br>只有講自己寫的做法</p><h2 id=\"原理\"><a class=\"header-anchor\" href=\"#原理\"></a>原理</h2><p>如果要在一個數字的尾端加上一位數，該如何操作？<br>有一種方法：先把原數字 * 10，然後再把那一位數加上去<br>所以就可以有下面這種code</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">translate</span> <span class=\"params\">( <span class=\"keyword\">char</span> *c, <span class=\"keyword\">int</span> len )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">\t\tres *= <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tres += ( c[i] - <span class=\"string\">'0'</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然後解說一下code中第五行<br>char之間的相減就是ASCii code的值的差<br>所以可以用這種方法把原本的數字還原出來</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字</p>","more":"<h2 id=\"方法\"><a class=\"header-anchor\" href=\"#方法\"></a>方法</h2><ol><li>使用內建函數atoi</li><li>自己寫</li></ol><p>內建函數的用法可以去cpprefrence查到，所以這邊就不解說了<br>只有講自己寫的做法</p><h2 id=\"原理\"><a class=\"header-anchor\" href=\"#原理\"></a>原理</h2><p>如果要在一個數字的尾端加上一位數，該如何操作？<br>有一種方法：先把原數字 * 10，然後再把那一位數加上去<br>所以就可以有下面這種code</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">translate</span> <span class=\"params\">( <span class=\"keyword\">char</span> *c, <span class=\"keyword\">int</span> len )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">\t\tres *= <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\tres += ( c[i] - <span class=\"string\">'0'</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然後解說一下code中第五行<br>char之間的相減就是ASCii code的值的差<br>所以可以用這種方法把原本的數字還原出來</p><!-- rebuild by neat -->"},{"title":"[APCS] 2019年六月場實作題詳解","date":"2019-06-24T09:44:23.000Z","_content":"\n## 前言\n\n因為想要拼5 + 5，於是又報名了這次的APCS\n至於成績如何那就晚點再說吧，算是個小伏筆（？\n\n<!--more-->\n\n即便考場在家附近，我還是提早出門了\n還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎\n趕快google一下才發現跑錯棚了，應該是在校區的另一邊\n所以我又趕快跑過去，差一點點遲到\n好險有提早出門（汗\n\n{% asset_img img.jpg \"因為不想要縮圖是我的成績單，所以我就放這張圖了\" %}\n\n## problem 1\n\n### 題目\n\n給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節\n求出主場最終的輸贏\n\n1.  兩場全贏：勝\n2.  兩場全敗：敗\n3.  一勝一敗：平手\n\n保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題\n\n### 解法\n\n直接實作一下就好了\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int a = 0, b = 0, ans = 0, swp;\n    for ( int i = 0 ; i < 4 ; i++ ){\n        cin >> swp;\n        a += swp;\n    }\n    for ( int i = 0 ; i < 4 ; i++ ){\n        cin >> swp;\n        b += swp;\n    }\n    ans += ( a > b ? 1 : -1 );\n\n\n    a = b = 0;\n    for ( int i = 1 ; i < 4 ; i++ ){\n        cin >> swp;\n        a += swp;\n    }\n    for ( int i = 1 ; i < 4 ; i++ ){\n        cin >> swp;\n        b += swp;\n    }\n    ans += ( a > b ? 1 : -1 );\n\n    if ( !ans )\n        cout << \"Draw\";\n    else if ( ans > 0 )\n        cout << \"Win\";\n    else\n        cout << \"Lose\";\n    cout << '\\n';\n}\n```\n\n## problem 2\n\n### 題目\n\n給定一張圖，起點為整張圖權重最小的點\n並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點\n然後路徑上點不能重複\n求出路徑的總權重\n\n### 解法\n\ndfs裸題，UVa有類似的題目（題號我忘記了\n反正就是模擬一次就對了（也沒有其他解法啊(ry\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 105; // 大小我忘記了\nconst int INF = 0x3f3f3f3f; // INF大於值域，又可直接memset，方便又實用\ntypedef long long LL;\n\nint mp[maxN][maxN];\n\nLL dfs ( int x, int y, LL sum ){\n    // 先找出最低點\n    int mi = min ( min ( mp[x + 1][y], mp[x - 1][y] ), min ( mp[x][y + 1], mp[x][y - 1] ) );\n    sum += mp[x][y];\n    mp[x][y] = INF;\n    if ( mi == INF )\n        return sum;\n    if ( mp[x + 1][y] == mi )\n        return dfs ( x + 1, y, sum );\n    if ( mp[x - 1][y] == mi )\n        return dfs ( x - 1, y, sum );\n    if ( mp[x][y + 1] == mi )\n        return dfs ( x, y + 1, sum );\n    if ( mp[x][y - 1] == mi )\n        return dfs ( x, y - 1, sum );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, x, y, mi = INF;\n    memset ( mp, INF, sizeof mp );\n    cin >> n >> m;\n    // 1 index，可以直接免去判斷邊界的麻煩\n    for ( int i = 1 ; i <= n ; i++ )\n        for ( int j = 1 ; j <= m ; j++ ){\n            cin >> mp[i][j];\n            if ( mi > mp[i][j] )\n                mi = mp[i][j], x = i, y = j;\n        }\n\n    cout << dfs ( x, y, 0 ) << '\\n';\n}\n```\n\n\n## problem 3\n\n### 題目\n\n給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始\n請求出每一對可以組成互補字串的數量\n且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列\n所以$AAB$與$AB$與$BA$都是相同的字串\n\n#### 定義一下互補字串\n\n假設字串$A$中的元素沒有出現在字串$B$中\n同時，字串$B$的元素也沒有出現在字串$A$中\n則稱$A \\text& B$為互補字串\n\n### 解法\n\n#### 解法一：硬幹\n\n##### 說明\n\n之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的\n\n##### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n#define F first\n#define S second\n\nusing namespace std;\n\nmap < string, int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    string str, basic;\n    char c = 'A';\n    cin >> n >> m;\n    for ( int i = 0 ; i < m ; i++, c++ )\n        basic += c;\n    while ( n-- ){\n        cin >> str;\n        // 這邊為了要把順序都統一，所以先做一下排序\n        sort ( str.begin(), str.end() );\n        // 這邊則是要把重複的字元壓掉\n        str.erase ( unique ( str.begin(), str.end() ), str.end() );\n        lib[str]++;\n    }\n\n    for ( auto j: lib ){\n        str = basic;\n        // 把出現過的直接刪掉\n        for ( auto i: j.F )\n            str.erase ( lower_bound ( str.begin(), str.end(), i ) );\n        ans += j.S * lib[str];\n    }\n\n    // 因為會重複計算到兩次    \n    ans /= 2;\n    cout << ans << '\\n';\n}\n```\n\n#### 方法二：Xor\n\n##### 說明\n\n因為原本的方法太智障了（？\n如果不是因為資料量小可以這樣做，資料量一大直接吃土\n\n出來之後聽到有人是這樣做的，有點類似Hash的做法\n把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$\n然後為了方便運算會把這個二進位reverse\n\n也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$\n然後再把二進位轉成十進位\n這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串\n\n##### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n#define F first\n#define S second\n\nusing namespace std;\n\nmap < int, int > lib;\n\ninline int translate ( string str ){\n    int res = 0;\n    for ( auto i: str )\n        res |= ( 1 << ( i - 'A' ) );\n\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0, ori = 0;\n    string str;\n    cin >> n >> m;\n    for ( int i = 0 ; i < m ; i++ )\n        ori |= ( 1 << i );\n    while ( n-- ){\n        cin >> str;\n        // 這邊為了要把順序都統一，所以先做一下排序\n        sort ( str.begin(), str.end() );\n        // 這邊則是要把重複的字元壓掉\n        str.erase ( unique ( str.begin(), str.end() ), str.end() );\n        lib[translate ( str )]++;\n    }\n\n    for ( auto j: lib )\n        ans += ( j.S * lib[ori ^ j.F] );\n\n    // 因為會重複計算到兩次    \n    ans >>= 1;\n    cout << ans << '\\n';\n}\n```\n**注意，這份code並沒有經過詳細測試，可能有誤**\n\n\n## problem 4\n\n### 題目\n\n給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量\n\n### 解法\n\nSlide Window裸題，不過關於實作又有兩種做法\n\n#### 方法一：固定Window大小\n\n把window大小固定為$M$，並且開一個set紀錄這個window的數字\n要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過\n然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了\n\n#### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 100005;\n\nint cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    cin >> n >> m;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    // 離散化\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    for ( auto &i: data )\n        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();\n\n    queue < int > q;\n    set < int > s;\n    for ( int i = 0 ; i < n ; i++ ){\n        q.push ( data[i] );\n        s.insert ( data[i] );\n        cnt[data[i]]++;\n        if ( q.size() >= m ){\n            cnt[q.front()]--;\n            if ( !cnt[q.front()] )\n                s.erase ( q.front() );\n            q.pop();\n        }\n        if ( s.size() == m )\n            ans++;\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n#### 方法二：不固定的window大小\n\n此方法由吳邦一教授提出（[原文連結](https://brian.su/r/APCS-2019-06-P4)）\n由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止\n\n#### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 100005;\n\nint cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    cin >> n >> m;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    // 離散化\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    for ( auto &i: data )\n        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();\n\n    // 這邊的話就不用set了    \n    queue < int > q;\n    for ( int i = 0 ; i < n ; i++ ){\n        // 不斷pop直到這個數字前面沒有出現過\n        while ( !q.empty() && cnt[data[i]] ){\n            cnt[q.front()]--;\n            q.pop();\n        }\n        q.push ( data[i] );\n        cnt[data[i]]++;\n        if ( q.size() == m )\n            ans++;\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n\n## 後記\n\n其實我把所有題目寫完之後，大概才過41分鐘\n然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug\n接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到\n也就是說，我在裡面燒機燒了一個半小時然後產量是零\n抓到，澪人桐是燒機大師\n早就知道出來玩手機算了 = =\n\n.\n\n看到這邊多多少少都會對我的成績有點興趣吧（？\n（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛\n話不多說我直接上圖好了\n\n![](score.png)\n\n差一題觀念5+5\n搞什麼 = =\n\n以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼\n（欸，差不多是一年前的六月場欸OAO\n\n雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜\n那麼今天就到這邊了，謝謝各位今天的閱讀\n如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我\n我的email可以在我的[個人頁面](https://miohitokiri5474.github.io/code/about/)找到\np.s. 我今天寫好長的文章喔，到這邊已經430行了\n\n本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行\n所以原本的文章看起來很很空\n還需要自己手動調整，有點小麻煩\n不過他可以即時顯示md的渲染結果，真的讓人難以抉擇\n\n## 更新（2019/07/04 10:28）\n\n之前可以查詢成績好像是bug，官方是說今天早上十點才可以查\n剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）\n\n{% asset_img per.png \"2019年六月場級距\" %}\n\n## 圖片出處\n1. 紅色鳥居：神奈川縣蘆之湖[kaji_nori06](https://www.instagram.com/kaji_nori06/)\n2. 成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧\n3. 級距。。。啊就從成績單上截圖截下來的啊 = =","source":"_posts/APCS-19-06.md","raw":"---\ntitle: '[APCS] 2019年六月場實作題詳解'\ndate: 2019-06-24 17:44:23\ntags:\n - APCS\n - Full Contest Solution\n---\n\n## 前言\n\n因為想要拼5 + 5，於是又報名了這次的APCS\n至於成績如何那就晚點再說吧，算是個小伏筆（？\n\n<!--more-->\n\n即便考場在家附近，我還是提早出門了\n還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎\n趕快google一下才發現跑錯棚了，應該是在校區的另一邊\n所以我又趕快跑過去，差一點點遲到\n好險有提早出門（汗\n\n{% asset_img img.jpg \"因為不想要縮圖是我的成績單，所以我就放這張圖了\" %}\n\n## problem 1\n\n### 題目\n\n給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節\n求出主場最終的輸贏\n\n1.  兩場全贏：勝\n2.  兩場全敗：敗\n3.  一勝一敗：平手\n\n保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題\n\n### 解法\n\n直接實作一下就好了\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int a = 0, b = 0, ans = 0, swp;\n    for ( int i = 0 ; i < 4 ; i++ ){\n        cin >> swp;\n        a += swp;\n    }\n    for ( int i = 0 ; i < 4 ; i++ ){\n        cin >> swp;\n        b += swp;\n    }\n    ans += ( a > b ? 1 : -1 );\n\n\n    a = b = 0;\n    for ( int i = 1 ; i < 4 ; i++ ){\n        cin >> swp;\n        a += swp;\n    }\n    for ( int i = 1 ; i < 4 ; i++ ){\n        cin >> swp;\n        b += swp;\n    }\n    ans += ( a > b ? 1 : -1 );\n\n    if ( !ans )\n        cout << \"Draw\";\n    else if ( ans > 0 )\n        cout << \"Win\";\n    else\n        cout << \"Lose\";\n    cout << '\\n';\n}\n```\n\n## problem 2\n\n### 題目\n\n給定一張圖，起點為整張圖權重最小的點\n並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點\n然後路徑上點不能重複\n求出路徑的總權重\n\n### 解法\n\ndfs裸題，UVa有類似的題目（題號我忘記了\n反正就是模擬一次就對了（也沒有其他解法啊(ry\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 105; // 大小我忘記了\nconst int INF = 0x3f3f3f3f; // INF大於值域，又可直接memset，方便又實用\ntypedef long long LL;\n\nint mp[maxN][maxN];\n\nLL dfs ( int x, int y, LL sum ){\n    // 先找出最低點\n    int mi = min ( min ( mp[x + 1][y], mp[x - 1][y] ), min ( mp[x][y + 1], mp[x][y - 1] ) );\n    sum += mp[x][y];\n    mp[x][y] = INF;\n    if ( mi == INF )\n        return sum;\n    if ( mp[x + 1][y] == mi )\n        return dfs ( x + 1, y, sum );\n    if ( mp[x - 1][y] == mi )\n        return dfs ( x - 1, y, sum );\n    if ( mp[x][y + 1] == mi )\n        return dfs ( x, y + 1, sum );\n    if ( mp[x][y - 1] == mi )\n        return dfs ( x, y - 1, sum );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, x, y, mi = INF;\n    memset ( mp, INF, sizeof mp );\n    cin >> n >> m;\n    // 1 index，可以直接免去判斷邊界的麻煩\n    for ( int i = 1 ; i <= n ; i++ )\n        for ( int j = 1 ; j <= m ; j++ ){\n            cin >> mp[i][j];\n            if ( mi > mp[i][j] )\n                mi = mp[i][j], x = i, y = j;\n        }\n\n    cout << dfs ( x, y, 0 ) << '\\n';\n}\n```\n\n\n## problem 3\n\n### 題目\n\n給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始\n請求出每一對可以組成互補字串的數量\n且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列\n所以$AAB$與$AB$與$BA$都是相同的字串\n\n#### 定義一下互補字串\n\n假設字串$A$中的元素沒有出現在字串$B$中\n同時，字串$B$的元素也沒有出現在字串$A$中\n則稱$A \\text& B$為互補字串\n\n### 解法\n\n#### 解法一：硬幹\n\n##### 說明\n\n之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的\n\n##### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n#define F first\n#define S second\n\nusing namespace std;\n\nmap < string, int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    string str, basic;\n    char c = 'A';\n    cin >> n >> m;\n    for ( int i = 0 ; i < m ; i++, c++ )\n        basic += c;\n    while ( n-- ){\n        cin >> str;\n        // 這邊為了要把順序都統一，所以先做一下排序\n        sort ( str.begin(), str.end() );\n        // 這邊則是要把重複的字元壓掉\n        str.erase ( unique ( str.begin(), str.end() ), str.end() );\n        lib[str]++;\n    }\n\n    for ( auto j: lib ){\n        str = basic;\n        // 把出現過的直接刪掉\n        for ( auto i: j.F )\n            str.erase ( lower_bound ( str.begin(), str.end(), i ) );\n        ans += j.S * lib[str];\n    }\n\n    // 因為會重複計算到兩次    \n    ans /= 2;\n    cout << ans << '\\n';\n}\n```\n\n#### 方法二：Xor\n\n##### 說明\n\n因為原本的方法太智障了（？\n如果不是因為資料量小可以這樣做，資料量一大直接吃土\n\n出來之後聽到有人是這樣做的，有點類似Hash的做法\n把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$\n然後為了方便運算會把這個二進位reverse\n\n也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$\n然後再把二進位轉成十進位\n這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串\n\n##### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n#define F first\n#define S second\n\nusing namespace std;\n\nmap < int, int > lib;\n\ninline int translate ( string str ){\n    int res = 0;\n    for ( auto i: str )\n        res |= ( 1 << ( i - 'A' ) );\n\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0, ori = 0;\n    string str;\n    cin >> n >> m;\n    for ( int i = 0 ; i < m ; i++ )\n        ori |= ( 1 << i );\n    while ( n-- ){\n        cin >> str;\n        // 這邊為了要把順序都統一，所以先做一下排序\n        sort ( str.begin(), str.end() );\n        // 這邊則是要把重複的字元壓掉\n        str.erase ( unique ( str.begin(), str.end() ), str.end() );\n        lib[translate ( str )]++;\n    }\n\n    for ( auto j: lib )\n        ans += ( j.S * lib[ori ^ j.F] );\n\n    // 因為會重複計算到兩次    \n    ans >>= 1;\n    cout << ans << '\\n';\n}\n```\n**注意，這份code並沒有經過詳細測試，可能有誤**\n\n\n## problem 4\n\n### 題目\n\n給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量\n\n### 解法\n\nSlide Window裸題，不過關於實作又有兩種做法\n\n#### 方法一：固定Window大小\n\n把window大小固定為$M$，並且開一個set紀錄這個window的數字\n要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過\n然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了\n\n#### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 100005;\n\nint cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    cin >> n >> m;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    // 離散化\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    for ( auto &i: data )\n        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();\n\n    queue < int > q;\n    set < int > s;\n    for ( int i = 0 ; i < n ; i++ ){\n        q.push ( data[i] );\n        s.insert ( data[i] );\n        cnt[data[i]]++;\n        if ( q.size() >= m ){\n            cnt[q.front()]--;\n            if ( !cnt[q.front()] )\n                s.erase ( q.front() );\n            q.pop();\n        }\n        if ( s.size() == m )\n            ans++;\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n#### 方法二：不固定的window大小\n\n此方法由吳邦一教授提出（[原文連結](https://brian.su/r/APCS-2019-06-P4)）\n由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止\n\n#### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxN = 100005;\n\nint cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, ans = 0;\n    cin >> n >> m;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    // 離散化\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    for ( auto &i: data )\n        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();\n\n    // 這邊的話就不用set了    \n    queue < int > q;\n    for ( int i = 0 ; i < n ; i++ ){\n        // 不斷pop直到這個數字前面沒有出現過\n        while ( !q.empty() && cnt[data[i]] ){\n            cnt[q.front()]--;\n            q.pop();\n        }\n        q.push ( data[i] );\n        cnt[data[i]]++;\n        if ( q.size() == m )\n            ans++;\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n\n## 後記\n\n其實我把所有題目寫完之後，大概才過41分鐘\n然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug\n接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到\n也就是說，我在裡面燒機燒了一個半小時然後產量是零\n抓到，澪人桐是燒機大師\n早就知道出來玩手機算了 = =\n\n.\n\n看到這邊多多少少都會對我的成績有點興趣吧（？\n（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛\n話不多說我直接上圖好了\n\n![](score.png)\n\n差一題觀念5+5\n搞什麼 = =\n\n以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼\n（欸，差不多是一年前的六月場欸OAO\n\n雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜\n那麼今天就到這邊了，謝謝各位今天的閱讀\n如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我\n我的email可以在我的[個人頁面](https://miohitokiri5474.github.io/code/about/)找到\np.s. 我今天寫好長的文章喔，到這邊已經430行了\n\n本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行\n所以原本的文章看起來很很空\n還需要自己手動調整，有點小麻煩\n不過他可以即時顯示md的渲染結果，真的讓人難以抉擇\n\n## 更新（2019/07/04 10:28）\n\n之前可以查詢成績好像是bug，官方是說今天早上十點才可以查\n剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）\n\n{% asset_img per.png \"2019年六月場級距\" %}\n\n## 圖片出處\n1. 紅色鳥居：神奈川縣蘆之湖[kaji_nori06](https://www.instagram.com/kaji_nori06/)\n2. 成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧\n3. 級距。。。啊就從成績單上截圖截下來的啊 = =","slug":"APCS-19-06","published":1,"updated":"2020-05-03T11:24:07.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsc0006xl9php5lb5yb","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>因為想要拼5 + 5，於是又報名了這次的APCS<br>至於成績如何那就晚點再說吧，算是個小伏筆（？</p><a id=\"more\"></a><p>即便考場在家附近，我還是提早出門了<br>還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎<br>趕快google一下才發現跑錯棚了，應該是在校區的另一邊<br>所以我又趕快跑過去，差一點點遲到<br>好險有提早出門（汗</p><img src=\"/code/APCS-19-06/img.jpg\" title=\"因為不想要縮圖是我的成績單，所以我就放這張圖了\"><h2 id=\"problem-1\"><a class=\"header-anchor\" href=\"#problem-1\"></a>problem 1</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節<br>求出主場最終的輸贏</p><ol><li>兩場全贏：勝</li><li>兩場全敗：敗</li><li>一勝一敗：平手</li></ol><p>保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>直接實作一下就好了</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>, swp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        a += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        b += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans += ( a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        a += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        b += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans += ( a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !ans )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Draw\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( ans &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Win\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lose\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-2\"><a class=\"header-anchor\" href=\"#problem-2\"></a>problem 2</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一張圖，起點為整張圖權重最小的點<br>並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點<br>然後路徑上點不能重複<br>求出路徑的總權重</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>dfs裸題，UVa有類似的題目（題號我忘記了<br>反正就是模擬一次就對了（也沒有其他解法啊(ry</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">105</span>; <span class=\"comment\">// 大小我忘記了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>; <span class=\"comment\">// INF大於值域，又可直接memset，方便又實用</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> mp[maxN][maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, LL sum )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先找出最低點</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mi = min ( min ( mp[x + <span class=\"number\">1</span>][y], mp[x - <span class=\"number\">1</span>][y] ), min ( mp[x][y + <span class=\"number\">1</span>], mp[x][y - <span class=\"number\">1</span>] ) );</span><br><span class=\"line\">    sum += mp[x][y];</span><br><span class=\"line\">    mp[x][y] = INF;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mi == INF )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x + <span class=\"number\">1</span>][y] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x + <span class=\"number\">1</span>, y, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x - <span class=\"number\">1</span>][y] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x - <span class=\"number\">1</span>, y, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x][y + <span class=\"number\">1</span>] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x, y + <span class=\"number\">1</span>, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x][y - <span class=\"number\">1</span>] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x, y - <span class=\"number\">1</span>, sum );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, x, y, mi = INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span> ( mp, INF, <span class=\"keyword\">sizeof</span> mp );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"comment\">// 1 index，可以直接免去判斷邊界的麻煩</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">1</span> ; j &lt;= m ; j++ )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; mp[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( mi &gt; mp[i][j] )</span><br><span class=\"line\">                mi = mp[i][j], x = i, y = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; dfs ( x, y, <span class=\"number\">0</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-3\"><a class=\"header-anchor\" href=\"#problem-3\"></a>problem 3</h2><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始<br>請求出每一對可以組成互補字串的數量<br>且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列<br>所以$AAB$與$AB$與$BA$都是相同的字串</p><h4 id=\"定義一下互補字串\"><a class=\"header-anchor\" href=\"#定義一下互補字串\"></a>定義一下互補字串</h4><p>假設字串$A$中的元素沒有出現在字串$B$中<br>同時，字串$B$的元素也沒有出現在字串$A$中<br>則稱$A \\text&amp; B$為互補字串</p><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><h4 id=\"解法一：硬幹\"><a class=\"header-anchor\" href=\"#解法一：硬幹\"></a>解法一：硬幹</h4><h5 id=\"說明\"><a class=\"header-anchor\" href=\"#說明\"></a>說明</h5><p>之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的</p><h5 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"built_in\">string</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str, basic;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++, c++ )</span><br><span class=\"line\">        basic += c;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( n-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"comment\">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class=\"line\">        sort ( str.begin(), str.end() );</span><br><span class=\"line\">        <span class=\"comment\">// 這邊則是要把重複的字元壓掉</span></span><br><span class=\"line\">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class=\"line\">        lib[str]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: lib )&#123;</span><br><span class=\"line\">        str = basic;</span><br><span class=\"line\">        <span class=\"comment\">// 把出現過的直接刪掉</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: j.F )</span><br><span class=\"line\">            str.erase ( lower_bound ( str.begin(), str.end(), i ) );</span><br><span class=\"line\">        ans += j.S * lib[str];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因為會重複計算到兩次    </span></span><br><span class=\"line\">    ans /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：Xor\"><a class=\"header-anchor\" href=\"#方法二：Xor\"></a>方法二：Xor</h4><h5 id=\"說明-v2\"><a class=\"header-anchor\" href=\"#說明-v2\"></a>說明</h5><p>因為原本的方法太智障了（？<br>如果不是因為資料量小可以這樣做，資料量一大直接吃土</p><p>出來之後聽到有人是這樣做的，有點類似Hash的做法<br>把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$<br>然後為了方便運算會把這個二進位reverse</p><p>也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$<br>然後再把二進位轉成十進位<br>這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串</p><h5 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">translate</span> <span class=\"params\">( <span class=\"built_in\">string</span> str )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )</span><br><span class=\"line\">        res |= ( <span class=\"number\">1</span> &lt;&lt; ( i - <span class=\"string\">'A'</span> ) );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>, ori = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )</span><br><span class=\"line\">        ori |= ( <span class=\"number\">1</span> &lt;&lt; i );</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( n-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"comment\">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class=\"line\">        sort ( str.begin(), str.end() );</span><br><span class=\"line\">        <span class=\"comment\">// 這邊則是要把重複的字元壓掉</span></span><br><span class=\"line\">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class=\"line\">        lib[translate ( str )]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: lib )</span><br><span class=\"line\">        ans += ( j.S * lib[ori ^ j.F] );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因為會重複計算到兩次    </span></span><br><span class=\"line\">    ans &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，這份code並沒有經過詳細測試，可能有誤</strong></p><h2 id=\"problem-4\"><a class=\"header-anchor\" href=\"#problem-4\"></a>problem 4</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量</p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>Slide Window裸題，不過關於實作又有兩種做法</p><h4 id=\"方法一：固定Window大小\"><a class=\"header-anchor\" href=\"#方法一：固定Window大小\"></a>方法一：固定Window大小</h4><p>把window大小固定為$M$，並且開一個set紀錄這個window的數字<br>要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過<br>然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了</p><h4 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"comment\">// 離散化</span></span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> &lt; <span class=\"keyword\">int</span> &gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        q.push ( data[i] );</span><br><span class=\"line\">        s.insert ( data[i] );</span><br><span class=\"line\">        cnt[data[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( q.size() &gt;= m )&#123;</span><br><span class=\"line\">            cnt[q.front()]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !cnt[q.front()] )</span><br><span class=\"line\">                s.erase ( q.front() );</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( s.size() == m )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：不固定的window大小\"><a class=\"header-anchor\" href=\"#方法二：不固定的window大小\"></a>方法二：不固定的window大小</h4><p>此方法由吳邦一教授提出（<a href=\"https://brian.su/r/APCS-2019-06-P4\" target=\"_blank\" rel=\"noopener\">原文連結</a>）<br>由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止</p><h4 id=\"code-v6\"><a class=\"header-anchor\" href=\"#code-v6\"></a>code</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"comment\">// 離散化</span></span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 這邊的話就不用set了    </span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> &lt; <span class=\"keyword\">int</span> &gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不斷pop直到這個數字前面沒有出現過</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( !q.empty() &amp;&amp; cnt[data[i]] )&#123;</span><br><span class=\"line\">            cnt[q.front()]--;</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.push ( data[i] );</span><br><span class=\"line\">        cnt[data[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( q.size() == m )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>其實我把所有題目寫完之後，大概才過41分鐘<br>然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug<br>接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到<br>也就是說，我在裡面燒機燒了一個半小時然後產量是零<br>抓到，澪人桐是燒機大師<br>早就知道出來玩手機算了 = =</p><p>.</p><p>看到這邊多多少少都會對我的成績有點興趣吧（？<br>（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛<br>話不多說我直接上圖好了</p><p><img src=\"score.png\" alt=\"\"></p><p>差一題觀念5+5<br>搞什麼 = =</p><p>以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼<br>（欸，差不多是一年前的六月場欸OAO</p><p>雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜<br>那麼今天就到這邊了，謝謝各位今天的閱讀<br>如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我<br>我的email可以在我的<a href=\"https://miohitokiri5474.github.io/code/about/\">個人頁面</a>找到<br>p.s. 我今天寫好長的文章喔，到這邊已經430行了</p><p>本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行<br>所以原本的文章看起來很很空<br>還需要自己手動調整，有點小麻煩<br>不過他可以即時顯示md的渲染結果，真的讓人難以抉擇</p><h2 id=\"更新（2019-07-04-10-28）\"><a class=\"header-anchor\" href=\"#更新（2019-07-04-10-28）\"></a>更新（2019/07/04 10:28）</h2><p>之前可以查詢成績好像是bug，官方是說今天早上十點才可以查<br>剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）</p><img src=\"/code/APCS-19-06/per.png\" title=\"2019年六月場級距\"><h2 id=\"圖片出處\"><a class=\"header-anchor\" href=\"#圖片出處\"></a>圖片出處</h2><ol><li>紅色鳥居：神奈川縣蘆之湖<a href=\"https://www.instagram.com/kaji_nori06/\" target=\"_blank\" rel=\"noopener\">kaji_nori06</a></li><li>成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧</li><li>級距。。。啊就從成績單上截圖截下來的啊 = =</li></ol><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>因為想要拼5 + 5，於是又報名了這次的APCS<br>至於成績如何那就晚點再說吧，算是個小伏筆（？</p>","more":"<p>即便考場在家附近，我還是提早出門了<br>還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎<br>趕快google一下才發現跑錯棚了，應該是在校區的另一邊<br>所以我又趕快跑過去，差一點點遲到<br>好險有提早出門（汗</p><img src=\"/code/APCS-19-06/img.jpg\" title=\"因為不想要縮圖是我的成績單，所以我就放這張圖了\"><h2 id=\"problem-1\"><a class=\"header-anchor\" href=\"#problem-1\"></a>problem 1</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節<br>求出主場最終的輸贏</p><ol><li>兩場全贏：勝</li><li>兩場全敗：敗</li><li>一勝一敗：平手</li></ol><p>保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>直接實作一下就好了</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>, swp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        a += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        b += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans += ( a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    a = b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        a += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; <span class=\"number\">4</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; swp;</span><br><span class=\"line\">        b += swp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans += ( a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !ans )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Draw\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( ans &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Win\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lose\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-2\"><a class=\"header-anchor\" href=\"#problem-2\"></a>problem 2</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一張圖，起點為整張圖權重最小的點<br>並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點<br>然後路徑上點不能重複<br>求出路徑的總權重</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>dfs裸題，UVa有類似的題目（題號我忘記了<br>反正就是模擬一次就對了（也沒有其他解法啊(ry</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">105</span>; <span class=\"comment\">// 大小我忘記了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>; <span class=\"comment\">// INF大於值域，又可直接memset，方便又實用</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> mp[maxN][maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LL <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, LL sum )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先找出最低點</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mi = min ( min ( mp[x + <span class=\"number\">1</span>][y], mp[x - <span class=\"number\">1</span>][y] ), min ( mp[x][y + <span class=\"number\">1</span>], mp[x][y - <span class=\"number\">1</span>] ) );</span><br><span class=\"line\">    sum += mp[x][y];</span><br><span class=\"line\">    mp[x][y] = INF;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mi == INF )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x + <span class=\"number\">1</span>][y] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x + <span class=\"number\">1</span>, y, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x - <span class=\"number\">1</span>][y] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x - <span class=\"number\">1</span>, y, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x][y + <span class=\"number\">1</span>] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x, y + <span class=\"number\">1</span>, sum );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mp[x][y - <span class=\"number\">1</span>] == mi )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs ( x, y - <span class=\"number\">1</span>, sum );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, x, y, mi = INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span> ( mp, INF, <span class=\"keyword\">sizeof</span> mp );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"comment\">// 1 index，可以直接免去判斷邊界的麻煩</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">1</span> ; j &lt;= m ; j++ )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; mp[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( mi &gt; mp[i][j] )</span><br><span class=\"line\">                mi = mp[i][j], x = i, y = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; dfs ( x, y, <span class=\"number\">0</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-3\"><a class=\"header-anchor\" href=\"#problem-3\"></a>problem 3</h2><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始<br>請求出每一對可以組成互補字串的數量<br>且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列<br>所以$AAB$與$AB$與$BA$都是相同的字串</p><h4 id=\"定義一下互補字串\"><a class=\"header-anchor\" href=\"#定義一下互補字串\"></a>定義一下互補字串</h4><p>假設字串$A$中的元素沒有出現在字串$B$中<br>同時，字串$B$的元素也沒有出現在字串$A$中<br>則稱$A \\text&amp; B$為互補字串</p><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><h4 id=\"解法一：硬幹\"><a class=\"header-anchor\" href=\"#解法一：硬幹\"></a>解法一：硬幹</h4><h5 id=\"說明\"><a class=\"header-anchor\" href=\"#說明\"></a>說明</h5><p>之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的</p><h5 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"built_in\">string</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str, basic;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++, c++ )</span><br><span class=\"line\">        basic += c;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( n-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"comment\">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class=\"line\">        sort ( str.begin(), str.end() );</span><br><span class=\"line\">        <span class=\"comment\">// 這邊則是要把重複的字元壓掉</span></span><br><span class=\"line\">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class=\"line\">        lib[str]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: lib )&#123;</span><br><span class=\"line\">        str = basic;</span><br><span class=\"line\">        <span class=\"comment\">// 把出現過的直接刪掉</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: j.F )</span><br><span class=\"line\">            str.erase ( lower_bound ( str.begin(), str.end(), i ) );</span><br><span class=\"line\">        ans += j.S * lib[str];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因為會重複計算到兩次    </span></span><br><span class=\"line\">    ans /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：Xor\"><a class=\"header-anchor\" href=\"#方法二：Xor\"></a>方法二：Xor</h4><h5 id=\"說明-v2\"><a class=\"header-anchor\" href=\"#說明-v2\"></a>說明</h5><p>因為原本的方法太智障了（？<br>如果不是因為資料量小可以這樣做，資料量一大直接吃土</p><p>出來之後聽到有人是這樣做的，有點類似Hash的做法<br>把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$<br>然後為了方便運算會把這個二進位reverse</p><p>也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$<br>然後再把二進位轉成十進位<br>這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串</p><h5 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">translate</span> <span class=\"params\">( <span class=\"built_in\">string</span> str )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )</span><br><span class=\"line\">        res |= ( <span class=\"number\">1</span> &lt;&lt; ( i - <span class=\"string\">'A'</span> ) );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>, ori = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )</span><br><span class=\"line\">        ori |= ( <span class=\"number\">1</span> &lt;&lt; i );</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( n-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"comment\">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class=\"line\">        sort ( str.begin(), str.end() );</span><br><span class=\"line\">        <span class=\"comment\">// 這邊則是要把重複的字元壓掉</span></span><br><span class=\"line\">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class=\"line\">        lib[translate ( str )]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: lib )</span><br><span class=\"line\">        ans += ( j.S * lib[ori ^ j.F] );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因為會重複計算到兩次    </span></span><br><span class=\"line\">    ans &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，這份code並沒有經過詳細測試，可能有誤</strong></p><h2 id=\"problem-4\"><a class=\"header-anchor\" href=\"#problem-4\"></a>problem 4</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量</p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>Slide Window裸題，不過關於實作又有兩種做法</p><h4 id=\"方法一：固定Window大小\"><a class=\"header-anchor\" href=\"#方法一：固定Window大小\"></a>方法一：固定Window大小</h4><p>把window大小固定為$M$，並且開一個set紀錄這個window的數字<br>要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過<br>然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了</p><h4 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"comment\">// 離散化</span></span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> &lt; <span class=\"keyword\">int</span> &gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; s;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        q.push ( data[i] );</span><br><span class=\"line\">        s.insert ( data[i] );</span><br><span class=\"line\">        cnt[data[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( q.size() &gt;= m )&#123;</span><br><span class=\"line\">            cnt[q.front()]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !cnt[q.front()] )</span><br><span class=\"line\">                s.erase ( q.front() );</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( s.size() == m )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：不固定的window大小\"><a class=\"header-anchor\" href=\"#方法二：不固定的window大小\"></a>方法二：不固定的window大小</h4><p>此方法由吳邦一教授提出（<a href=\"https://brian.su/r/APCS-2019-06-P4\" target=\"_blank\" rel=\"noopener\">原文連結</a>）<br>由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止</p><h4 id=\"code-v6\"><a class=\"header-anchor\" href=\"#code-v6\"></a>code</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> maxN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"comment\">// 離散化</span></span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 這邊的話就不用set了    </span></span><br><span class=\"line\">    <span class=\"built_in\">queue</span> &lt; <span class=\"keyword\">int</span> &gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不斷pop直到這個數字前面沒有出現過</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( !q.empty() &amp;&amp; cnt[data[i]] )&#123;</span><br><span class=\"line\">            cnt[q.front()]--;</span><br><span class=\"line\">            q.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.push ( data[i] );</span><br><span class=\"line\">        cnt[data[i]]++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( q.size() == m )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>其實我把所有題目寫完之後，大概才過41分鐘<br>然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug<br>接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到<br>也就是說，我在裡面燒機燒了一個半小時然後產量是零<br>抓到，澪人桐是燒機大師<br>早就知道出來玩手機算了 = =</p><p>.</p><p>看到這邊多多少少都會對我的成績有點興趣吧（？<br>（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛<br>話不多說我直接上圖好了</p><p><img src=\"score.png\" alt=\"\"></p><p>差一題觀念5+5<br>搞什麼 = =</p><p>以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼<br>（欸，差不多是一年前的六月場欸OAO</p><p>雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜<br>那麼今天就到這邊了，謝謝各位今天的閱讀<br>如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我<br>我的email可以在我的<a href=\"https://miohitokiri5474.github.io/code/about/\">個人頁面</a>找到<br>p.s. 我今天寫好長的文章喔，到這邊已經430行了</p><p>本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行<br>所以原本的文章看起來很很空<br>還需要自己手動調整，有點小麻煩<br>不過他可以即時顯示md的渲染結果，真的讓人難以抉擇</p><h2 id=\"更新（2019-07-04-10-28）\"><a class=\"header-anchor\" href=\"#更新（2019-07-04-10-28）\"></a>更新（2019/07/04 10:28）</h2><p>之前可以查詢成績好像是bug，官方是說今天早上十點才可以查<br>剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）</p><img src=\"/code/APCS-19-06/per.png\" title=\"2019年六月場級距\"><h2 id=\"圖片出處\"><a class=\"header-anchor\" href=\"#圖片出處\"></a>圖片出處</h2><ol><li>紅色鳥居：神奈川縣蘆之湖<a href=\"https://www.instagram.com/kaji_nori06/\" target=\"_blank\" rel=\"noopener\">kaji_nori06</a></li><li>成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧</li><li>級距。。。啊就從成績單上截圖截下來的啊 = =</li></ol><!-- rebuild by neat -->"},{"title":"[CF]Round 521","date":"2018-11-17T04:20:01.000Z","_content":"\n## 前言\n\n身為一個垃圾，當然要打的像垃圾一樣\n先是校內爆掉，現在換 div.3 爆掉\n。。。pC 沒開 long long 溢位被 hack 成智障的就是我\n坐等晚上 rating change\n沒意外應該會噴掉啦\n<!--more-->\n\n先放上所有題目的[連結](http://codeforces.com/contest/1077)\n\n## problem A\n\n### 題目\n\n大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步\n然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）\n\n### 解法\n\n阿不就直接暴力就好\n算一下會往左次往右幾次，算一下就好\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    #define int LL\n\n    int t, k, a, b, swp, ans;\n    cin >> t;\n    while ( t-- ){\n        cin >> a >> b >> k;\n        swp = a - b;\n        ans = swp * ( LL ) ( k / 2 );\n        if ( k & 1 )\n            ans += a;\n        cout << ans << '\\n';\n    }\n}\n```\n\n\n## problem B\n\n### 題目\n\n給定一排房屋現在是否有開燈\n通常關燈了就是在睡覺了\n\n題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈\n那麼那戶人家就會被干擾\n但是請注意，只有一邊的鄰居開燈並不會被干擾\n\n現在想要讓所有在睡覺的人都不會被干擾\n求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數\n\n### 解法\n\n因為只有一邊有開燈並不會被干擾\n也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了\n\n那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉\n順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, ans = 0, m;\n    cin >> n;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    for ( int i = 1 ; i < n - 1 ; i++ ){\n        if ( !data[i] && data[i - 1] && data[i + 1] )\n            lib.push_back ( i );\n    }\n\n    m = lib.size();\n    while ( lib.size() > 1 ){\n        if ( lib[1] - lib[0] == 2 ){\n            ans++;\n            lib.erase ( lib.begin() );\n            lib.erase ( lib.begin() );\n        }\n        else{\n            ans++;\n            lib.erase ( lib.begin() );\n        }\n    }\n\n    if ( !lib.empty() )\n        ans++;\n    cout << ans << '\\n';\n}\n```\n\n\n## problem C\n\n就是這題，我沒有開 long long 然後就被 hack 了\n名次噴掉 1500 多名\n\n### 題目\n\n給定一條長度為 $N$ 的序列\n我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和\n也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$\n求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的\n請列出數量，以及些解的位置\n\n因為題目有點難懂，我放上其中一個例子好了\n那現在看另外一個序列 $[ 8, 3, 5, 2 ]$\n1. 移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \\to 5 = 3 + 2$\n2. 移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \\to 8 = 3 + 5$\n\n### 解法\n\n1. 計算原先序列的總和\n2. 每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉\n3. 把 $sum$ 為奇數則返回步驟2\n4. 尋找 $\\frac{sum}{2}$ 是否出現於原序列中\n5. 檢查 $\\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次\n6. 如果有出現過兩次，那麼 i 就是其中一個答案\n7. 返回步驟 2\n\n有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數\n假設 $sum' = sum - a[i]，sum'$ 代表除了 $a[i]$ 以外的元素和\n既然一個序列為好的序列，代表說這個序列會被切成兩部分\n而這兩部分的和會一樣\n既然都會被切成兩個一樣的東西了，為什麼 $sum'$ 會是奇數\n這就矛盾了，所以 $sum'$ 一定為偶數\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define int LL\n\nmap < int, int > lib;\n\n#undef int\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    #define int LL\n\n    int n, sum = 0;\n    cin >> n;\n    vector < int > data ( n ), ans;\n    for ( auto &i: data ){\n        cin >> i;\n        sum += i;\n        lib[i]++;\n    }\n    for ( int i = 0 ; i < n ; i++ ){\n        sum -= data[i];\n        if ( sum & 1 ){\n            sum += data[i];\n            continue;\n        }\n        sum >>= 1;\n        if ( ( lib[sum] == 1 && sum != data[i] ) || lib[sum] > 1 ){\n            ans.push_back ( i + 1 );\n        }\n        sum <<= 1;\n        sum += data[i];\n    }\n\n    cout << ans.size() << '\\n';\n    for ( auto i: data )\n        cout << i << ' ';\n    cout << '\\n';\n}\n```\n\n\n## problem D\n\n### 題目\n\n給定一大小為 $N$ 的可重複集合 $S$\n求找出一大小為 $K$ 的可重複集合 $S' ( S'\\subseteq S )$ 且 $S'$ 在 $S$ 中出現次數最多\n\n**元素可重複，這件事情非常重要**\n\n### 解法\n\n我先做離散化，反正數字跟解法沒有關係\n接著紀錄每個數字出現幾次\n我先二分搜最多那個集合最多可以出現幾次\n然後按照次數輸出，反正只要符合要求的都行\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 200005\n\nint cnt[maxN], m, k, ma;\nvector < int > lib;\nmap < int, vector < int > > table;\n\ninline bool check ( int tms ){\n    int res = 0;\n    for ( int i = tms ; i < ma ; i++ )\n        for ( auto j: table[i] )\n            res += cnt[j] / tms;\n\n    return res >= k;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n\n    int n, l = 0, r = -1, mid;\n    cin >> n >> k;\n    vector < int > data ( n );\n    for ( auto &i: data )\n        cin >> i;\n    if ( n == k ){\n        for ( auto i: data )\n            cout << i << ' ';\n        cout << '\\n';\n        return 0;\n    }\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    m = lib.size();\n    for ( auto i: data ){\n        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;\n    }\n    for ( int i = 0 ; i < m ; i++ ){\n        r = max ( r, cnt[i] );\n        table[cnt[i]].push_back ( i );\n    }\n    ma = ++r;\n    mid = ( l + r ) >> 1;\n    while ( r - l > 1 ){\n        if ( check ( mid ) )\n            l = mid;\n        else\n            r = mid;\n        mid = ( l + r ) >> 1;\n    }\n\n    l = k;\n    for ( int i = 0 ; i < m ; i++ ){\n        for ( int j = 0 ; j < min ( cnt[i] / mid, l ) ; j++ )\n            cout << lib[i] << ' ';\n        l -= min ( cnt[i] / mid, l );\n        if ( !l )\n            break;\n    }\n    cout << '\\n';\n}\n```\n\n\n## problem E\n\n這題我賽中只有想到喇賽解法，賽後才想到正解\n\n### 題目\n\n給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$\n要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用\n且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）\n求最多可以使用多少題目\n**注意！你應該要最大會題目數量，而非天數**\n\n### 解法\n\n每舉第一天的題數，然後暴力往後找\n用 lower_bound 去尋找是個不錯的選擇\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 200005\n\nLL cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n\n    int n, m, ma, ans = -1, swp, idx, id;\n    cin >> n;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    m = lib.size();\n    for ( auto i: data )\n        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;\n\n    data.clear();\n    for ( int i = 0 ; i < m ; i++ ){\n        data.push_back ( cnt[i] );\n    }\n    sort ( data.begin(), data.end() );\n    ma = data.back() + 1;\n\n    for ( int i = 0 ; i < ma ; i++ ){\n        swp = idx = 0;\n        for ( int j = i ; j < ma && idx < m ; j <<= 1 ){\n            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();\n            if ( id < data.size() )\n                swp += j;\n            idx = id + 1;\n        }\n\n        ans = max ( ans, swp );\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n\n## 後記\n\n老實說我這場有點慘\npC 被 Hack，pE 賽中沒寫出來\n以我的實力來說不應該這樣子的\n因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@\n\n希望下一場可以好好發揮","source":"_posts/CFR521.md","raw":"---\ntitle: '[CF]Round 521'\ndate: 2018-11-17 12:20:01\ntags:\n - CodeForces\n - div.3\n - Full Contest Solution\n - dp\n---\n\n## 前言\n\n身為一個垃圾，當然要打的像垃圾一樣\n先是校內爆掉，現在換 div.3 爆掉\n。。。pC 沒開 long long 溢位被 hack 成智障的就是我\n坐等晚上 rating change\n沒意外應該會噴掉啦\n<!--more-->\n\n先放上所有題目的[連結](http://codeforces.com/contest/1077)\n\n## problem A\n\n### 題目\n\n大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步\n然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）\n\n### 解法\n\n阿不就直接暴力就好\n算一下會往左次往右幾次，算一下就好\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    #define int LL\n\n    int t, k, a, b, swp, ans;\n    cin >> t;\n    while ( t-- ){\n        cin >> a >> b >> k;\n        swp = a - b;\n        ans = swp * ( LL ) ( k / 2 );\n        if ( k & 1 )\n            ans += a;\n        cout << ans << '\\n';\n    }\n}\n```\n\n\n## problem B\n\n### 題目\n\n給定一排房屋現在是否有開燈\n通常關燈了就是在睡覺了\n\n題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈\n那麼那戶人家就會被干擾\n但是請注意，只有一邊的鄰居開燈並不會被干擾\n\n現在想要讓所有在睡覺的人都不會被干擾\n求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數\n\n### 解法\n\n因為只有一邊有開燈並不會被干擾\n也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了\n\n那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉\n順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, ans = 0, m;\n    cin >> n;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    for ( int i = 1 ; i < n - 1 ; i++ ){\n        if ( !data[i] && data[i - 1] && data[i + 1] )\n            lib.push_back ( i );\n    }\n\n    m = lib.size();\n    while ( lib.size() > 1 ){\n        if ( lib[1] - lib[0] == 2 ){\n            ans++;\n            lib.erase ( lib.begin() );\n            lib.erase ( lib.begin() );\n        }\n        else{\n            ans++;\n            lib.erase ( lib.begin() );\n        }\n    }\n\n    if ( !lib.empty() )\n        ans++;\n    cout << ans << '\\n';\n}\n```\n\n\n## problem C\n\n就是這題，我沒有開 long long 然後就被 hack 了\n名次噴掉 1500 多名\n\n### 題目\n\n給定一條長度為 $N$ 的序列\n我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和\n也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$\n求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的\n請列出數量，以及些解的位置\n\n因為題目有點難懂，我放上其中一個例子好了\n那現在看另外一個序列 $[ 8, 3, 5, 2 ]$\n1. 移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \\to 5 = 3 + 2$\n2. 移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \\to 8 = 3 + 5$\n\n### 解法\n\n1. 計算原先序列的總和\n2. 每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉\n3. 把 $sum$ 為奇數則返回步驟2\n4. 尋找 $\\frac{sum}{2}$ 是否出現於原序列中\n5. 檢查 $\\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次\n6. 如果有出現過兩次，那麼 i 就是其中一個答案\n7. 返回步驟 2\n\n有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數\n假設 $sum' = sum - a[i]，sum'$ 代表除了 $a[i]$ 以外的元素和\n既然一個序列為好的序列，代表說這個序列會被切成兩部分\n而這兩部分的和會一樣\n既然都會被切成兩個一樣的東西了，為什麼 $sum'$ 會是奇數\n這就矛盾了，所以 $sum'$ 一定為偶數\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define int LL\n\nmap < int, int > lib;\n\n#undef int\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    #define int LL\n\n    int n, sum = 0;\n    cin >> n;\n    vector < int > data ( n ), ans;\n    for ( auto &i: data ){\n        cin >> i;\n        sum += i;\n        lib[i]++;\n    }\n    for ( int i = 0 ; i < n ; i++ ){\n        sum -= data[i];\n        if ( sum & 1 ){\n            sum += data[i];\n            continue;\n        }\n        sum >>= 1;\n        if ( ( lib[sum] == 1 && sum != data[i] ) || lib[sum] > 1 ){\n            ans.push_back ( i + 1 );\n        }\n        sum <<= 1;\n        sum += data[i];\n    }\n\n    cout << ans.size() << '\\n';\n    for ( auto i: data )\n        cout << i << ' ';\n    cout << '\\n';\n}\n```\n\n\n## problem D\n\n### 題目\n\n給定一大小為 $N$ 的可重複集合 $S$\n求找出一大小為 $K$ 的可重複集合 $S' ( S'\\subseteq S )$ 且 $S'$ 在 $S$ 中出現次數最多\n\n**元素可重複，這件事情非常重要**\n\n### 解法\n\n我先做離散化，反正數字跟解法沒有關係\n接著紀錄每個數字出現幾次\n我先二分搜最多那個集合最多可以出現幾次\n然後按照次數輸出，反正只要符合要求的都行\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 200005\n\nint cnt[maxN], m, k, ma;\nvector < int > lib;\nmap < int, vector < int > > table;\n\ninline bool check ( int tms ){\n    int res = 0;\n    for ( int i = tms ; i < ma ; i++ )\n        for ( auto j: table[i] )\n            res += cnt[j] / tms;\n\n    return res >= k;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n\n    int n, l = 0, r = -1, mid;\n    cin >> n >> k;\n    vector < int > data ( n );\n    for ( auto &i: data )\n        cin >> i;\n    if ( n == k ){\n        for ( auto i: data )\n            cout << i << ' ';\n        cout << '\\n';\n        return 0;\n    }\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    m = lib.size();\n    for ( auto i: data ){\n        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;\n    }\n    for ( int i = 0 ; i < m ; i++ ){\n        r = max ( r, cnt[i] );\n        table[cnt[i]].push_back ( i );\n    }\n    ma = ++r;\n    mid = ( l + r ) >> 1;\n    while ( r - l > 1 ){\n        if ( check ( mid ) )\n            l = mid;\n        else\n            r = mid;\n        mid = ( l + r ) >> 1;\n    }\n\n    l = k;\n    for ( int i = 0 ; i < m ; i++ ){\n        for ( int j = 0 ; j < min ( cnt[i] / mid, l ) ; j++ )\n            cout << lib[i] << ' ';\n        l -= min ( cnt[i] / mid, l );\n        if ( !l )\n            break;\n    }\n    cout << '\\n';\n}\n```\n\n\n## problem E\n\n這題我賽中只有想到喇賽解法，賽後才想到正解\n\n### 題目\n\n給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$\n要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用\n且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）\n求最多可以使用多少題目\n**注意！你應該要最大會題目數量，而非天數**\n\n### 解法\n\n每舉第一天的題數，然後暴力往後找\n用 lower_bound 去尋找是個不錯的選擇\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 200005\n\nLL cnt[maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n\n    int n, m, ma, ans = -1, swp, idx, id;\n    cin >> n;\n    vector < int > data ( n ), lib;\n    for ( auto &i: data )\n        cin >> i;\n    lib = data;\n    sort ( lib.begin(), lib.end() );\n    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );\n    m = lib.size();\n    for ( auto i: data )\n        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;\n\n    data.clear();\n    for ( int i = 0 ; i < m ; i++ ){\n        data.push_back ( cnt[i] );\n    }\n    sort ( data.begin(), data.end() );\n    ma = data.back() + 1;\n\n    for ( int i = 0 ; i < ma ; i++ ){\n        swp = idx = 0;\n        for ( int j = i ; j < ma && idx < m ; j <<= 1 ){\n            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();\n            if ( id < data.size() )\n                swp += j;\n            idx = id + 1;\n        }\n\n        ans = max ( ans, swp );\n    }\n\n    cout << ans << '\\n';\n}\n```\n\n\n## 後記\n\n老實說我這場有點慘\npC 被 Hack，pE 賽中沒寫出來\n以我的實力來說不應該這樣子的\n因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@\n\n希望下一場可以好好發揮","slug":"CFR521","published":1,"updated":"2020-05-03T11:24:07.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsd0007xl9p91cq9v1v","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>身為一個垃圾，當然要打的像垃圾一樣<br>先是校內爆掉，現在換 div.3 爆掉<br>。。。pC 沒開 long long 溢位被 hack 成智障的就是我<br>坐等晚上 rating change<br>沒意外應該會噴掉啦</p><a id=\"more\"></a><p>先放上所有題目的<a href=\"http://codeforces.com/contest/1077\" target=\"_blank\" rel=\"noopener\">連結</a></p><h2 id=\"problem-A\"><a class=\"header-anchor\" href=\"#problem-A\"></a>problem A</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步<br>然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>阿不就直接暴力就好<br>算一下會往左次往右幾次，算一下就好</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, k, a, b, swp, ans;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class=\"line\">        swp = a - b;</span><br><span class=\"line\">        ans = swp * ( LL ) ( k / <span class=\"number\">2</span> );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( k &amp; <span class=\"number\">1</span> )</span><br><span class=\"line\">            ans += a;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-B\"><a class=\"header-anchor\" href=\"#problem-B\"></a>problem B</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一排房屋現在是否有開燈<br>通常關燈了就是在睡覺了</p><p>題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈<br>那麼那戶人家就會被干擾<br>但是請注意，只有一邊的鄰居開燈並不會被干擾</p><p>現在想要讓所有在睡覺的人都不會被干擾<br>求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>因為只有一邊有開燈並不會被干擾<br>也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了</p><p>那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉<br>順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, ans = <span class=\"number\">0</span>, m;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; n - <span class=\"number\">1</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !data[i] &amp;&amp; data[i - <span class=\"number\">1</span>] &amp;&amp; data[i + <span class=\"number\">1</span>] )</span><br><span class=\"line\">            lib.push_back ( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( lib.size() &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( lib[<span class=\"number\">1</span>] - lib[<span class=\"number\">0</span>] == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !lib.empty() )</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-C\"><a class=\"header-anchor\" href=\"#problem-C\"></a>problem C</h2><p>就是這題，我沒有開 long long 然後就被 hack 了<br>名次噴掉 1500 多名</p><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定一條長度為 $N$ 的序列<br>我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和<br>也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$<br>求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的<br>請列出數量，以及些解的位置</p><p>因為題目有點難懂，我放上其中一個例子好了<br>那現在看另外一個序列 $[ 8, 3, 5, 2 ]$</p><ol><li>移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \\to 5 = 3 + 2$</li><li>移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \\to 8 = 3 + 5$</li></ol><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><ol><li>計算原先序列的總和</li><li>每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉</li><li>把 $sum$ 為奇數則返回步驟2</li><li>尋找 $\\frac{sum}{2}$ 是否出現於原序列中</li><li>檢查 $\\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次</li><li>如果有出現過兩次，那麼 i 就是其中一個答案</li><li>返回步驟 2</li></ol><p>有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數<br>假設 $sum’ = sum - a[i]，sum’$ 代表除了 $a[i]$ 以外的元素和<br>既然一個序列為好的序列，代表說這個序列會被切成兩部分<br>而這兩部分的和會一樣<br>既然都會被切成兩個一樣的東西了，為什麼 $sum’$ 會是奇數<br>這就矛盾了，所以 $sum’$ 一定為偶數</p><h3 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), ans;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">        lib[i]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        sum -= data[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( sum &amp; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            sum += data[i];</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ( lib[sum] == <span class=\"number\">1</span> &amp;&amp; sum != data[i] ) || lib[sum] &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            ans.push_back ( i + <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        sum += data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-D\"><a class=\"header-anchor\" href=\"#problem-D\"></a>problem D</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>給定一大小為 $N$ 的可重複集合 $S$<br>求找出一大小為 $K$ 的可重複集合 $S’ ( S’\\subseteq S )$ 且 $S’$ 在 $S$ 中出現次數最多</p><p><strong>元素可重複，這件事情非常重要</strong></p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>我先做離散化，反正數字跟解法沒有關係<br>接著紀錄每個數字出現幾次<br>我先二分搜最多那個集合最多可以出現幾次<br>然後按照次數輸出，反正只要符合要求的都行</p><h3 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN], m, k, ma;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; &gt; table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">check</span> <span class=\"params\">( <span class=\"keyword\">int</span> tms )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = tms ; i &lt; ma ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: table[i] )</span><br><span class=\"line\">            res += cnt[j] / tms;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res &gt;= k;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, l = <span class=\"number\">0</span>, r = <span class=\"number\">-1</span>, mid;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( n == k )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )&#123;</span><br><span class=\"line\">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        r = max ( r, cnt[i] );</span><br><span class=\"line\">        table[cnt[i]].push_back ( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ma = ++r;</span><br><span class=\"line\">    mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( r - l &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( check ( mid ) )</span><br><span class=\"line\">            l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">        mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    l = k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; min ( cnt[i] / mid, l ) ; j++ )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; lib[i] &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">        l -= min ( cnt[i] / mid, l );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !l )</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-E\"><a class=\"header-anchor\" href=\"#problem-E\"></a>problem E</h2><p>這題我賽中只有想到喇賽解法，賽後才想到正解</p><h3 id=\"題目-v5\"><a class=\"header-anchor\" href=\"#題目-v5\"></a>題目</h3><p>給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$<br>要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用<br>且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）<br>求最多可以使用多少題目<br><strong>注意！你應該要最大會題目數量，而非天數</strong></p><h3 id=\"解法-v5\"><a class=\"header-anchor\" href=\"#解法-v5\"></a>解法</h3><p>每舉第一天的題數，然後暴力往後找<br>用 lower_bound 去尋找是個不錯的選擇</p><h3 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\">LL cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ma, ans = <span class=\"number\">-1</span>, swp, idx, id;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;</span><br><span class=\"line\"></span><br><span class=\"line\">    data.clear();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        data.push_back ( cnt[i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort ( data.begin(), data.end() );</span><br><span class=\"line\">    ma = data.back() + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; ma ; i++ )&#123;</span><br><span class=\"line\">        swp = idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i ; j &lt; ma &amp;&amp; idx &lt; m ; j &lt;&lt;= <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( id &lt; data.size() )</span><br><span class=\"line\">                swp += j;</span><br><span class=\"line\">            idx = id + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ans = max ( ans, swp );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>老實說我這場有點慘<br>pC 被 Hack，pE 賽中沒寫出來<br>以我的實力來說不應該這樣子的<br>因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@</p><p>希望下一場可以好好發揮</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>身為一個垃圾，當然要打的像垃圾一樣<br>先是校內爆掉，現在換 div.3 爆掉<br>。。。pC 沒開 long long 溢位被 hack 成智障的就是我<br>坐等晚上 rating change<br>沒意外應該會噴掉啦</p>","more":"<p>先放上所有題目的<a href=\"http://codeforces.com/contest/1077\" target=\"_blank\" rel=\"noopener\">連結</a></p><h2 id=\"problem-A\"><a class=\"header-anchor\" href=\"#problem-A\"></a>problem A</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步<br>然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>阿不就直接暴力就好<br>算一下會往左次往右幾次，算一下就好</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, k, a, b, swp, ans;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class=\"line\">        swp = a - b;</span><br><span class=\"line\">        ans = swp * ( LL ) ( k / <span class=\"number\">2</span> );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( k &amp; <span class=\"number\">1</span> )</span><br><span class=\"line\">            ans += a;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-B\"><a class=\"header-anchor\" href=\"#problem-B\"></a>problem B</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一排房屋現在是否有開燈<br>通常關燈了就是在睡覺了</p><p>題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈<br>那麼那戶人家就會被干擾<br>但是請注意，只有一邊的鄰居開燈並不會被干擾</p><p>現在想要讓所有在睡覺的人都不會被干擾<br>求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>因為只有一邊有開燈並不會被干擾<br>也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了</p><p>那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉<br>順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, ans = <span class=\"number\">0</span>, m;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; n - <span class=\"number\">1</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !data[i] &amp;&amp; data[i - <span class=\"number\">1</span>] &amp;&amp; data[i + <span class=\"number\">1</span>] )</span><br><span class=\"line\">            lib.push_back ( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( lib.size() &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( lib[<span class=\"number\">1</span>] - lib[<span class=\"number\">0</span>] == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">            lib.erase ( lib.begin() );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !lib.empty() )</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-C\"><a class=\"header-anchor\" href=\"#problem-C\"></a>problem C</h2><p>就是這題，我沒有開 long long 然後就被 hack 了<br>名次噴掉 1500 多名</p><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定一條長度為 $N$ 的序列<br>我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和<br>也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$<br>求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的<br>請列出數量，以及些解的位置</p><p>因為題目有點難懂，我放上其中一個例子好了<br>那現在看另外一個序列 $[ 8, 3, 5, 2 ]$</p><ol><li>移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \\to 5 = 3 + 2$</li><li>移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \\to 8 = 3 + 5$</li></ol><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><ol><li>計算原先序列的總和</li><li>每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉</li><li>把 $sum$ 為奇數則返回步驟2</li><li>尋找 $\\frac{sum}{2}$ 是否出現於原序列中</li><li>檢查 $\\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次</li><li>如果有出現過兩次，那麼 i 就是其中一個答案</li><li>返回步驟 2</li></ol><p>有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數<br>假設 $sum’ = sum - a[i]，sum’$ 代表除了 $a[i]$ 以外的元素和<br>既然一個序列為好的序列，代表說這個序列會被切成兩部分<br>而這兩部分的和會一樣<br>既然都會被切成兩個一樣的東西了，為什麼 $sum’$ 會是奇數<br>這就矛盾了，所以 $sum’$ 一定為偶數</p><h3 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), ans;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">        lib[i]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        sum -= data[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( sum &amp; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            sum += data[i];</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ( lib[sum] == <span class=\"number\">1</span> &amp;&amp; sum != data[i] ) || lib[sum] &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            ans.push_back ( i + <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        sum += data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-D\"><a class=\"header-anchor\" href=\"#problem-D\"></a>problem D</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>給定一大小為 $N$ 的可重複集合 $S$<br>求找出一大小為 $K$ 的可重複集合 $S’ ( S’\\subseteq S )$ 且 $S’$ 在 $S$ 中出現次數最多</p><p><strong>元素可重複，這件事情非常重要</strong></p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>我先做離散化，反正數字跟解法沒有關係<br>接著紀錄每個數字出現幾次<br>我先二分搜最多那個集合最多可以出現幾次<br>然後按照次數輸出，反正只要符合要求的都行</p><h3 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN], m, k, ma;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; &gt; table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">check</span> <span class=\"params\">( <span class=\"keyword\">int</span> tms )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = tms ; i &lt; ma ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> j: table[i] )</span><br><span class=\"line\">            res += cnt[j] / tms;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res &gt;= k;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, l = <span class=\"number\">0</span>, r = <span class=\"number\">-1</span>, mid;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( n == k )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )&#123;</span><br><span class=\"line\">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        r = max ( r, cnt[i] );</span><br><span class=\"line\">        table[cnt[i]].push_back ( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ma = ++r;</span><br><span class=\"line\">    mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( r - l &gt; <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( check ( mid ) )</span><br><span class=\"line\">            l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">        mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    l = k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; min ( cnt[i] / mid, l ) ; j++ )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; lib[i] &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">        l -= min ( cnt[i] / mid, l );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !l )</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-E\"><a class=\"header-anchor\" href=\"#problem-E\"></a>problem E</h2><p>這題我賽中只有想到喇賽解法，賽後才想到正解</p><h3 id=\"題目-v5\"><a class=\"header-anchor\" href=\"#題目-v5\"></a>題目</h3><p>給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$<br>要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用<br>且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）<br>求最多可以使用多少題目<br><strong>注意！你應該要最大會題目數量，而非天數</strong></p><h3 id=\"解法-v5\"><a class=\"header-anchor\" href=\"#解法-v5\"></a>解法</h3><p>每舉第一天的題數，然後暴力往後找<br>用 lower_bound 去尋找是個不錯的選擇</p><h3 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\">LL cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, ma, ans = <span class=\"number\">-1</span>, swp, idx, id;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n ), lib;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\">    lib = data;</span><br><span class=\"line\">    sort ( lib.begin(), lib.end() );</span><br><span class=\"line\">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class=\"line\">    m = lib.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )</span><br><span class=\"line\">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;</span><br><span class=\"line\"></span><br><span class=\"line\">    data.clear();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class=\"line\">        data.push_back ( cnt[i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort ( data.begin(), data.end() );</span><br><span class=\"line\">    ma = data.back() + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; ma ; i++ )&#123;</span><br><span class=\"line\">        swp = idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i ; j &lt; ma &amp;&amp; idx &lt; m ; j &lt;&lt;= <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( id &lt; data.size() )</span><br><span class=\"line\">                swp += j;</span><br><span class=\"line\">            idx = id + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ans = max ( ans, swp );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>老實說我這場有點慘<br>pC 被 Hack，pE 賽中沒寫出來<br>以我的實力來說不應該這樣子的<br>因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@</p><p>希望下一場可以好好發揮</p><!-- rebuild by neat -->"},{"title":"[TIOJ][1615] A! + B! problem","date":"2018-10-28T12:13:43.000Z","_content":"\n## 前言\n\n好久沒有寫 code 發題解了\n最近因為一些事情沒有時間（也沒有心情）認真寫 code\n（因為上次 CodeForces 連續掉分我心情有點糟）\n（啊還有學科校內爆炸也是我心情糟的原因之一）\n（開始懷疑我到底這一年努力是為了什麼，之類的）\n<!--more-->\n然後今天想說寫個題目、發個題解刷一下存在感，之類的\n所以跑去 TIOJ 翻題目\n然後看到這題\n。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼\n\n## 題目 & 解法\n\n大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數\n原網址我放[在這](https://tioj.ck.tp.edu.tw/problems/1615)\n\n很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做\n所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數\n因為要加一，所以我想了很久\n感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）\n但是我真的沒有想法\n所以就寫了個 $O ( N^2 )$ 的解法\n。。。然後過了，wtf\n就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查\n就這樣。。。\n我一臉懵逼的坐在電腦前傻了一下\n才開始動手打這篇文章\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 1000000\n\nbitset < maxN > lib;\nvector < LL > prime;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n    #define int LL\n\n    lib[0] = lib[1] = true;\n    for ( int i = 2 ; i < maxN ; i++ ){\n        if ( !lib[i] ){\n            prime.push_back ( i );\n            for ( int j = i ; j < maxN ; j += i )\n                lib[j] = true;\n        }\n    }\n\n    int a, b, len = prime.size();\n    LL ans, stp;\n    while ( cin >> a >> b ){\n        if ( a > b )\n            swap ( a, b );\n        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();\n        stp = 1;\n        for ( int i = a + 1 ; i <= b ; i++ ){\n            stp *= i;\n        }\n        stp++;\n        for ( int i = 0 ; i < ans ; i++ ){\n            while ( stp % prime[i] == 0 ){\n                stp /= prime[i];\n            }\n        }\n\n        for ( int i = ans ; i < len ; i++ ){\n            if ( !( stp % prime[i] ) ){\n                ans++;\n                while ( stp % prime[i] == 0 )\n                    stp /= prime[i];\n            }\n        }\n\n        if ( stp > maxN )\n            ans++;\n\n        cout << ans << '\\n';\n    }\n}\n```\n\n## 後記\n\n最近特殊選才有點忙\n加上 CodeForces，校內賽的陰影\n我可能會暫時停筆一下啦XD\n沒有意外，等到特選告一段落會繼續。。。吧\n等等印象中好像有 CodeForces，啊不過有點晚\n會不會打還是未知數\n下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧\n在特選放榜前我應該不會繼續認真搞比賽了\n因為我不知道在放榜後我會何去何從（笑\n先讀點書好像比較保險\n\n不過如果特選有好結果我還是會認真搞 TOI 入營考啦\n已經是最後一年了，能不能進去就聽由天命囉\n\n然後，謝謝看到這邊的你\n（我這麼寫怎麼有點感傷啊XD）\n我已經很久沒有發文了，希望大家還有在看\n謝謝各位一直以來對我的支持 <3","source":"_posts/TIOJ-1615.md","raw":"---\ntitle: '[TIOJ][1615] A! + B! problem'\ndate: 2018-10-28 20:13:43\ntags:\n - TIOJ\n - math\n---\n\n## 前言\n\n好久沒有寫 code 發題解了\n最近因為一些事情沒有時間（也沒有心情）認真寫 code\n（因為上次 CodeForces 連續掉分我心情有點糟）\n（啊還有學科校內爆炸也是我心情糟的原因之一）\n（開始懷疑我到底這一年努力是為了什麼，之類的）\n<!--more-->\n然後今天想說寫個題目、發個題解刷一下存在感，之類的\n所以跑去 TIOJ 翻題目\n然後看到這題\n。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼\n\n## 題目 & 解法\n\n大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數\n原網址我放[在這](https://tioj.ck.tp.edu.tw/problems/1615)\n\n很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做\n所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數\n因為要加一，所以我想了很久\n感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）\n但是我真的沒有想法\n所以就寫了個 $O ( N^2 )$ 的解法\n。。。然後過了，wtf\n就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查\n就這樣。。。\n我一臉懵逼的坐在電腦前傻了一下\n才開始動手打這篇文章\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 1000000\n\nbitset < maxN > lib;\nvector < LL > prime;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n    #define int LL\n\n    lib[0] = lib[1] = true;\n    for ( int i = 2 ; i < maxN ; i++ ){\n        if ( !lib[i] ){\n            prime.push_back ( i );\n            for ( int j = i ; j < maxN ; j += i )\n                lib[j] = true;\n        }\n    }\n\n    int a, b, len = prime.size();\n    LL ans, stp;\n    while ( cin >> a >> b ){\n        if ( a > b )\n            swap ( a, b );\n        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();\n        stp = 1;\n        for ( int i = a + 1 ; i <= b ; i++ ){\n            stp *= i;\n        }\n        stp++;\n        for ( int i = 0 ; i < ans ; i++ ){\n            while ( stp % prime[i] == 0 ){\n                stp /= prime[i];\n            }\n        }\n\n        for ( int i = ans ; i < len ; i++ ){\n            if ( !( stp % prime[i] ) ){\n                ans++;\n                while ( stp % prime[i] == 0 )\n                    stp /= prime[i];\n            }\n        }\n\n        if ( stp > maxN )\n            ans++;\n\n        cout << ans << '\\n';\n    }\n}\n```\n\n## 後記\n\n最近特殊選才有點忙\n加上 CodeForces，校內賽的陰影\n我可能會暫時停筆一下啦XD\n沒有意外，等到特選告一段落會繼續。。。吧\n等等印象中好像有 CodeForces，啊不過有點晚\n會不會打還是未知數\n下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧\n在特選放榜前我應該不會繼續認真搞比賽了\n因為我不知道在放榜後我會何去何從（笑\n先讀點書好像比較保險\n\n不過如果特選有好結果我還是會認真搞 TOI 入營考啦\n已經是最後一年了，能不能進去就聽由天命囉\n\n然後，謝謝看到這邊的你\n（我這麼寫怎麼有點感傷啊XD）\n我已經很久沒有發文了，希望大家還有在看\n謝謝各位一直以來對我的支持 <3","slug":"TIOJ-1615","published":1,"updated":"2020-05-03T11:24:07.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsf0009xl9pa11w10b4","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>好久沒有寫 code 發題解了<br>最近因為一些事情沒有時間（也沒有心情）認真寫 code<br>（因為上次 CodeForces 連續掉分我心情有點糟）<br>（啊還有學科校內爆炸也是我心情糟的原因之一）<br>（開始懷疑我到底這一年努力是為了什麼，之類的）</p><a id=\"more\"></a><p>然後今天想說寫個題目、發個題解刷一下存在感，之類的<br>所以跑去 TIOJ 翻題目<br>然後看到這題<br>。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼</p><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p>大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數<br>原網址我放<a href=\"https://tioj.ck.tp.edu.tw/problems/1615\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做<br>所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數<br>因為要加一，所以我想了很久<br>感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）<br>但是我真的沒有想法<br>所以就寫了個 $O ( N^2 )$ 的解法<br>。。。然後過了，wtf<br>就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查<br>就這樣。。。<br>我一臉懵逼的坐在電腦前傻了一下<br>才開始動手打這篇文章</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bitset</span> &lt; maxN &gt; lib;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; LL &gt; prime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    lib[<span class=\"number\">0</span>] = lib[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt; maxN ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !lib[i] )&#123;</span><br><span class=\"line\">            prime.push_back ( i );</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i ; j &lt; maxN ; j += i )</span><br><span class=\"line\">                lib[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, len = prime.size();</span><br><span class=\"line\">    LL ans, stp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a &gt; b )</span><br><span class=\"line\">            swap ( a, b );</span><br><span class=\"line\">        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();</span><br><span class=\"line\">        stp = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = a + <span class=\"number\">1</span> ; i &lt;= b ; i++ )&#123;</span><br><span class=\"line\">            stp *= i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stp++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; ans ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ( stp % prime[i] == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                stp /= prime[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = ans ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !( stp % prime[i] ) )&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ( stp % prime[i] == <span class=\"number\">0</span> )</span><br><span class=\"line\">                    stp /= prime[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( stp &gt; maxN )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>最近特殊選才有點忙<br>加上 CodeForces，校內賽的陰影<br>我可能會暫時停筆一下啦XD<br>沒有意外，等到特選告一段落會繼續。。。吧<br>等等印象中好像有 CodeForces，啊不過有點晚<br>會不會打還是未知數<br>下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧<br>在特選放榜前我應該不會繼續認真搞比賽了<br>因為我不知道在放榜後我會何去何從（笑<br>先讀點書好像比較保險</p><p>不過如果特選有好結果我還是會認真搞 TOI 入營考啦<br>已經是最後一年了，能不能進去就聽由天命囉</p><p>然後，謝謝看到這邊的你<br>（我這麼寫怎麼有點感傷啊XD）<br>我已經很久沒有發文了，希望大家還有在看<br>謝謝各位一直以來對我的支持 &lt;3</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>好久沒有寫 code 發題解了<br>最近因為一些事情沒有時間（也沒有心情）認真寫 code<br>（因為上次 CodeForces 連續掉分我心情有點糟）<br>（啊還有學科校內爆炸也是我心情糟的原因之一）<br>（開始懷疑我到底這一年努力是為了什麼，之類的）</p>","more":"<p>然後今天想說寫個題目、發個題解刷一下存在感，之類的<br>所以跑去 TIOJ 翻題目<br>然後看到這題<br>。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼</p><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p>大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數<br>原網址我放<a href=\"https://tioj.ck.tp.edu.tw/problems/1615\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做<br>所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數<br>因為要加一，所以我想了很久<br>感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）<br>但是我真的沒有想法<br>所以就寫了個 $O ( N^2 )$ 的解法<br>。。。然後過了，wtf<br>就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查<br>就這樣。。。<br>我一臉懵逼的坐在電腦前傻了一下<br>才開始動手打這篇文章</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">bitset</span> &lt; maxN &gt; lib;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; LL &gt; prime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> int LL</span></span><br><span class=\"line\"></span><br><span class=\"line\">    lib[<span class=\"number\">0</span>] = lib[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt; maxN ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !lib[i] )&#123;</span><br><span class=\"line\">            prime.push_back ( i );</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i ; j &lt; maxN ; j += i )</span><br><span class=\"line\">                lib[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a, b, len = prime.size();</span><br><span class=\"line\">    LL ans, stp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a &gt; b )</span><br><span class=\"line\">            swap ( a, b );</span><br><span class=\"line\">        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();</span><br><span class=\"line\">        stp = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = a + <span class=\"number\">1</span> ; i &lt;= b ; i++ )&#123;</span><br><span class=\"line\">            stp *= i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stp++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; ans ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ( stp % prime[i] == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                stp /= prime[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = ans ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !( stp % prime[i] ) )&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> ( stp % prime[i] == <span class=\"number\">0</span> )</span><br><span class=\"line\">                    stp /= prime[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( stp &gt; maxN )</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>最近特殊選才有點忙<br>加上 CodeForces，校內賽的陰影<br>我可能會暫時停筆一下啦XD<br>沒有意外，等到特選告一段落會繼續。。。吧<br>等等印象中好像有 CodeForces，啊不過有點晚<br>會不會打還是未知數<br>下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧<br>在特選放榜前我應該不會繼續認真搞比賽了<br>因為我不知道在放榜後我會何去何從（笑<br>先讀點書好像比較保險</p><p>不過如果特選有好結果我還是會認真搞 TOI 入營考啦<br>已經是最後一年了，能不能進去就聽由天命囉</p><p>然後，謝謝看到這邊的你<br>（我這麼寫怎麼有點感傷啊XD）<br>我已經很久沒有發文了，希望大家還有在看<br>謝謝各位一直以來對我的支持 &lt;3</p><!-- rebuild by neat -->"},{"title":"Google Code Jam 2019 Qualification Round","date":"2019-04-09T07:21:21.000Z","_content":"\n## 前言\n\n我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）\n然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了\n\n只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了\n<!--more-->\n下一場是在這週六晚上九點～十一點半\n撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走\n\n總之，過 Qualification Round 應該就算比去年好了\n去年在耍廢直接爆炸。。。\n\n希望今年可以去 Round 2\n\n先放上這次的[題目連結](https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705)\n\n## problem A\n\n### 題目\n\n現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了\n然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$\n**多筆測資**\n\n### 解法\n\n顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$\n一臉就是在跟你說開 string 存啊\n所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$\n然後把這兩個數字輸出\n**注意不能有前導零**\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, mi;\n    string n;\n    cin >> t;\n    for ( int tms = 1 ; tms <= t ; tms++ ){\n        cout << \"Case #\" << tms << \": \";\n        cin >> n;\n        mi = INF;\n        for ( int i = 0 ; i < n.size() ; i++ ){\n            if ( n[i] == '4' ){\n                mi = min ( mi, i );\n                cout << '3';\n            }\n            else\n                cout << n[i];\n        }\n\n        cout << ' ';\n\n        for ( int i = mi ; i < n.size() ; i++ )\n            cout << ( n[i] == '4' )\n        cout << '\\n';\n    }\n}\n```\n\n### 後記\n我還沒有注意到這題有保證輸入有 $4$\n也沒有注意到這題要求輸出都要是正整數\n運氣真好，歪歪得正\n\n\n## problem B\n\n### 題目\n\n給定一張二維圖以及一條從左上到右下的路線\n求一條不重複的另外一條路線\n所謂的路線重複是指 $a \\to b$ 這個邊同時出現在兩條路線中\n然後輸入都是SESE這樣，代表從起點開始他往哪些位置走\n並且保證只會往東（右）以及往南（下）走\n詳細請看這張圖\n![](pB.jpg)\n\n### 解法\n\n#### $O ( N ^ 2 )$\n\n垃圾如我，肯定只會寫 $N ^ 2$ 的解法\n簡單來說就是 dp\n我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存\n然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）\n接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）\n所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點\n\n不過這樣做有小地方需要注意一下\n理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ & $dp[i][j - 1]$ 轉移過來\n所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上\n如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來\n但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）\n因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移\n啊如果還是都可以拿，那就真的隨便了\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define mp make_pair\ntypedef pair < short, char > psc;\n\nbool lib[maxN][maxN];\npsc str[maxN][maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n, x, y;\n    string data;\n    cin >> t;\n    for ( int tms = 1 ; tms <= t ; tms++ ){\n        cin >> n >> data;\n        memset ( lib, 0, sizeof lib );\n        for ( int i = 0 ; i <= n ; i++ ){\n            for ( int j = 0 ; j <= n ; j++ ){\n                str[i][j] = mp ( 0, ' ' );\n            }\n        }\n        x = 1, y = 1;\n        for ( auto i: data ){\n            lib[x][y] = true;\n            i == 'S' ? x++ : y++;\n        }\n        lib[x][y] = true;\n        str[1][1] = mp ( 0, ' ' );\n\n        for ( int i = 2 ; i <= n ; i++ ){\n            if ( lib[1][i] ){\n                if ( !lib[1][i - 1] ){\n                    str[1][i] = str[1][i - 1];\n                    str[1][i].F++;\n                    str[1][i].S = 'E';\n                }\n            }\n            else{\n                str[1][i] = str[1][i - 1];\n                str[1][i].F++;\n                str[1][i].S = 'E';\n            }\n        }\n\n        for ( int i = 2 ; i <= n ; i++ ){\n            if ( lib[i][1] ){\n                if ( !lib[i - 1][1] ){\n                    str[i][1] = str[i - 1][1];\n                    str[i][1].F++;\n                    str[i][1].S = 'S';\n                }\n            }\n            else{\n                str[i][1] = str[i - 1][1];\n                str[i][1].F++;\n                str[i][1].S = 'S';\n            }\n            for ( int j = 2 ; j <= n ; j++ ){\n                if ( lib[i][j] ){\n                    if ( !lib[i][j - 1] ){\n                        str[i][j] = str[i][j - 1];\n                        str[i][j].F++;\n                        str[i][j].S = 'E';\n                    }\n                    else{\n                        str[i][j] = str[i - 1][j];\n                        str[i][j].F++;\n                        str[i][j].S = 'S';\n                    }\n                }\n                else{\n                    if ( str[i][j - 1].F > str[i - 1][j].F ){\n                        str[i][j] = str[i][j - 1];\n                        str[i][j].S = 'E';\n                    }\n                    else{\n                        str[i][j] = str[i - 1][j];\n                        str[i][j].S = 'S';\n                    }\n                    str[i][j].F++;\n                }\n            }\n        }\n\n        data = \"\";\n        x = y = n;\n        while ( str[x][y].S != ' ' ){\n            data += str[x][y].S;\n            str[x][y].S == 'S' ? x-- : y--;\n        }\n        reverse ( data.begin(), data.end() );\n        cout << \"Case #\" << tms << \": \" << data << '\\n';\n    }\n}\n```\n\n#### $O ( N )$\n\n沒錯，$O ( N )$\n我後來才發現我TMD被哏到了\n只要把 S E 反轉就好啊\n讀到 S 輸出 E ，反之讀到 E 輸出 S\n這樣就會變成從左上到右下的對稱\n所以路線不會重複。。。\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n;\n    string str;\n    cin >> t;\n    while ( t-- && cin >> n >> str ){\n        for ( auto i: str )\n            cout << ( i == 'S' ? 'E' : 'S' );\n        cout << '\\n';\n    }\n}\n```\n\n## problem C\n\n感謝 [En-ming Huang](https://www.facebook.com/enminghuang1) 大大提供\n要 solution 請去找他\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint input[maxN], l;\nchar out[maxN][2], print[maxN];\n\nbool check ( int idx, char now ){\n    if ( idx == l ){\n        cout << print << '\\n';\n        return true;\n    }\n    for ( int i = 0 ; i < 2 ; i++ ){\n        if ( out[idx][i] != now )\n            continue;\n        print[idx] = out[idx][i];\n        if ( idx == l - 1 )\n            print[idx + 1] = out[idx][!i];\n        return check ( idx + 1, out[idx][!i] );\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n, idx;\n    set < int > prime;\n    map < int, char > lib;\n    cin >> t;\n    for (int i = 1; i <= t; i++){\n        cin >> n >> l;\n        memset ( print, 0, sizeof print );\n        prime.clear();\n        lib.clear();\n        cout << \"Case #\" << i << \": \";\n        for ( int i = 0 ; i < l ; i++ ){\n            cin >> input[i];\n            for ( int j = 2 ; j <= n ; j++ ){\n                if ( input[i] % j == 0 ){\n                    prime.insert ( j );\n                    prime.insert ( input[i] / j );\n                    break;\n                }\n            }\n        }\n\n        idx = 0;\n        for ( auto i: prime )\n            lib[i] = 'A' + idx++;\n        for ( int i = 0 ; i < l ; i++ )\n            for ( int j = 2 ; j <= n ; j++ )\n                if ( input[i] % j == 0 ){\n                    out[i][0] = lib[j];\n                    out[i][1] = lib[input[i] / j];\n                    break;\n                }\n        for ( int i = 0 ; i < 2 ; i++ )\n            if ( check ( 0, out[0][i] ) )\n                break;\n    }\n    return 0;\n}\n```\n\n## 後記\n\n這場打起來感覺好廢\n最近比較少寫演算法競賽的題目\n幾乎都是在讀新東西\n手感感覺不是很好\n教練，我想要拿 T-Shirt\np.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！\n下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打\n而且時間上來說是 CodeForces 的 usaul time\n中國人應該不少（汗\n1A 1B 1C 要有一場前 1500 名才能進去啊（遠望\n覺得有點難@@\n\n最後放個計分板截圖\n![](scb.jpg)\n\n寫完這篇文章，在本地端用 hexo 編譯預覽出來後\n發現圖片邊緣有白框\n。。。\n好樣的，我又要來修 css 配置了\n工作量 up up\n = =","source":"_posts/GCJ-2019-QuR.md","raw":"---\ntitle: 'Google Code Jam 2019 Qualification Round'\ndate: 2019-04-09 15:21:21\ntags:\n - GCJ\n - Full Contest Solution\n---\n\n## 前言\n\n我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）\n然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了\n\n只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了\n<!--more-->\n下一場是在這週六晚上九點～十一點半\n撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走\n\n總之，過 Qualification Round 應該就算比去年好了\n去年在耍廢直接爆炸。。。\n\n希望今年可以去 Round 2\n\n先放上這次的[題目連結](https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705)\n\n## problem A\n\n### 題目\n\n現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了\n然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$\n**多筆測資**\n\n### 解法\n\n顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$\n一臉就是在跟你說開 string 存啊\n所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$\n然後把這兩個數字輸出\n**注意不能有前導零**\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, mi;\n    string n;\n    cin >> t;\n    for ( int tms = 1 ; tms <= t ; tms++ ){\n        cout << \"Case #\" << tms << \": \";\n        cin >> n;\n        mi = INF;\n        for ( int i = 0 ; i < n.size() ; i++ ){\n            if ( n[i] == '4' ){\n                mi = min ( mi, i );\n                cout << '3';\n            }\n            else\n                cout << n[i];\n        }\n\n        cout << ' ';\n\n        for ( int i = mi ; i < n.size() ; i++ )\n            cout << ( n[i] == '4' )\n        cout << '\\n';\n    }\n}\n```\n\n### 後記\n我還沒有注意到這題有保證輸入有 $4$\n也沒有注意到這題要求輸出都要是正整數\n運氣真好，歪歪得正\n\n\n## problem B\n\n### 題目\n\n給定一張二維圖以及一條從左上到右下的路線\n求一條不重複的另外一條路線\n所謂的路線重複是指 $a \\to b$ 這個邊同時出現在兩條路線中\n然後輸入都是SESE這樣，代表從起點開始他往哪些位置走\n並且保證只會往東（右）以及往南（下）走\n詳細請看這張圖\n![](pB.jpg)\n\n### 解法\n\n#### $O ( N ^ 2 )$\n\n垃圾如我，肯定只會寫 $N ^ 2$ 的解法\n簡單來說就是 dp\n我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存\n然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）\n接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）\n所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點\n\n不過這樣做有小地方需要注意一下\n理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ & $dp[i][j - 1]$ 轉移過來\n所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上\n如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來\n但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）\n因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移\n啊如果還是都可以拿，那就真的隨便了\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define mp make_pair\ntypedef pair < short, char > psc;\n\nbool lib[maxN][maxN];\npsc str[maxN][maxN];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n, x, y;\n    string data;\n    cin >> t;\n    for ( int tms = 1 ; tms <= t ; tms++ ){\n        cin >> n >> data;\n        memset ( lib, 0, sizeof lib );\n        for ( int i = 0 ; i <= n ; i++ ){\n            for ( int j = 0 ; j <= n ; j++ ){\n                str[i][j] = mp ( 0, ' ' );\n            }\n        }\n        x = 1, y = 1;\n        for ( auto i: data ){\n            lib[x][y] = true;\n            i == 'S' ? x++ : y++;\n        }\n        lib[x][y] = true;\n        str[1][1] = mp ( 0, ' ' );\n\n        for ( int i = 2 ; i <= n ; i++ ){\n            if ( lib[1][i] ){\n                if ( !lib[1][i - 1] ){\n                    str[1][i] = str[1][i - 1];\n                    str[1][i].F++;\n                    str[1][i].S = 'E';\n                }\n            }\n            else{\n                str[1][i] = str[1][i - 1];\n                str[1][i].F++;\n                str[1][i].S = 'E';\n            }\n        }\n\n        for ( int i = 2 ; i <= n ; i++ ){\n            if ( lib[i][1] ){\n                if ( !lib[i - 1][1] ){\n                    str[i][1] = str[i - 1][1];\n                    str[i][1].F++;\n                    str[i][1].S = 'S';\n                }\n            }\n            else{\n                str[i][1] = str[i - 1][1];\n                str[i][1].F++;\n                str[i][1].S = 'S';\n            }\n            for ( int j = 2 ; j <= n ; j++ ){\n                if ( lib[i][j] ){\n                    if ( !lib[i][j - 1] ){\n                        str[i][j] = str[i][j - 1];\n                        str[i][j].F++;\n                        str[i][j].S = 'E';\n                    }\n                    else{\n                        str[i][j] = str[i - 1][j];\n                        str[i][j].F++;\n                        str[i][j].S = 'S';\n                    }\n                }\n                else{\n                    if ( str[i][j - 1].F > str[i - 1][j].F ){\n                        str[i][j] = str[i][j - 1];\n                        str[i][j].S = 'E';\n                    }\n                    else{\n                        str[i][j] = str[i - 1][j];\n                        str[i][j].S = 'S';\n                    }\n                    str[i][j].F++;\n                }\n            }\n        }\n\n        data = \"\";\n        x = y = n;\n        while ( str[x][y].S != ' ' ){\n            data += str[x][y].S;\n            str[x][y].S == 'S' ? x-- : y--;\n        }\n        reverse ( data.begin(), data.end() );\n        cout << \"Case #\" << tms << \": \" << data << '\\n';\n    }\n}\n```\n\n#### $O ( N )$\n\n沒錯，$O ( N )$\n我後來才發現我TMD被哏到了\n只要把 S E 反轉就好啊\n讀到 S 輸出 E ，反之讀到 E 輸出 S\n這樣就會變成從左上到右下的對稱\n所以路線不會重複。。。\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n;\n    string str;\n    cin >> t;\n    while ( t-- && cin >> n >> str ){\n        for ( auto i: str )\n            cout << ( i == 'S' ? 'E' : 'S' );\n        cout << '\\n';\n    }\n}\n```\n\n## problem C\n\n感謝 [En-ming Huang](https://www.facebook.com/enminghuang1) 大大提供\n要 solution 請去找他\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint input[maxN], l;\nchar out[maxN][2], print[maxN];\n\nbool check ( int idx, char now ){\n    if ( idx == l ){\n        cout << print << '\\n';\n        return true;\n    }\n    for ( int i = 0 ; i < 2 ; i++ ){\n        if ( out[idx][i] != now )\n            continue;\n        print[idx] = out[idx][i];\n        if ( idx == l - 1 )\n            print[idx + 1] = out[idx][!i];\n        return check ( idx + 1, out[idx][!i] );\n    }\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, n, idx;\n    set < int > prime;\n    map < int, char > lib;\n    cin >> t;\n    for (int i = 1; i <= t; i++){\n        cin >> n >> l;\n        memset ( print, 0, sizeof print );\n        prime.clear();\n        lib.clear();\n        cout << \"Case #\" << i << \": \";\n        for ( int i = 0 ; i < l ; i++ ){\n            cin >> input[i];\n            for ( int j = 2 ; j <= n ; j++ ){\n                if ( input[i] % j == 0 ){\n                    prime.insert ( j );\n                    prime.insert ( input[i] / j );\n                    break;\n                }\n            }\n        }\n\n        idx = 0;\n        for ( auto i: prime )\n            lib[i] = 'A' + idx++;\n        for ( int i = 0 ; i < l ; i++ )\n            for ( int j = 2 ; j <= n ; j++ )\n                if ( input[i] % j == 0 ){\n                    out[i][0] = lib[j];\n                    out[i][1] = lib[input[i] / j];\n                    break;\n                }\n        for ( int i = 0 ; i < 2 ; i++ )\n            if ( check ( 0, out[0][i] ) )\n                break;\n    }\n    return 0;\n}\n```\n\n## 後記\n\n這場打起來感覺好廢\n最近比較少寫演算法競賽的題目\n幾乎都是在讀新東西\n手感感覺不是很好\n教練，我想要拿 T-Shirt\np.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！\n下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打\n而且時間上來說是 CodeForces 的 usaul time\n中國人應該不少（汗\n1A 1B 1C 要有一場前 1500 名才能進去啊（遠望\n覺得有點難@@\n\n最後放個計分板截圖\n![](scb.jpg)\n\n寫完這篇文章，在本地端用 hexo 編譯預覽出來後\n發現圖片邊緣有白框\n。。。\n好樣的，我又要來修 css 配置了\n工作量 up up\n = =","slug":"GCJ-2019-QuR","published":1,"updated":"2020-05-03T11:24:07.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsg000axl9pahg355ej","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）<br>然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了</p><p>只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了</p><a id=\"more\"></a><p>下一場是在這週六晚上九點～十一點半<br>撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走</p><p>總之，過 Qualification Round 應該就算比去年好了<br>去年在耍廢直接爆炸。。。</p><p>希望今年可以去 Round 2</p><p>先放上這次的<a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705\" target=\"_blank\" rel=\"noopener\">題目連結</a></p><h2 id=\"problem-A\"><a class=\"header-anchor\" href=\"#problem-A\"></a>problem A</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了<br>然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$<br><strong>多筆測資</strong></p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$<br>一臉就是在跟你說開 string 存啊<br>所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$<br>然後把這兩個數字輸出<br><strong>注意不能有前導零</strong></p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, mi;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> tms = <span class=\"number\">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; tms &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">        mi = INF;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n.size() ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( n[i] == <span class=\"string\">'4'</span> )&#123;</span><br><span class=\"line\">                mi = min ( mi, i );</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'3'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; n[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = mi ; i &lt; n.size() ; i++ )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ( n[i] == <span class=\"string\">'4'</span> )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h3><p>我還沒有注意到這題有保證輸入有 $4$<br>也沒有注意到這題要求輸出都要是正整數<br>運氣真好，歪歪得正</p><h2 id=\"problem-B\"><a class=\"header-anchor\" href=\"#problem-B\"></a>problem B</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一張二維圖以及一條從左上到右下的路線<br>求一條不重複的另外一條路線<br>所謂的路線重複是指 $a \\to b$ 這個邊同時出現在兩條路線中<br>然後輸入都是SESE這樣，代表從起點開始他往哪些位置走<br>並且保證只會往東（右）以及往南（下）走<br>詳細請看這張圖<br><img src=\"pB.jpg\" alt=\"\"></p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><h4 id=\"O-N-2\"><a class=\"header-anchor\" href=\"#O-N-2\"></a>$O ( N ^ 2 )$</h4><p>垃圾如我，肯定只會寫 $N ^ 2$ 的解法<br>簡單來說就是 dp<br>我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存<br>然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）<br>接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）<br>所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點</p><p>不過這樣做有小地方需要注意一下<br>理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ &amp; $dp[i][j - 1]$ 轉移過來<br>所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上<br>如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來<br>但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）<br>因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移<br>啊如果還是都可以拿，那就真的隨便了</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mp make_pair</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; short, <span class=\"keyword\">char</span> &gt; psc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lib[maxN][maxN];</span><br><span class=\"line\">psc str[maxN][maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n, x, y;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> data;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> tms = <span class=\"number\">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; data;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( lib, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> lib );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                str[i][j] = mp ( <span class=\"number\">0</span>, <span class=\"string\">' '</span> );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x = <span class=\"number\">1</span>, y = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )&#123;</span><br><span class=\"line\">            lib[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            i == <span class=\"string\">'S'</span> ? x++ : y++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lib[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        str[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = mp ( <span class=\"number\">0</span>, <span class=\"string\">' '</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( lib[<span class=\"number\">1</span>][i] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( !lib[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i] = str[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i].F++;</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i] = str[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i].F++;</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( lib[i][<span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( !lib[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>] = str[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>].F++;</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>] = str[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>].F++;</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( lib[i][j] )&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( !lib[i][j - <span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                        str[i][j] = str[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                        str[i][j].F++;</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        str[i][j] = str[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                        str[i][j].F++;</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( str[i][j - <span class=\"number\">1</span>].F &gt; str[i - <span class=\"number\">1</span>][j].F )&#123;</span><br><span class=\"line\">                        str[i][j] = str[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        str[i][j] = str[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    str[i][j].F++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        x = y = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( str[x][y].S != <span class=\"string\">' '</span> )&#123;</span><br><span class=\"line\">            data += str[x][y].S;</span><br><span class=\"line\">            str[x][y].S == <span class=\"string\">'S'</span> ? x-- : y--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse ( data.begin(), data.end() );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; tms &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; data &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"O-N\"><a class=\"header-anchor\" href=\"#O-N\"></a>$O ( N )$</h4><p>沒錯，$O ( N )$<br>我後來才發現我TMD被哏到了<br>只要把 S E 反轉就好啊<br>讀到 S 輸出 E ，反之讀到 E 輸出 S<br>這樣就會變成從左上到右下的對稱<br>所以路線不會重複。。。</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- &amp;&amp; <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; str )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ( i == <span class=\"string\">'S'</span> ? <span class=\"string\">'E'</span> : <span class=\"string\">'S'</span> );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-C\"><a class=\"header-anchor\" href=\"#problem-C\"></a>problem C</h2><p>感謝 <a href=\"https://www.facebook.com/enminghuang1\" target=\"_blank\" rel=\"noopener\">En-ming Huang</a> 大大提供<br>要 solution 請去找他</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> input[maxN], l;</span><br><span class=\"line\"><span class=\"keyword\">char</span> out[maxN][<span class=\"number\">2</span>], print[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span> <span class=\"params\">( <span class=\"keyword\">int</span> idx, <span class=\"keyword\">char</span> now )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( idx == l )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; print &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( out[idx][i] != now )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        print[idx] = out[idx][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( idx == l - <span class=\"number\">1</span> )</span><br><span class=\"line\">            print[idx + <span class=\"number\">1</span>] = out[idx][!i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check ( idx + <span class=\"number\">1</span>, out[idx][!i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n, idx;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; prime;</span><br><span class=\"line\">    <span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= t; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( print, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> print );</span><br><span class=\"line\">        prime.clear();</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; l ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; input[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( input[i] % j == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                    prime.insert ( j );</span><br><span class=\"line\">                    prime.insert ( input[i] / j );</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: prime )</span><br><span class=\"line\">            lib[i] = <span class=\"string\">'A'</span> + idx++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; l ; i++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( input[i] % j == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                    out[i][<span class=\"number\">0</span>] = lib[j];</span><br><span class=\"line\">                    out[i][<span class=\"number\">1</span>] = lib[input[i] / j];</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++ )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( check ( <span class=\"number\">0</span>, out[<span class=\"number\">0</span>][i] ) )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記-v2\"><a class=\"header-anchor\" href=\"#後記-v2\"></a>後記</h2><p>這場打起來感覺好廢<br>最近比較少寫演算法競賽的題目<br>幾乎都是在讀新東西<br>手感感覺不是很好<br>教練，我想要拿 T-Shirt<br>p.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！<br>下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打<br>而且時間上來說是 CodeForces 的 usaul time<br>中國人應該不少（汗<br>1A 1B 1C 要有一場前 1500 名才能進去啊（遠望<br>覺得有點難@@</p><p>最後放個計分板截圖<br><img src=\"scb.jpg\" alt=\"\"></p><p>寫完這篇文章，在本地端用 hexo 編譯預覽出來後<br>發現圖片邊緣有白框<br>。。。<br>好樣的，我又要來修 css 配置了<br>工作量 up up<br>= =</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）<br>然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了</p><p>只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了</p>","more":"<p>下一場是在這週六晚上九點～十一點半<br>撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走</p><p>總之，過 Qualification Round 應該就算比去年好了<br>去年在耍廢直接爆炸。。。</p><p>希望今年可以去 Round 2</p><p>先放上這次的<a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705\" target=\"_blank\" rel=\"noopener\">題目連結</a></p><h2 id=\"problem-A\"><a class=\"header-anchor\" href=\"#problem-A\"></a>problem A</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了<br>然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$<br><strong>多筆測資</strong></p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$<br>一臉就是在跟你說開 string 存啊<br>所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$<br>然後把這兩個數字輸出<br><strong>注意不能有前導零</strong></p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, mi;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> tms = <span class=\"number\">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; tms &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">        mi = INF;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n.size() ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( n[i] == <span class=\"string\">'4'</span> )&#123;</span><br><span class=\"line\">                mi = min ( mi, i );</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'3'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; n[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = mi ; i &lt; n.size() ; i++ )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ( n[i] == <span class=\"string\">'4'</span> )</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h3><p>我還沒有注意到這題有保證輸入有 $4$<br>也沒有注意到這題要求輸出都要是正整數<br>運氣真好，歪歪得正</p><h2 id=\"problem-B\"><a class=\"header-anchor\" href=\"#problem-B\"></a>problem B</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給定一張二維圖以及一條從左上到右下的路線<br>求一條不重複的另外一條路線<br>所謂的路線重複是指 $a \\to b$ 這個邊同時出現在兩條路線中<br>然後輸入都是SESE這樣，代表從起點開始他往哪些位置走<br>並且保證只會往東（右）以及往南（下）走<br>詳細請看這張圖<br><img src=\"pB.jpg\" alt=\"\"></p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><h4 id=\"O-N-2\"><a class=\"header-anchor\" href=\"#O-N-2\"></a>$O ( N ^ 2 )$</h4><p>垃圾如我，肯定只會寫 $N ^ 2$ 的解法<br>簡單來說就是 dp<br>我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存<br>然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）<br>接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）<br>所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點</p><p>不過這樣做有小地方需要注意一下<br>理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ &amp; $dp[i][j - 1]$ 轉移過來<br>所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上<br>如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來<br>但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）<br>因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移<br>啊如果還是都可以拿，那就真的隨便了</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mp make_pair</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; short, <span class=\"keyword\">char</span> &gt; psc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> lib[maxN][maxN];</span><br><span class=\"line\">psc str[maxN][maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n, x, y;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> data;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> tms = <span class=\"number\">1</span> ; tms &lt;= t ; tms++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; data;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( lib, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> lib );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                str[i][j] = mp ( <span class=\"number\">0</span>, <span class=\"string\">' '</span> );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        x = <span class=\"number\">1</span>, y = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: data )&#123;</span><br><span class=\"line\">            lib[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            i == <span class=\"string\">'S'</span> ? x++ : y++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lib[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        str[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = mp ( <span class=\"number\">0</span>, <span class=\"string\">' '</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( lib[<span class=\"number\">1</span>][i] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( !lib[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i] = str[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i].F++;</span><br><span class=\"line\">                    str[<span class=\"number\">1</span>][i].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i] = str[<span class=\"number\">1</span>][i - <span class=\"number\">1</span>];</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i].F++;</span><br><span class=\"line\">                str[<span class=\"number\">1</span>][i].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">2</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( lib[i][<span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( !lib[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>] = str[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>].F++;</span><br><span class=\"line\">                    str[i][<span class=\"number\">1</span>].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>] = str[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>].F++;</span><br><span class=\"line\">                str[i][<span class=\"number\">1</span>].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( lib[i][j] )&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( !lib[i][j - <span class=\"number\">1</span>] )&#123;</span><br><span class=\"line\">                        str[i][j] = str[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                        str[i][j].F++;</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        str[i][j] = str[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                        str[i][j].F++;</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( str[i][j - <span class=\"number\">1</span>].F &gt; str[i - <span class=\"number\">1</span>][j].F )&#123;</span><br><span class=\"line\">                        str[i][j] = str[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'E'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        str[i][j] = str[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                        str[i][j].S = <span class=\"string\">'S'</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    str[i][j].F++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        x = y = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( str[x][y].S != <span class=\"string\">' '</span> )&#123;</span><br><span class=\"line\">            data += str[x][y].S;</span><br><span class=\"line\">            str[x][y].S == <span class=\"string\">'S'</span> ? x-- : y--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse ( data.begin(), data.end() );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; tms &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; data &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"O-N\"><a class=\"header-anchor\" href=\"#O-N\"></a>$O ( N )$</h4><p>沒錯，$O ( N )$<br>我後來才發現我TMD被哏到了<br>只要把 S E 反轉就好啊<br>讀到 S 輸出 E ，反之讀到 E 輸出 S<br>這樣就會變成從左上到右下的對稱<br>所以路線不會重複。。。</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- &amp;&amp; <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; str )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; ( i == <span class=\"string\">'S'</span> ? <span class=\"string\">'E'</span> : <span class=\"string\">'S'</span> );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-C\"><a class=\"header-anchor\" href=\"#problem-C\"></a>problem C</h2><p>感謝 <a href=\"https://www.facebook.com/enminghuang1\" target=\"_blank\" rel=\"noopener\">En-ming Huang</a> 大大提供<br>要 solution 請去找他</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> input[maxN], l;</span><br><span class=\"line\"><span class=\"keyword\">char</span> out[maxN][<span class=\"number\">2</span>], print[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span> <span class=\"params\">( <span class=\"keyword\">int</span> idx, <span class=\"keyword\">char</span> now )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( idx == l )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; print &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( out[idx][i] != now )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        print[idx] = out[idx][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( idx == l - <span class=\"number\">1</span> )</span><br><span class=\"line\">            print[idx + <span class=\"number\">1</span>] = out[idx][!i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check ( idx + <span class=\"number\">1</span>, out[idx][!i] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, n, idx;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; prime;</span><br><span class=\"line\">    <span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= t; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( print, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> print );</span><br><span class=\"line\">        prime.clear();</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case #\"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\": \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; l ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; input[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( input[i] % j == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                    prime.insert ( j );</span><br><span class=\"line\">                    prime.insert ( input[i] / j );</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: prime )</span><br><span class=\"line\">            lib[i] = <span class=\"string\">'A'</span> + idx++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; l ; i++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">2</span> ; j &lt;= n ; j++ )</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( input[i] % j == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                    out[i][<span class=\"number\">0</span>] = lib[j];</span><br><span class=\"line\">                    out[i][<span class=\"number\">1</span>] = lib[input[i] / j];</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++ )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( check ( <span class=\"number\">0</span>, out[<span class=\"number\">0</span>][i] ) )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記-v2\"><a class=\"header-anchor\" href=\"#後記-v2\"></a>後記</h2><p>這場打起來感覺好廢<br>最近比較少寫演算法競賽的題目<br>幾乎都是在讀新東西<br>手感感覺不是很好<br>教練，我想要拿 T-Shirt<br>p.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！<br>下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打<br>而且時間上來說是 CodeForces 的 usaul time<br>中國人應該不少（汗<br>1A 1B 1C 要有一場前 1500 名才能進去啊（遠望<br>覺得有點難@@</p><p>最後放個計分板截圖<br><img src=\"scb.jpg\" alt=\"\"></p><p>寫完這篇文章，在本地端用 hexo 編譯預覽出來後<br>發現圖片邊緣有白框<br>。。。<br>好樣的，我又要來修 css 配置了<br>工作量 up up<br>= =</p><!-- rebuild by neat -->"},{"title":"[TIOJ][1795] 咕嚕咕嚕呱啦呱啦","date":"2018-01-16T03:53:57.000Z","_content":"\n這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧\n\n## 題目\n\n題目連結[在這](https://tioj.ck.tp.edu.tw/problems/1795)\n\n給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$\n另外，任意一條邊的權重只有可能為 $0 or 1$\n<!--more-->\n\n\n## 解法\n\n只要做出最小生成樹以及最大生成樹就好了，證明如下\n假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：\n$$ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )$$\n又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\\le k\\e ub$ 的生成樹\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 100005\n\nstruct bridge{\n    int u, v, w;\n};\n\nstruct disjionSet{\n    int dis[maxN];\n\n    inline void Init ( void ){\n        for ( int i = 0 ; i < maxN ; i++ )\n            dis[i] = i;\n    }\n\n    inline int find ( int n ){\n        return dis[n] == n ? n : dis[n] = find ( dis[n] );\n    }\n\n    inline bool same ( int a, int b ){\n        return find ( a ) == find ( b );\n    }\n\n    inline void Union ( int a, int b ){\n        dis[find ( a )] = find ( b );\n    }\n};\n\nvector < bridge > edges;\n\ninline bool cmp ( bridge a, bridge b ){\n    return a.w < b.w;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, k, u, v, w, ub = 0, lb = 0;\n    disjionSet dis;\n    cin >> n >> m >> k;\n    while ( m-- ){\n        cin >> u >> v >> w;\n        edges.push_back ( bridge { u, v, w } );\n    }\n\n    sort ( edges.begin(), edges.end(), cmp );\n    dis.Init();\n    for ( auto i: edges ){\n        if ( dis.same ( i.u, i.v ) )\n            continue;\n\n        dis.Union ( i.u, i.v );\n        lb += i.w;\n    }\n\n\n    reverse ( edges.begin(), edges.end() );\n    dis.Init();\n    for ( auto i: edges ){\n        if ( dis.same ( i.u, i.v ) )\n            continue;\n\n        dis.Union ( i.u, i.v );\n        ub += i.w;\n    }\n\n    cout << ( lb <= k && k <= ub ? \"TAK\" : \"NIE\" ) << '\\n';\n}\n```","source":"_posts/TIOJ-1795.md","raw":"---\ntitle: '[TIOJ][1795] 咕嚕咕嚕呱啦呱啦'\ndate: 2018-01-16 11:53:57\ntags:\n - TIOJ\n - math\n---\n\n這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧\n\n## 題目\n\n題目連結[在這](https://tioj.ck.tp.edu.tw/problems/1795)\n\n給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$\n另外，任意一條邊的權重只有可能為 $0 or 1$\n<!--more-->\n\n\n## 解法\n\n只要做出最小生成樹以及最大生成樹就好了，證明如下\n假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：\n$$ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )$$\n又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\\le k\\e ub$ 的生成樹\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define maxN 100005\n\nstruct bridge{\n    int u, v, w;\n};\n\nstruct disjionSet{\n    int dis[maxN];\n\n    inline void Init ( void ){\n        for ( int i = 0 ; i < maxN ; i++ )\n            dis[i] = i;\n    }\n\n    inline int find ( int n ){\n        return dis[n] == n ? n : dis[n] = find ( dis[n] );\n    }\n\n    inline bool same ( int a, int b ){\n        return find ( a ) == find ( b );\n    }\n\n    inline void Union ( int a, int b ){\n        dis[find ( a )] = find ( b );\n    }\n};\n\nvector < bridge > edges;\n\ninline bool cmp ( bridge a, bridge b ){\n    return a.w < b.w;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, k, u, v, w, ub = 0, lb = 0;\n    disjionSet dis;\n    cin >> n >> m >> k;\n    while ( m-- ){\n        cin >> u >> v >> w;\n        edges.push_back ( bridge { u, v, w } );\n    }\n\n    sort ( edges.begin(), edges.end(), cmp );\n    dis.Init();\n    for ( auto i: edges ){\n        if ( dis.same ( i.u, i.v ) )\n            continue;\n\n        dis.Union ( i.u, i.v );\n        lb += i.w;\n    }\n\n\n    reverse ( edges.begin(), edges.end() );\n    dis.Init();\n    for ( auto i: edges ){\n        if ( dis.same ( i.u, i.v ) )\n            continue;\n\n        dis.Union ( i.u, i.v );\n        ub += i.w;\n    }\n\n    cout << ( lb <= k && k <= ub ? \"TAK\" : \"NIE\" ) << '\\n';\n}\n```","slug":"TIOJ-1795","published":1,"updated":"2020-05-03T11:24:07.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsh000cxl9pfgah96pn","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><p>這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧</p><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>題目連結<a href=\"https://tioj.ck.tp.edu.tw/problems/1795\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$<br>另外，任意一條邊的權重只有可能為 $0 or 1$</p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>只要做出最小生成樹以及最大生成樹就好了，證明如下<br>假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：<br>$$ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )$$<br>又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\\le k\\e ub$ 的生成樹</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 100005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bridge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">disjionSet</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">            dis[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">        dis[find ( a )] = find ( b );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; bridge &gt; edges;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">cmp</span> <span class=\"params\">( bridge a, bridge b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, k, u, v, w, ub = <span class=\"number\">0</span>, lb = <span class=\"number\">0</span>;</span><br><span class=\"line\">    disjionSet dis;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class=\"line\">        edges.push_back ( bridge &#123; u, v, w &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class=\"line\">    dis.Init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dis.Union ( i.u, i.v );</span><br><span class=\"line\">        lb += i.w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    reverse ( edges.begin(), edges.end() );</span><br><span class=\"line\">    dis.Init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dis.Union ( i.u, i.v );</span><br><span class=\"line\">        ub += i.w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ( lb &lt;= k &amp;&amp; k &lt;= ub ? <span class=\"string\">\"TAK\"</span> : <span class=\"string\">\"NIE\"</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><p>這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧</p><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>題目連結<a href=\"https://tioj.ck.tp.edu.tw/problems/1795\" target=\"_blank\" rel=\"noopener\">在這</a></p><p>給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$<br>另外，任意一條邊的權重只有可能為 $0 or 1$</p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>只要做出最小生成樹以及最大生成樹就好了，證明如下<br>假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：<br>$$ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )$$<br>又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\\le k\\e ub$ 的生成樹</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 100005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bridge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">disjionSet</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">            dis[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">        dis[find ( a )] = find ( b );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; bridge &gt; edges;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">cmp</span> <span class=\"params\">( bridge a, bridge b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, k, u, v, w, ub = <span class=\"number\">0</span>, lb = <span class=\"number\">0</span>;</span><br><span class=\"line\">    disjionSet dis;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class=\"line\">        edges.push_back ( bridge &#123; u, v, w &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class=\"line\">    dis.Init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dis.Union ( i.u, i.v );</span><br><span class=\"line\">        lb += i.w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    reverse ( edges.begin(), edges.end() );</span><br><span class=\"line\">    dis.Init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        dis.Union ( i.u, i.v );</span><br><span class=\"line\">        ub += i.w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ( lb &lt;= k &amp;&amp; k &lt;= ub ? <span class=\"string\">\"TAK\"</span> : <span class=\"string\">\"NIE\"</span> ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"[TIOJ][1940]Nim","date":"2017-12-26T12:28:32.000Z","_content":"\n## 題目\n\n這題目很哏，真得很哏\n哏到我都快不想寫了（結果還是用兩節課 AC 了）\n題目略過，要看原題的[在這](https://tioj.ck.tp.edu.tw/problems/1940)\n<!--more-->\n\n\n## 解法\n\n我看完題目第一個想法就是 DP\n\n。。。然後我就 TLE 了（廢話\n\n因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP\n但是請看範圍：$1e9$，怎麼看都會 TLE\n所以只能想一下數學解法了\n\n$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏\n\n接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：\n$$0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6$$\n經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\\frac{n}{2}$ 就好了\n\n接著再分兩個case : $n$ 為奇術時\n\ncase 餘一：$\\frac{n}{4}$ 的整數部分 $\\to \\lfloor \\frac{n}{4} \\rfloor$\ncase 餘三：$f ( 2, \\frac{n}{2} ) \\to$直接對這個函數做遞迴就好\n\n總結一下，函數大概長這樣\n\n$$f ( k, n ) =\n\\begin{cases}\nn, & \\text{if $k$ is $1$} \\\\\n\\begin{cases}\n\\frac{n}{2}, & \\text{if $n$ is even} \\\\\n\\lfloor \\frac{n}{4} \\rfloor, & \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\\\\nf ( 2, \\frac{n}{2} ), & \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }\n\\end{cases}, & \\text{if $k$ is $2$ }\n\\end{cases}\n$$\n\n因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define maxN 10005\n\ninline int count ( int n ){\n    switch ( n ){\n        case 3:\n        case 1: return 1;\n        case 5:\n        case 2: return 0;\n        default: \n            switch ( n % 4 ){\n                case 2:\n                case 0: return n / 2;\n                case 1: return n / 4;\n                case 3: return count ( n / 2 );\n            }\n    }\n    return 0;\n}\n\nint main(){\n    int k, m;\n    scanf ( \"%d%d\", &k, &m );\n    printf ( \"%d\\n\", ( k == 1 ? m : count ( m ) ) );\n}\n```\n\n## 後記(2019/03/23 00:29)\n\n為了能讓這篇文章的函數好看一些\n硬生生讓 hexo 支援 mathjax 了\n然後上面那個精美的函式，我把原始碼放這邊\n\n```\n$$\nf ( k, n ) =\n\\begin{cases}\nn, & \\text{if $k$ is $1$} \\\\\n\\begin{cases}\n\\frac{n}{2}, & \\text{if $n$ is even} \\\\\n\\lfloor \\frac{n}{4} \\rfloor, & \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\\\\nf ( 2, \\frac{n}{2} ), & \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }\n\\end{cases}, & \\text{if $k$ is $2$ }\n\\end{cases}\n$$\n```","source":"_posts/TIOJ-1940.md","raw":"---\ntitle: '[TIOJ][1940]Nim'\ndate: 2017-12-26 20:28:32\ntags: \n - TIOJ\n - math\n---\n\n## 題目\n\n這題目很哏，真得很哏\n哏到我都快不想寫了（結果還是用兩節課 AC 了）\n題目略過，要看原題的[在這](https://tioj.ck.tp.edu.tw/problems/1940)\n<!--more-->\n\n\n## 解法\n\n我看完題目第一個想法就是 DP\n\n。。。然後我就 TLE 了（廢話\n\n因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP\n但是請看範圍：$1e9$，怎麼看都會 TLE\n所以只能想一下數學解法了\n\n$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏\n\n接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：\n$$0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6$$\n經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\\frac{n}{2}$ 就好了\n\n接著再分兩個case : $n$ 為奇術時\n\ncase 餘一：$\\frac{n}{4}$ 的整數部分 $\\to \\lfloor \\frac{n}{4} \\rfloor$\ncase 餘三：$f ( 2, \\frac{n}{2} ) \\to$直接對這個函數做遞迴就好\n\n總結一下，函數大概長這樣\n\n$$f ( k, n ) =\n\\begin{cases}\nn, & \\text{if $k$ is $1$} \\\\\n\\begin{cases}\n\\frac{n}{2}, & \\text{if $n$ is even} \\\\\n\\lfloor \\frac{n}{4} \\rfloor, & \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\\\\nf ( 2, \\frac{n}{2} ), & \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }\n\\end{cases}, & \\text{if $k$ is $2$ }\n\\end{cases}\n$$\n\n因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define maxN 10005\n\ninline int count ( int n ){\n    switch ( n ){\n        case 3:\n        case 1: return 1;\n        case 5:\n        case 2: return 0;\n        default: \n            switch ( n % 4 ){\n                case 2:\n                case 0: return n / 2;\n                case 1: return n / 4;\n                case 3: return count ( n / 2 );\n            }\n    }\n    return 0;\n}\n\nint main(){\n    int k, m;\n    scanf ( \"%d%d\", &k, &m );\n    printf ( \"%d\\n\", ( k == 1 ? m : count ( m ) ) );\n}\n```\n\n## 後記(2019/03/23 00:29)\n\n為了能讓這篇文章的函數好看一些\n硬生生讓 hexo 支援 mathjax 了\n然後上面那個精美的函式，我把原始碼放這邊\n\n```\n$$\nf ( k, n ) =\n\\begin{cases}\nn, & \\text{if $k$ is $1$} \\\\\n\\begin{cases}\n\\frac{n}{2}, & \\text{if $n$ is even} \\\\\n\\lfloor \\frac{n}{4} \\rfloor, & \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\\\\nf ( 2, \\frac{n}{2} ), & \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }\n\\end{cases}, & \\text{if $k$ is $2$ }\n\\end{cases}\n$$\n```","slug":"TIOJ-1940","published":1,"updated":"2020-05-03T11:24:07.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsj000dxl9pe0fj4efv","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>這題目很哏，真得很哏<br>哏到我都快不想寫了（結果還是用兩節課 AC 了）<br>題目略過，要看原題的<a href=\"https://tioj.ck.tp.edu.tw/problems/1940\" target=\"_blank\" rel=\"noopener\">在這</a></p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>我看完題目第一個想法就是 DP</p><p>。。。然後我就 TLE 了（廢話</p><p>因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP<br>但是請看範圍：$1e9$，怎麼看都會 TLE<br>所以只能想一下數學解法了</p><p>$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏</p><p>接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：<br>$$0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6$$<br>經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\\frac{n}{2}$ 就好了</p><p>接著再分兩個case : $n$ 為奇術時</p><p>case 餘一：$\\frac{n}{4}$ 的整數部分 $\\to \\lfloor \\frac{n}{4} \\rfloor$<br>case 餘三：$f ( 2, \\frac{n}{2} ) \\to$直接對這個函數做遞迴就好</p><p>總結一下，函數大概長這樣</p><p>$$f ( k, n ) =<br>\\begin{cases}<br>n, &amp; \\text{if $k$ is $1$} \\<br>\\begin{cases}<br>\\frac{n}{2}, &amp; \\text{if $n$ is even} \\<br>\\lfloor \\frac{n}{4} \\rfloor, &amp; \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\<br>f ( 2, \\frac{n}{2} ), &amp; \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }<br>\\end{cases}, &amp; \\text{if $k$ is $2$ }<br>\\end{cases}<br>$$</p><p>因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 10005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">count</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> ( n )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: </span><br><span class=\"line\">            <span class=\"keyword\">switch</span> ( n % <span class=\"number\">4</span> )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> n / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> n / <span class=\"number\">4</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> count ( n / <span class=\"number\">2</span> );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k, m;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span> ( <span class=\"string\">\"%d%d\"</span>, &amp;k, &amp;m );</span><br><span class=\"line\">    <span class=\"built_in\">printf</span> ( <span class=\"string\">\"%d\\n\"</span>, ( k == <span class=\"number\">1</span> ? m : count ( m ) ) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記-2019-03-23-00-29\"><a class=\"header-anchor\" href=\"#後記-2019-03-23-00-29\"></a>後記(2019/03/23 00:29)</h2><p>為了能讓這篇文章的函數好看一些<br>硬生生讓 hexo 支援 mathjax 了<br>然後上面那個精美的函式，我把原始碼放這邊</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$</span><br><span class=\"line\">f ( k, n ) &#x3D;</span><br><span class=\"line\">\\begin&#123;cases&#125;</span><br><span class=\"line\">n, &amp; \\text&#123;if $k$ is $1$&#125; \\\\</span><br><span class=\"line\">\\begin&#123;cases&#125;</span><br><span class=\"line\">\\frac&#123;n&#125;&#123;2&#125;, &amp; \\text&#123;if $n$ is even&#125; \\\\</span><br><span class=\"line\">\\lfloor \\frac&#123;n&#125;&#123;4&#125; \\rfloor, &amp; \\text&#123;if $n &#x3D; 4\\times k + 1 ( k \\in \\mathbb&#123;R&#125; )$ &#125; \\\\</span><br><span class=\"line\">f ( 2, \\frac&#123;n&#125;&#123;2&#125; ), &amp; \\text&#123;if $n &#x3D; 4\\times k + 3 ( k \\in \\mathbb&#123;R&#125; )$ &#125;</span><br><span class=\"line\">\\end&#123;cases&#125;, &amp; \\text&#123;if $k$ is $2$ &#125;</span><br><span class=\"line\">\\end&#123;cases&#125;</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>這題目很哏，真得很哏<br>哏到我都快不想寫了（結果還是用兩節課 AC 了）<br>題目略過，要看原題的<a href=\"https://tioj.ck.tp.edu.tw/problems/1940\" target=\"_blank\" rel=\"noopener\">在這</a></p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>我看完題目第一個想法就是 DP</p><p>。。。然後我就 TLE 了（廢話</p><p>因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP<br>但是請看範圍：$1e9$，怎麼看都會 TLE<br>所以只能想一下數學解法了</p><p>$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏</p><p>接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：<br>$$0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6$$<br>經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\\frac{n}{2}$ 就好了</p><p>接著再分兩個case : $n$ 為奇術時</p><p>case 餘一：$\\frac{n}{4}$ 的整數部分 $\\to \\lfloor \\frac{n}{4} \\rfloor$<br>case 餘三：$f ( 2, \\frac{n}{2} ) \\to$直接對這個函數做遞迴就好</p><p>總結一下，函數大概長這樣</p><p>$$f ( k, n ) =<br>\\begin{cases}<br>n, &amp; \\text{if $k$ is $1$} \\<br>\\begin{cases}<br>\\frac{n}{2}, &amp; \\text{if $n$ is even} \\<br>\\lfloor \\frac{n}{4} \\rfloor, &amp; \\text{if $n = 4\\times k + 1 ( k \\in \\mathbb{R} )$ } \\<br>f ( 2, \\frac{n}{2} ), &amp; \\text{if $n = 4\\times k + 3 ( k \\in \\mathbb{R} )$ }<br>\\end{cases}, &amp; \\text{if $k$ is $2$ }<br>\\end{cases}<br>$$</p><p>因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 10005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">count</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> ( n )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: </span><br><span class=\"line\">            <span class=\"keyword\">switch</span> ( n % <span class=\"number\">4</span> )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> n / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> n / <span class=\"number\">4</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> count ( n / <span class=\"number\">2</span> );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k, m;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span> ( <span class=\"string\">\"%d%d\"</span>, &amp;k, &amp;m );</span><br><span class=\"line\">    <span class=\"built_in\">printf</span> ( <span class=\"string\">\"%d\\n\"</span>, ( k == <span class=\"number\">1</span> ? m : count ( m ) ) );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記-2019-03-23-00-29\"><a class=\"header-anchor\" href=\"#後記-2019-03-23-00-29\"></a>後記(2019/03/23 00:29)</h2><p>為了能讓這篇文章的函數好看一些<br>硬生生讓 hexo 支援 mathjax 了<br>然後上面那個精美的函式，我把原始碼放這邊</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$$</span><br><span class=\"line\">f ( k, n ) &#x3D;</span><br><span class=\"line\">\\begin&#123;cases&#125;</span><br><span class=\"line\">n, &amp; \\text&#123;if $k$ is $1$&#125; \\\\</span><br><span class=\"line\">\\begin&#123;cases&#125;</span><br><span class=\"line\">\\frac&#123;n&#125;&#123;2&#125;, &amp; \\text&#123;if $n$ is even&#125; \\\\</span><br><span class=\"line\">\\lfloor \\frac&#123;n&#125;&#123;4&#125; \\rfloor, &amp; \\text&#123;if $n &#x3D; 4\\times k + 1 ( k \\in \\mathbb&#123;R&#125; )$ &#125; \\\\</span><br><span class=\"line\">f ( 2, \\frac&#123;n&#125;&#123;2&#125; ), &amp; \\text&#123;if $n &#x3D; 4\\times k + 3 ( k \\in \\mathbb&#123;R&#125; )$ &#125;</span><br><span class=\"line\">\\end&#123;cases&#125;, &amp; \\text&#123;if $k$ is $2$ &#125;</span><br><span class=\"line\">\\end&#123;cases&#125;</span><br><span class=\"line\">$$</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"[TIOJ][1909] 勇者出征","date":"2019-01-04T01:46:38.000Z","_content":"\n## 題目\n\n[原題目連結](https://tioj.ck.tp.edu.tw/problems/1909)\n據說是 2015TOI 三模的題目\n簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：\n1. 從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個\n2.    假設 $D$ 可以連結到 $A$ 的話（$D的高度 \\lt A$），那麼$A$也可以到 $D$\n\n求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號\n如果有多組解，輸出編號最小的\n<!--more-->\n\n\n## 解法\n\n我們先來釐清一下什麼是簡單路徑好了\n所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑\n\n### 建圖\n\n看到路徑，我第一個想到的是圖論\n我們先想一下，要怎麼把圖建出來\n\n#### 暴力 $O ( N^2 )$\n\n$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較\n```cpp\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\nfor ( int i = 0 ; i < n ; i++ ){\n    int l = -1, r = n;\n    for ( int j = i - 1 ; j >= 0 ; j-- )\n        if ( data[j] > data[i] ){\n            l = j;\n            break;\n        }\n    for ( int j = i + 1 ; j < n ; j++ )\n        if ( data[j] > data[i] ){\n            r = j;\n            break;\n        }\n    if ( l == -1 && r == n )\n        continue;\n    if ( l == -1 ){\n        UNI ( r, i, edges );\n        continue;\n    }\n    if ( r == n ){\n        UNI ( l, i, edges );\n        continue;\n    }\n    UNI ( ( data[l] < data[r] ? l : r ), i, edges );\n}\n```\n\n#### 線段樹 $O ( NlogN )$\n\n然後我就想到線段樹了\n$index$ 是做離散化後的數字，$value$ 是編號\n然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值\n一開始右手邊的最小值線段樹，裡面有$N$個點\n每處理完一個點，就把這個點拔掉丟到左邊去\ncode大概像這樣\n```cpp\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n#define INF 0x3f3f3f3f\n\n// function\n// 線段樹1是紀錄最小值、右手邊的線段樹\n// 而線段數2是紀錄最大值、左手邊的線段樹\nint seg1[maxN << 2], seg2[maxN << 2];\nvoid update1 ( int l, int r, int index, int value, int n );\nint query1 ( int l, int r, int nowL, int nowR, int n );\nvoid update2 ( int l, int r, int index, int value, int n );\nint query2 ( int l, int r, int index, int value, int n );\n\n// lib是已經做完離散化的數列\nmemset ( seg1, INF, sizeof seg1 );\nmemset ( seg2, -1, sizeof seg2 )\nfor ( int i = 0 ; i < n ; i++ )\n    update1 ( 0, n, i, lib[i], 1 );\n\nfor ( int i = 0 ; i < n ; i++ ){\n    int l = query2 ( lib[i] + 1, n, 0, n, 1 );\n    int r = query1 ( lib[i] + 1, n, 0, n, 1 );\n    if ( l == -1 && r == INF )\n        continue;\n    if ( l == -1 ){\n        UNI ( i, r, edges );\n        continue;\n    }\n    if ( r == INF ){\n        UNI ( i, l, edges );\n        continue;\n    }\n    UNI ( i, ( data[l] < data[r] ? l : r ), edges );\n\n    update1 ( 0, n, INF, lib[i], 1 );\n    update2 ( 0, n, i, lib[i], 1 );\n}\n```\n\n#### 單調列隊優化 $O ( N )$\n\n關於單調列隊優化的介紹可以看這份建中講義第二頁[這邊](https://goo.gl/e12UAo)\n\n根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的\n\n那麼假設要插入一個數字呢？\n假設現在這個數字比最後一個還要大，那麼我們就不斷的拔\n拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候\n接著把這些拔掉的數字與 $A$ 做連接\n\n不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？\n因為他是說兩邊第一個比她大的數字的 min\n既然兩邊都比他大，那麼當然選小的啊\n\n最後這個 deque 會保證遞減\n那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L'$ 做連結\n直到這個 deque 清空為止\n\n不過因為只需要從後端做操作\n所以用 stack 就可以了\n\n詳細的 code 請看這\n```cpp\ntypedef pair < int, int > pii;\n#define F first\n#define S second\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n\n// data 是原數列\nstack < pii, vector < pii > > st;\n// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）\npii swp;\nst.push ( pii ( data[0], 0 ) );\nfor ( int i = 1 ; i < n ; i++ ){\n    while ( !st.empty() && data[i] > st.top().F ){\n        swp = st.top();\n        st.pop();\n        if ( EMP ( st ) )\n            UNI ( swp.S, i, edges );\n        else\n            UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );\n    }\n    st.push ( pii ( data[i], i ) );\n}\nswp = st.top();\nst.pop();\nwhile ( !st.empty() ){\n    UNI ( swp.S, st.top().S, edges );\n    swp = st.top();\n    st.pop();\n}\n```\n\n### 是時候來處理路徑囉\n\n至於這個題目的另外一個部分：路徑\n又該怎麼處理呢？\n我們可以發現，這份資料轉換完之後保證是二元樹\n為什麼？\n因為他最多只會被兩個其他的點連結（左邊一個右邊一個）\n而自己只會連結到一個點\n那麼這不就是二元樹嗎？\n那麼，通過點 $u$ 的路徑會有三種：\n1. $u$ 的祖先到 $u$ 的子孫的路徑\n2. $u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑\n3. 從 $u$ 開始（或結束）的路徑\n\n我們先定義\n$$dp[u] = u的子孫數目（包含 u ）$$\n\n因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）\n因此只要計算起點終點的組合數就好了\n\n那麼 1. 就很好算啦\n$$( 總點數 - dp[n] - 1 )\\times ( dp[n] - 1 )$$\n\n那麼 2. 呢？\n上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）\n所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\\times dp[n]$）就是答案了\n\n呃，3. 應該就不用講了吧 = =\n就 總點數減一啊 = =\n\n然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）\n\n綜合一二三，所以只需要dfs一次就好了\n\n這部分的code我放這\n```cpp\n#define maxN 1000005\nvector < int > edges[maxN];\nint cnt[maxN], dp[maxN], N;\n// N = 總點數 - 1\n\nvoid dfs ( int n,  int p ){\n    int a = -1, b = -1;\n    for ( auto i: edges[n] ){\n        if ( i == p )\n            continue;\n        if ( a == -1 )\n            a = i;\n        else\n            b = i;\n        dfs ( i, n );\n        dp[n] += dp[i];\n    }\n    cnt[n] += ( N - dp[n] ) * dp[n]; // 祖先到子孫\n    if ( deges[n].size() == 3 ) // 如果是有兩個子孫的話\n        cnt[n] += dp[a] * dp[b];\n    dp[n]++; // 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1\n    cnt[n] += N;\n    cnt[n] <<= 1; // 記得乘二喔\n}\n```\n\n## code\n\n綜合以上，我的code長這樣\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntypedef pair < int, int > pii;\n#define pb push_back\n#define F first\n#define S second\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n#define maxN 1000005\n\nvector < int > edges[maxN];\nLL dp[maxN], N, cnt[maxN];\n\nvoid dfs ( int n,  int p ){\n    int a = -1, b = -1;\n    for ( auto i: edges[n] ){\n        if ( i == p )\n            continue;\n        if ( a == -1 )\n            a = i;\n        else\n            b = i;\n        dfs ( i, n );\n        dp[n] += dp[i];\n    }\n    cnt[n] += ( N - dp[n] ) * dp[n];\n    if ( edges[n].size() == 3 )\n        cnt[n] += dp[a] * dp[b];\n    dp[n]++;\n    cnt[n] += N;\n    cnt[n] <<= 1;\n}\n\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, idx = -1;\n    LL ma = -1;\n    cin >> n;\n    vector < int > data ( n );\n    for ( auto &i: data )\n        cin >> i;\n\n\n    stack < pii, vector < pii > > st;\n    pii swp;\n    st.push ( pii ( data[0], 0 ) );\n    for ( int i =  1 ; i < n ; i++ ){\n        while ( !st.empty() && data[i] > st.top().F ){\n            swp = st.top();\n            st.pop();\n            if ( st.empty() )\n                UNI ( swp.S, i, edges );\n            else\n                UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );\n        }\n        st.push ( pii ( data[i], i ) );\n    }\n    swp = st.top();\n    st.pop();\n    while ( !st.empty() ){\n        UNI ( swp.S, st.top().S, edges );\n        swp = st.top();\n        st.pop();\n    }\n\n    N = n - 1;\n    dfs ( 0, -1 );\n\n    for ( int i = 0 ; i < n ; i++ ){\n        if ( cnt[i] > ma )\n            ma = cnt[i], idx = i;\n    }\n\n    cout << ma << ' ' << idx + 1 << '\\n';\n}\n```\n\n## 後記\n\n其實這題我寫了很久\n因為之前一段時間都在搞特選\n而且我怕特選爆掉沒學校念\n所以我都在讀學測\n最近特選出來了\n已經沒有後顧之憂可以好好搞 TOI 了 <3\n才回來鍊\n也是因為剛回來鍊\n所以手感很糟 = =\n線段樹寫 query 還把查詢區間 & 總區間寫反 = =\n還有忘了設定 ma = -1\n然後還想說為什麼 WA Orz\n這題也沒有看出來是單調列隊\n還傻傻花一個多小時寫線段樹 + debug\n結果單調隊列快狠準 = =\n我到底在幹嘛 = =\n不過好險還有三個月（吧\n\n然後這篇文章也太長 = =\n這一行是第 326 行\n呃我是說在原始的 md 檔案上\n喔這邊已經 328 行了\n好多 = =\n至少可定下心來好好練習了","source":"_posts/TIOJ-1909.md","raw":"---\ntitle: '[TIOJ][1909] 勇者出征'\ndate: 2019-01-04 09:46:38\ntags:\n - TIOJ\n - graph\n---\n\n## 題目\n\n[原題目連結](https://tioj.ck.tp.edu.tw/problems/1909)\n據說是 2015TOI 三模的題目\n簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：\n1. 從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個\n2.    假設 $D$ 可以連結到 $A$ 的話（$D的高度 \\lt A$），那麼$A$也可以到 $D$\n\n求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號\n如果有多組解，輸出編號最小的\n<!--more-->\n\n\n## 解法\n\n我們先來釐清一下什麼是簡單路徑好了\n所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑\n\n### 建圖\n\n看到路徑，我第一個想到的是圖論\n我們先想一下，要怎麼把圖建出來\n\n#### 暴力 $O ( N^2 )$\n\n$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較\n```cpp\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\nfor ( int i = 0 ; i < n ; i++ ){\n    int l = -1, r = n;\n    for ( int j = i - 1 ; j >= 0 ; j-- )\n        if ( data[j] > data[i] ){\n            l = j;\n            break;\n        }\n    for ( int j = i + 1 ; j < n ; j++ )\n        if ( data[j] > data[i] ){\n            r = j;\n            break;\n        }\n    if ( l == -1 && r == n )\n        continue;\n    if ( l == -1 ){\n        UNI ( r, i, edges );\n        continue;\n    }\n    if ( r == n ){\n        UNI ( l, i, edges );\n        continue;\n    }\n    UNI ( ( data[l] < data[r] ? l : r ), i, edges );\n}\n```\n\n#### 線段樹 $O ( NlogN )$\n\n然後我就想到線段樹了\n$index$ 是做離散化後的數字，$value$ 是編號\n然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值\n一開始右手邊的最小值線段樹，裡面有$N$個點\n每處理完一個點，就把這個點拔掉丟到左邊去\ncode大概像這樣\n```cpp\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n#define INF 0x3f3f3f3f\n\n// function\n// 線段樹1是紀錄最小值、右手邊的線段樹\n// 而線段數2是紀錄最大值、左手邊的線段樹\nint seg1[maxN << 2], seg2[maxN << 2];\nvoid update1 ( int l, int r, int index, int value, int n );\nint query1 ( int l, int r, int nowL, int nowR, int n );\nvoid update2 ( int l, int r, int index, int value, int n );\nint query2 ( int l, int r, int index, int value, int n );\n\n// lib是已經做完離散化的數列\nmemset ( seg1, INF, sizeof seg1 );\nmemset ( seg2, -1, sizeof seg2 )\nfor ( int i = 0 ; i < n ; i++ )\n    update1 ( 0, n, i, lib[i], 1 );\n\nfor ( int i = 0 ; i < n ; i++ ){\n    int l = query2 ( lib[i] + 1, n, 0, n, 1 );\n    int r = query1 ( lib[i] + 1, n, 0, n, 1 );\n    if ( l == -1 && r == INF )\n        continue;\n    if ( l == -1 ){\n        UNI ( i, r, edges );\n        continue;\n    }\n    if ( r == INF ){\n        UNI ( i, l, edges );\n        continue;\n    }\n    UNI ( i, ( data[l] < data[r] ? l : r ), edges );\n\n    update1 ( 0, n, INF, lib[i], 1 );\n    update2 ( 0, n, i, lib[i], 1 );\n}\n```\n\n#### 單調列隊優化 $O ( N )$\n\n關於單調列隊優化的介紹可以看這份建中講義第二頁[這邊](https://goo.gl/e12UAo)\n\n根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的\n\n那麼假設要插入一個數字呢？\n假設現在這個數字比最後一個還要大，那麼我們就不斷的拔\n拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候\n接著把這些拔掉的數字與 $A$ 做連接\n\n不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？\n因為他是說兩邊第一個比她大的數字的 min\n既然兩邊都比他大，那麼當然選小的啊\n\n最後這個 deque 會保證遞減\n那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L'$ 做連結\n直到這個 deque 清空為止\n\n不過因為只需要從後端做操作\n所以用 stack 就可以了\n\n詳細的 code 請看這\n```cpp\ntypedef pair < int, int > pii;\n#define F first\n#define S second\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n\n// data 是原數列\nstack < pii, vector < pii > > st;\n// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）\npii swp;\nst.push ( pii ( data[0], 0 ) );\nfor ( int i = 1 ; i < n ; i++ ){\n    while ( !st.empty() && data[i] > st.top().F ){\n        swp = st.top();\n        st.pop();\n        if ( EMP ( st ) )\n            UNI ( swp.S, i, edges );\n        else\n            UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );\n    }\n    st.push ( pii ( data[i], i ) );\n}\nswp = st.top();\nst.pop();\nwhile ( !st.empty() ){\n    UNI ( swp.S, st.top().S, edges );\n    swp = st.top();\n    st.pop();\n}\n```\n\n### 是時候來處理路徑囉\n\n至於這個題目的另外一個部分：路徑\n又該怎麼處理呢？\n我們可以發現，這份資料轉換完之後保證是二元樹\n為什麼？\n因為他最多只會被兩個其他的點連結（左邊一個右邊一個）\n而自己只會連結到一個點\n那麼這不就是二元樹嗎？\n那麼，通過點 $u$ 的路徑會有三種：\n1. $u$ 的祖先到 $u$ 的子孫的路徑\n2. $u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑\n3. 從 $u$ 開始（或結束）的路徑\n\n我們先定義\n$$dp[u] = u的子孫數目（包含 u ）$$\n\n因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）\n因此只要計算起點終點的組合數就好了\n\n那麼 1. 就很好算啦\n$$( 總點數 - dp[n] - 1 )\\times ( dp[n] - 1 )$$\n\n那麼 2. 呢？\n上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）\n所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\\times dp[n]$）就是答案了\n\n呃，3. 應該就不用講了吧 = =\n就 總點數減一啊 = =\n\n然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）\n\n綜合一二三，所以只需要dfs一次就好了\n\n這部分的code我放這\n```cpp\n#define maxN 1000005\nvector < int > edges[maxN];\nint cnt[maxN], dp[maxN], N;\n// N = 總點數 - 1\n\nvoid dfs ( int n,  int p ){\n    int a = -1, b = -1;\n    for ( auto i: edges[n] ){\n        if ( i == p )\n            continue;\n        if ( a == -1 )\n            a = i;\n        else\n            b = i;\n        dfs ( i, n );\n        dp[n] += dp[i];\n    }\n    cnt[n] += ( N - dp[n] ) * dp[n]; // 祖先到子孫\n    if ( deges[n].size() == 3 ) // 如果是有兩個子孫的話\n        cnt[n] += dp[a] * dp[b];\n    dp[n]++; // 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1\n    cnt[n] += N;\n    cnt[n] <<= 1; // 記得乘二喔\n}\n```\n\n## code\n\n綜合以上，我的code長這樣\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\ntypedef pair < int, int > pii;\n#define pb push_back\n#define F first\n#define S second\n#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )\n#define maxN 1000005\n\nvector < int > edges[maxN];\nLL dp[maxN], N, cnt[maxN];\n\nvoid dfs ( int n,  int p ){\n    int a = -1, b = -1;\n    for ( auto i: edges[n] ){\n        if ( i == p )\n            continue;\n        if ( a == -1 )\n            a = i;\n        else\n            b = i;\n        dfs ( i, n );\n        dp[n] += dp[i];\n    }\n    cnt[n] += ( N - dp[n] ) * dp[n];\n    if ( edges[n].size() == 3 )\n        cnt[n] += dp[a] * dp[b];\n    dp[n]++;\n    cnt[n] += N;\n    cnt[n] <<= 1;\n}\n\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, idx = -1;\n    LL ma = -1;\n    cin >> n;\n    vector < int > data ( n );\n    for ( auto &i: data )\n        cin >> i;\n\n\n    stack < pii, vector < pii > > st;\n    pii swp;\n    st.push ( pii ( data[0], 0 ) );\n    for ( int i =  1 ; i < n ; i++ ){\n        while ( !st.empty() && data[i] > st.top().F ){\n            swp = st.top();\n            st.pop();\n            if ( st.empty() )\n                UNI ( swp.S, i, edges );\n            else\n                UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );\n        }\n        st.push ( pii ( data[i], i ) );\n    }\n    swp = st.top();\n    st.pop();\n    while ( !st.empty() ){\n        UNI ( swp.S, st.top().S, edges );\n        swp = st.top();\n        st.pop();\n    }\n\n    N = n - 1;\n    dfs ( 0, -1 );\n\n    for ( int i = 0 ; i < n ; i++ ){\n        if ( cnt[i] > ma )\n            ma = cnt[i], idx = i;\n    }\n\n    cout << ma << ' ' << idx + 1 << '\\n';\n}\n```\n\n## 後記\n\n其實這題我寫了很久\n因為之前一段時間都在搞特選\n而且我怕特選爆掉沒學校念\n所以我都在讀學測\n最近特選出來了\n已經沒有後顧之憂可以好好搞 TOI 了 <3\n才回來鍊\n也是因為剛回來鍊\n所以手感很糟 = =\n線段樹寫 query 還把查詢區間 & 總區間寫反 = =\n還有忘了設定 ma = -1\n然後還想說為什麼 WA Orz\n這題也沒有看出來是單調列隊\n還傻傻花一個多小時寫線段樹 + debug\n結果單調隊列快狠準 = =\n我到底在幹嘛 = =\n不過好險還有三個月（吧\n\n然後這篇文章也太長 = =\n這一行是第 326 行\n呃我是說在原始的 md 檔案上\n喔這邊已經 328 行了\n好多 = =\n至少可定下心來好好練習了","slug":"TIOJ-1909","published":1,"updated":"2020-05-03T11:24:07.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsk000fxl9p7xuk7c9h","content":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p><a href=\"https://tioj.ck.tp.edu.tw/problems/1909\" target=\"_blank\" rel=\"noopener\">原題目連結</a><br>據說是 2015TOI 三模的題目<br>簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：</p><ol><li>從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個</li><li>假設 $D$ 可以連結到 $A$ 的話（$D的高度 \\lt A$），那麼$A$也可以到 $D$</li></ol><p>求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號<br>如果有多組解，輸出編號最小的</p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>我們先來釐清一下什麼是簡單路徑好了<br>所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑</p><h3 id=\"建圖\"><a class=\"header-anchor\" href=\"#建圖\"></a>建圖</h3><p>看到路徑，我第一個想到的是圖論<br>我們先想一下，要怎麼把圖建出來</p><h4 id=\"暴力-O-N-2\"><a class=\"header-anchor\" href=\"#暴力-O-N-2\"></a>暴力 $O ( N^2 )$</h4><p>$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">-1</span>, r = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span> ; j &gt;= <span class=\"number\">0</span> ; j-- )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class=\"line\">            l = j;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span> ; j &lt; n ; j++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class=\"line\">            r = j;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> &amp;&amp; r == n )</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">        UNI ( r, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r == n )&#123;</span><br><span class=\"line\">        UNI ( l, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    UNI ( ( data[l] &lt; data[r] ? l : r ), i, edges );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"線段樹-O-NlogN\"><a class=\"header-anchor\" href=\"#線段樹-O-NlogN\"></a>線段樹 $O ( NlogN )$</h4><p>然後我就想到線段樹了<br>$index$ 是做離散化後的數字，$value$ 是編號<br>然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值<br>一開始右手邊的最小值線段樹，裡面有$N$個點<br>每處理完一個點，就把這個點拔掉丟到左邊去<br>code大概像這樣</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"comment\">// 線段樹1是紀錄最小值、右手邊的線段樹</span></span><br><span class=\"line\"><span class=\"comment\">// 而線段數2是紀錄最大值、左手邊的線段樹</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> seg1[maxN &lt;&lt; <span class=\"number\">2</span>], seg2[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update1</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query1</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update2</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query2</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lib是已經做完離散化的數列</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span> ( seg1, INF, <span class=\"keyword\">sizeof</span> seg1 );</span><br><span class=\"line\"><span class=\"built_in\">memset</span> ( seg2, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> seg2 )</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">    update1 ( <span class=\"number\">0</span>, n, i, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = query2 ( lib[i] + <span class=\"number\">1</span>, n, <span class=\"number\">0</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = query1 ( lib[i] + <span class=\"number\">1</span>, n, <span class=\"number\">0</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> &amp;&amp; r == INF )</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">        UNI ( i, r, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r == INF )&#123;</span><br><span class=\"line\">        UNI ( i, l, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    UNI ( i, ( data[l] &lt; data[r] ? l : r ), edges );</span><br><span class=\"line\"></span><br><span class=\"line\">    update1 ( <span class=\"number\">0</span>, n, INF, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\">    update2 ( <span class=\"number\">0</span>, n, i, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"單調列隊優化-O-N\"><a class=\"header-anchor\" href=\"#單調列隊優化-O-N\"></a>單調列隊優化 $O ( N )$</h4><p>關於單調列隊優化的介紹可以看這份建中講義第二頁<a href=\"https://goo.gl/e12UAo\" target=\"_blank\" rel=\"noopener\">這邊</a></p><p>根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的</p><p>那麼假設要插入一個數字呢？<br>假設現在這個數字比最後一個還要大，那麼我們就不斷的拔<br>拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候<br>接著把這些拔掉的數字與 $A$ 做連接</p><p>不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？<br>因為他是說兩邊第一個比她大的數字的 min<br>既然兩邊都比他大，那麼當然選小的啊</p><p>最後這個 deque 會保證遞減<br>那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L’$ 做連結<br>直到這個 deque 清空為止</p><p>不過因為只需要從後端做操作<br>所以用 stack 就可以了</p><p>詳細的 code 請看這</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// data 是原數列</span></span><br><span class=\"line\"><span class=\"built_in\">stack</span> &lt; pii, <span class=\"built_in\">vector</span> &lt; pii &gt; &gt; st;</span><br><span class=\"line\"><span class=\"comment\">// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）</span></span><br><span class=\"line\">pii swp;</span><br><span class=\"line\">st.push ( pii ( data[<span class=\"number\">0</span>], <span class=\"number\">0</span> ) );</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class=\"line\">        swp = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( EMP ( st ) )</span><br><span class=\"line\">            UNI ( swp.S, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    st.push ( pii ( data[i], i ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">swp = st.top();</span><br><span class=\"line\">st.pop();</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( !st.empty() )&#123;</span><br><span class=\"line\">    UNI ( swp.S, st.top().S, edges );</span><br><span class=\"line\">    swp = st.top();</span><br><span class=\"line\">    st.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"是時候來處理路徑囉\"><a class=\"header-anchor\" href=\"#是時候來處理路徑囉\"></a>是時候來處理路徑囉</h3><p>至於這個題目的另外一個部分：路徑<br>又該怎麼處理呢？<br>我們可以發現，這份資料轉換完之後保證是二元樹<br>為什麼？<br>因為他最多只會被兩個其他的點連結（左邊一個右邊一個）<br>而自己只會連結到一個點<br>那麼這不就是二元樹嗎？<br>那麼，通過點 $u$ 的路徑會有三種：</p><ol><li>$u$ 的祖先到 $u$ 的子孫的路徑</li><li>$u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑</li><li>從 $u$ 開始（或結束）的路徑</li></ol><p>我們先定義<br>$$dp[u] = u的子孫數目（包含 u ）$$</p><p>因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）<br>因此只要計算起點終點的組合數就好了</p><p>那麼 1. 就很好算啦<br>$$( 總點數 - dp[n] - 1 )\\times ( dp[n] - 1 )$$</p><p>那麼 2. 呢？<br>上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）<br>所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\\times dp[n]$）就是答案了</p><p>呃，3. 應該就不用講了吧 = =<br>就 總點數減一啊 = =</p><p>然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）</p><p>綜合一二三，所以只需要dfs一次就好了</p><p>這部分的code我放這</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN], dp[maxN], N;</span><br><span class=\"line\"><span class=\"comment\">// N = 總點數 - 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n,  <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">-1</span>, b = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a == <span class=\"number\">-1</span> )</span><br><span class=\"line\">            a = i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b = i;</span><br><span class=\"line\">        dfs ( i, n );</span><br><span class=\"line\">        dp[n] += dp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cnt[n] += ( N - dp[n] ) * dp[n]; <span class=\"comment\">// 祖先到子孫</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( deges[n].size() == <span class=\"number\">3</span> ) <span class=\"comment\">// 如果是有兩個子孫的話</span></span><br><span class=\"line\">        cnt[n] += dp[a] * dp[b];</span><br><span class=\"line\">    dp[n]++; <span class=\"comment\">// 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1</span></span><br><span class=\"line\">    cnt[n] += N;</span><br><span class=\"line\">    cnt[n] &lt;&lt;= <span class=\"number\">1</span>; <span class=\"comment\">// 記得乘二喔</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><p>綜合以上，我的code長這樣</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\">LL dp[maxN], N, cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n,  <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">-1</span>, b = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a == <span class=\"number\">-1</span> )</span><br><span class=\"line\">            a = i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b = i;</span><br><span class=\"line\">        dfs ( i, n );</span><br><span class=\"line\">        dp[n] += dp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cnt[n] += ( N - dp[n] ) * dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( edges[n].size() == <span class=\"number\">3</span> )</span><br><span class=\"line\">        cnt[n] += dp[a] * dp[b];</span><br><span class=\"line\">    dp[n]++;</span><br><span class=\"line\">    cnt[n] += N;</span><br><span class=\"line\">    cnt[n] &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, idx = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    LL ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> &lt; pii, <span class=\"built_in\">vector</span> &lt; pii &gt; &gt; st;</span><br><span class=\"line\">    pii swp;</span><br><span class=\"line\">    st.push ( pii ( data[<span class=\"number\">0</span>], <span class=\"number\">0</span> ) );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i =  <span class=\"number\">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class=\"line\">            swp = st.top();</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( st.empty() )</span><br><span class=\"line\">                UNI ( swp.S, i, edges );</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        st.push ( pii ( data[i], i ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swp = st.top();</span><br><span class=\"line\">    st.pop();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( !st.empty() )&#123;</span><br><span class=\"line\">        UNI ( swp.S, st.top().S, edges );</span><br><span class=\"line\">        swp = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    N = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    dfs ( <span class=\"number\">0</span>, <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( cnt[i] &gt; ma )</span><br><span class=\"line\">            ma = cnt[i], idx = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ma &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; idx + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>其實這題我寫了很久<br>因為之前一段時間都在搞特選<br>而且我怕特選爆掉沒學校念<br>所以我都在讀學測<br>最近特選出來了<br>已經沒有後顧之憂可以好好搞 TOI 了 &lt;3<br>才回來鍊<br>也是因為剛回來鍊<br>所以手感很糟 = =<br>線段樹寫 query 還把查詢區間 &amp; 總區間寫反 = =<br>還有忘了設定 ma = -1<br>然後還想說為什麼 WA Orz<br>這題也沒有看出來是單調列隊<br>還傻傻花一個多小時寫線段樹 + debug<br>結果單調隊列快狠準 = =<br>我到底在幹嘛 = =<br>不過好險還有三個月（吧</p><p>然後這篇文章也太長 = =<br>這一行是第 326 行<br>呃我是說在原始的 md 檔案上<br>喔這邊已經 328 行了<br>好多 = =<br>至少可定下心來好好練習了</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:00 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p><a href=\"https://tioj.ck.tp.edu.tw/problems/1909\" target=\"_blank\" rel=\"noopener\">原題目連結</a><br>據說是 2015TOI 三模的題目<br>簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：</p><ol><li>從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個</li><li>假設 $D$ 可以連結到 $A$ 的話（$D的高度 \\lt A$），那麼$A$也可以到 $D$</li></ol><p>求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號<br>如果有多組解，輸出編號最小的</p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>我們先來釐清一下什麼是簡單路徑好了<br>所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑</p><h3 id=\"建圖\"><a class=\"header-anchor\" href=\"#建圖\"></a>建圖</h3><p>看到路徑，我第一個想到的是圖論<br>我們先想一下，要怎麼把圖建出來</p><h4 id=\"暴力-O-N-2\"><a class=\"header-anchor\" href=\"#暴力-O-N-2\"></a>暴力 $O ( N^2 )$</h4><p>$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">-1</span>, r = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i - <span class=\"number\">1</span> ; j &gt;= <span class=\"number\">0</span> ; j-- )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class=\"line\">            l = j;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span> ; j &lt; n ; j++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( data[j] &gt; data[i] )&#123;</span><br><span class=\"line\">            r = j;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> &amp;&amp; r == n )</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">        UNI ( r, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r == n )&#123;</span><br><span class=\"line\">        UNI ( l, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    UNI ( ( data[l] &lt; data[r] ? l : r ), i, edges );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"線段樹-O-NlogN\"><a class=\"header-anchor\" href=\"#線段樹-O-NlogN\"></a>線段樹 $O ( NlogN )$</h4><p>然後我就想到線段樹了<br>$index$ 是做離散化後的數字，$value$ 是編號<br>然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值<br>一開始右手邊的最小值線段樹，裡面有$N$個點<br>每處理完一個點，就把這個點拔掉丟到左邊去<br>code大概像這樣</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 0x3f3f3f3f</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"comment\">// 線段樹1是紀錄最小值、右手邊的線段樹</span></span><br><span class=\"line\"><span class=\"comment\">// 而線段數2是紀錄最大值、左手邊的線段樹</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> seg1[maxN &lt;&lt; <span class=\"number\">2</span>], seg2[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update1</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query1</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update2</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query2</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lib是已經做完離散化的數列</span></span><br><span class=\"line\"><span class=\"built_in\">memset</span> ( seg1, INF, <span class=\"keyword\">sizeof</span> seg1 );</span><br><span class=\"line\"><span class=\"built_in\">memset</span> ( seg2, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> seg2 )</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">    update1 ( <span class=\"number\">0</span>, n, i, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = query2 ( lib[i] + <span class=\"number\">1</span>, n, <span class=\"number\">0</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = query1 ( lib[i] + <span class=\"number\">1</span>, n, <span class=\"number\">0</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> &amp;&amp; r == INF )</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">        UNI ( i, r, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r == INF )&#123;</span><br><span class=\"line\">        UNI ( i, l, edges );</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    UNI ( i, ( data[l] &lt; data[r] ? l : r ), edges );</span><br><span class=\"line\"></span><br><span class=\"line\">    update1 ( <span class=\"number\">0</span>, n, INF, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\">    update2 ( <span class=\"number\">0</span>, n, i, lib[i], <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"單調列隊優化-O-N\"><a class=\"header-anchor\" href=\"#單調列隊優化-O-N\"></a>單調列隊優化 $O ( N )$</h4><p>關於單調列隊優化的介紹可以看這份建中講義第二頁<a href=\"https://goo.gl/e12UAo\" target=\"_blank\" rel=\"noopener\">這邊</a></p><p>根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的</p><p>那麼假設要插入一個數字呢？<br>假設現在這個數字比最後一個還要大，那麼我們就不斷的拔<br>拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候<br>接著把這些拔掉的數字與 $A$ 做連接</p><p>不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？<br>因為他是說兩邊第一個比她大的數字的 min<br>既然兩邊都比他大，那麼當然選小的啊</p><p>最後這個 deque 會保證遞減<br>那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L’$ 做連結<br>直到這個 deque 清空為止</p><p>不過因為只需要從後端做操作<br>所以用 stack 就可以了</p><p>詳細的 code 請看這</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// data 是原數列</span></span><br><span class=\"line\"><span class=\"built_in\">stack</span> &lt; pii, <span class=\"built_in\">vector</span> &lt; pii &gt; &gt; st;</span><br><span class=\"line\"><span class=\"comment\">// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）</span></span><br><span class=\"line\">pii swp;</span><br><span class=\"line\">st.push ( pii ( data[<span class=\"number\">0</span>], <span class=\"number\">0</span> ) );</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class=\"line\">        swp = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( EMP ( st ) )</span><br><span class=\"line\">            UNI ( swp.S, i, edges );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    st.push ( pii ( data[i], i ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">swp = st.top();</span><br><span class=\"line\">st.pop();</span><br><span class=\"line\"><span class=\"keyword\">while</span> ( !st.empty() )&#123;</span><br><span class=\"line\">    UNI ( swp.S, st.top().S, edges );</span><br><span class=\"line\">    swp = st.top();</span><br><span class=\"line\">    st.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"是時候來處理路徑囉\"><a class=\"header-anchor\" href=\"#是時候來處理路徑囉\"></a>是時候來處理路徑囉</h3><p>至於這個題目的另外一個部分：路徑<br>又該怎麼處理呢？<br>我們可以發現，這份資料轉換完之後保證是二元樹<br>為什麼？<br>因為他最多只會被兩個其他的點連結（左邊一個右邊一個）<br>而自己只會連結到一個點<br>那麼這不就是二元樹嗎？<br>那麼，通過點 $u$ 的路徑會有三種：</p><ol><li>$u$ 的祖先到 $u$ 的子孫的路徑</li><li>$u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑</li><li>從 $u$ 開始（或結束）的路徑</li></ol><p>我們先定義<br>$$dp[u] = u的子孫數目（包含 u ）$$</p><p>因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）<br>因此只要計算起點終點的組合數就好了</p><p>那麼 1. 就很好算啦<br>$$( 總點數 - dp[n] - 1 )\\times ( dp[n] - 1 )$$</p><p>那麼 2. 呢？<br>上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）<br>所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\\times dp[n]$）就是答案了</p><p>呃，3. 應該就不用講了吧 = =<br>就 總點數減一啊 = =</p><p>然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）</p><p>綜合一二三，所以只需要dfs一次就好了</p><p>這部分的code我放這</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[maxN], dp[maxN], N;</span><br><span class=\"line\"><span class=\"comment\">// N = 總點數 - 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n,  <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">-1</span>, b = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a == <span class=\"number\">-1</span> )</span><br><span class=\"line\">            a = i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b = i;</span><br><span class=\"line\">        dfs ( i, n );</span><br><span class=\"line\">        dp[n] += dp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cnt[n] += ( N - dp[n] ) * dp[n]; <span class=\"comment\">// 祖先到子孫</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( deges[n].size() == <span class=\"number\">3</span> ) <span class=\"comment\">// 如果是有兩個子孫的話</span></span><br><span class=\"line\">        cnt[n] += dp[a] * dp[b];</span><br><span class=\"line\">    dp[n]++; <span class=\"comment\">// 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1</span></span><br><span class=\"line\">    cnt[n] += N;</span><br><span class=\"line\">    cnt[n] &lt;&lt;= <span class=\"number\">1</span>; <span class=\"comment\">// 記得乘二喔</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><p>綜合以上，我的code長這樣</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\">LL dp[maxN], N, cnt[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n,  <span class=\"keyword\">int</span> p )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">-1</span>, b = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( a == <span class=\"number\">-1</span> )</span><br><span class=\"line\">            a = i;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b = i;</span><br><span class=\"line\">        dfs ( i, n );</span><br><span class=\"line\">        dp[n] += dp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cnt[n] += ( N - dp[n] ) * dp[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( edges[n].size() == <span class=\"number\">3</span> )</span><br><span class=\"line\">        cnt[n] += dp[a] * dp[b];</span><br><span class=\"line\">    dp[n]++;</span><br><span class=\"line\">    cnt[n] += N;</span><br><span class=\"line\">    cnt[n] &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, idx = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    LL ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; data ( n );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: data )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; i;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">stack</span> &lt; pii, <span class=\"built_in\">vector</span> &lt; pii &gt; &gt; st;</span><br><span class=\"line\">    pii swp;</span><br><span class=\"line\">    st.push ( pii ( data[<span class=\"number\">0</span>], <span class=\"number\">0</span> ) );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i =  <span class=\"number\">1</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( !st.empty() &amp;&amp; data[i] &gt; st.top().F )&#123;</span><br><span class=\"line\">            swp = st.top();</span><br><span class=\"line\">            st.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( st.empty() )</span><br><span class=\"line\">                UNI ( swp.S, i, edges );</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                UNI ( ( st.top().F &lt; data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        st.push ( pii ( data[i], i ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swp = st.top();</span><br><span class=\"line\">    st.pop();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( !st.empty() )&#123;</span><br><span class=\"line\">        UNI ( swp.S, st.top().S, edges );</span><br><span class=\"line\">        swp = st.top();</span><br><span class=\"line\">        st.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    N = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    dfs ( <span class=\"number\">0</span>, <span class=\"number\">-1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( cnt[i] &gt; ma )</span><br><span class=\"line\">            ma = cnt[i], idx = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ma &lt;&lt; <span class=\"string\">' '</span> &lt;&lt; idx + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>其實這題我寫了很久<br>因為之前一段時間都在搞特選<br>而且我怕特選爆掉沒學校念<br>所以我都在讀學測<br>最近特選出來了<br>已經沒有後顧之憂可以好好搞 TOI 了 &lt;3<br>才回來鍊<br>也是因為剛回來鍊<br>所以手感很糟 = =<br>線段樹寫 query 還把查詢區間 &amp; 總區間寫反 = =<br>還有忘了設定 ma = -1<br>然後還想說為什麼 WA Orz<br>這題也沒有看出來是單調列隊<br>還傻傻花一個多小時寫線段樹 + debug<br>結果單調隊列快狠準 = =<br>我到底在幹嘛 = =<br>不過好險還有三個月（吧</p><p>然後這篇文章也太長 = =<br>這一行是第 326 行<br>呃我是說在原始的 md 檔案上<br>喔這邊已經 328 行了<br>好多 = =<br>至少可定下心來好好練習了</p><!-- rebuild by neat -->"},{"title":"[TOJ][365]G.大龍貓","date":"2017-12-26T12:50:14.000Z","_content":"\n## 題目\n\n給定一個數列，為一群龍貓的『高度』\n定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群\n請實作出支援單點修改及區間查詢的 code\n[題目原網址](http://toj.tfcis.org/oj/pro/365/)\n\n<!--more-->\n\n## 解法\n\n先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\n\n接著定義另外一種資料型態，用在線段樹上維護的 $node$\n$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\n\n在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$\n\n\n那麼，$stop.ma$ 呢？\n\n$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大\n\n## 總結\n\n其實這題不難，只是 coding 有點複雜，query & update 都與正常的線段樹差不多，只是 up 需要思考一下（？）\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 100005\n\nstruct piece{\n    int f, s, sz;\n};\n\ninline bool same ( piece a, piece b ){\n    return a.f == b.f && a.s == b.s;\n}\n\nstruct node{\n    piece fro, bck, ma;\n} seg[maxN << 2];\n\nint basic[maxN];\n\ninline node up ( node L, node R ){\n    node res;\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\n\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\n\n        if ( same ( L.fro, L.bck ) )\n            res.fro = stop;\n        if ( same ( R.fro, R.bck ) )\n            res.bck = stop;\n\n        res.ma = ( stop.sz > res.ma.sz ? stop : res.ma );\n    }\n\n    return res;\n}\n\ninline void build ( int l, int r, int n ){\n    if ( l == r )\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        build ( l, mid, leftSon );\n        build ( mid + 1, r, rightSon );\n\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nvoid update ( int l, int r, int Index, int n ){\n    if ( l == r )\n        return;\n    int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( Index <= mid )\n        update ( l, mid, Index, leftSon );\n    else\n        update ( mid + 1, r, Index, rightSon );\n\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\n}\n\nnode query ( int l, int r, int nowL, int nowR, int n ){\n    if ( l <= nowL && nowR <= r )\n        return seg[n];\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( r <= mid )\n        return query ( l, r, nowL, mid, leftSon );\n    if ( mid < l )\n        return query ( l, r, mid + 1, nowR, rightSon );\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, q, l, r, type;\n    cin >> n;\n    for ( int i = 1 ; i <= n ; i++ )\n        cin >> basic[i];\n    build ( 1, n, 1 );\n\n    cin >> q;\n    while ( q-- ){\n        cin >> type >> l >> r;\n        if ( type == 1 ){\n            basic[l] = r;\n            update ( 1, n, l, 1 );\n        }\n        else\n            cout << query ( l, r, 1, n, 1 ).ma.sz << '\\n';\n    }\n}\n```\n\n","source":"_posts/TOJ-365.md","raw":"---\ntitle: '[TOJ][365]G.大龍貓'\ndate: 2017-12-26 20:50:14\ntags:\n - TOJ\n - segment tree\n---\n\n## 題目\n\n給定一個數列，為一群龍貓的『高度』\n定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群\n請實作出支援單點修改及區間查詢的 code\n[題目原網址](http://toj.tfcis.org/oj/pro/365/)\n\n<!--more-->\n\n## 解法\n\n先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）\n\n接著定義另外一種資料型態，用在線段樹上維護的 $node$\n$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個\n\n在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$\n\n\n那麼，$stop.ma$ 呢？\n\n$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大\n\n## 總結\n\n其實這題不難，只是 coding 有點複雜，query & update 都與正常的線段樹差不多，只是 up 需要思考一下（？）\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 100005\n\nstruct piece{\n    int f, s, sz;\n};\n\ninline bool same ( piece a, piece b ){\n    return a.f == b.f && a.s == b.s;\n}\n\nstruct node{\n    piece fro, bck, ma;\n} seg[maxN << 2];\n\nint basic[maxN];\n\ninline node up ( node L, node R ){\n    node res;\n    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\n\n    if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){\n        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 };\n\n        if ( same ( L.fro, L.bck ) )\n            res.fro = stop;\n        if ( same ( R.fro, R.bck ) )\n            res.bck = stop;\n\n        res.ma = ( stop.sz > res.ma.sz ? stop : res.ma );\n    }\n\n    return res;\n}\n\ninline void build ( int l, int r, int n ){\n    if ( l == r )\n        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 };\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        build ( l, mid, leftSon );\n        build ( mid + 1, r, rightSon );\n\n        seg[n] = up ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nvoid update ( int l, int r, int Index, int n ){\n    if ( l == r )\n        return;\n    int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( Index <= mid )\n        update ( l, mid, Index, leftSon );\n    else\n        update ( mid + 1, r, Index, rightSon );\n\n    seg[n] = up ( seg[leftSon], seg[rightSon] );\n}\n\nnode query ( int l, int r, int nowL, int nowR, int n ){\n    if ( l <= nowL && nowR <= r )\n        return seg[n];\n    int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n    if ( r <= mid )\n        return query ( l, r, nowL, mid, leftSon );\n    if ( mid < l )\n        return query ( l, r, mid + 1, nowR, rightSon );\n    return up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + 1, nowR, rightSon ) );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, q, l, r, type;\n    cin >> n;\n    for ( int i = 1 ; i <= n ; i++ )\n        cin >> basic[i];\n    build ( 1, n, 1 );\n\n    cin >> q;\n    while ( q-- ){\n        cin >> type >> l >> r;\n        if ( type == 1 ){\n            basic[l] = r;\n            update ( 1, n, l, 1 );\n        }\n        else\n            cout << query ( l, r, 1, n, 1 ).ma.sz << '\\n';\n    }\n}\n```\n\n","slug":"TOJ-365","published":1,"updated":"2020-05-03T11:24:07.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsl000gxl9pain010a9","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>給定一個數列，為一群龍貓的『高度』<br>定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群<br>請實作出支援單點修改及區間查詢的 code<br><a href=\"http://toj.tfcis.org/oj/pro/365/\" target=\"_blank\" rel=\"noopener\">題目原網址</a></p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）</p><p>接著定義另外一種資料型態，用在線段樹上維護的 $node$<br>$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個</p><p>在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$</p><p>那麼，$stop.ma$ 呢？</p><p>$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大</p><h2 id=\"總結\"><a class=\"header-anchor\" href=\"#總結\"></a>總結</h2><p>其實這題不難，只是 coding 有點複雜，query &amp; update 都與正常的線段樹差不多，只是 up 需要思考一下（？）</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 100005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">piece</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> f, s, sz;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( piece a, piece b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.f == b.f &amp;&amp; a.s == b.s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    piece fro, bck, ma;</span><br><span class=\"line\">&#125; seg[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> basic[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">up</span> <span class=\"params\">( node L, node R )</span></span>&#123;</span><br><span class=\"line\">    node res;</span><br><span class=\"line\">    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( basic[L.bck.s] + <span class=\"number\">1</span> == basic[R.fro.f] )&#123;</span><br><span class=\"line\">        piece stop = piece &#123; L.bck.f, R.fro.s, R.fro.s - L.bck.f + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( L.fro, L.bck ) )</span><br><span class=\"line\">            res.fro = stop;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( R.fro, R.bck ) )</span><br><span class=\"line\">            res.bck = stop;</span><br><span class=\"line\"></span><br><span class=\"line\">        res.ma = ( stop.sz &gt; res.ma.sz ? stop : res.ma );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        seg[n].fro = seg[n].bck = seg[n].ma = piece &#123; l, r, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        build ( l, mid, leftSon );</span><br><span class=\"line\">        build ( mid + <span class=\"number\">1</span>, r, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> Index, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( Index &lt;= mid )</span><br><span class=\"line\">        update ( l, mid, Index, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update ( mid + <span class=\"number\">1</span>, r, Index, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">    seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seg[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, q, l, r, type;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; basic[i];</span><br><span class=\"line\">    build ( <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( q-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            basic[l] = r;</span><br><span class=\"line\">            update ( <span class=\"number\">1</span>, n, l, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> ).ma.sz &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>給定一個數列，為一群龍貓的『高度』<br>定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群<br>請實作出支援單點修改及區間查詢的 code<br><a href=\"http://toj.tfcis.org/oj/pro/365/\" target=\"_blank\" rel=\"noopener\">題目原網址</a></p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）</p><p>接著定義另外一種資料型態，用在線段樹上維護的 $node$<br>$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個</p><p>在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$</p><p>那麼，$stop.ma$ 呢？</p><p>$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大</p><h2 id=\"總結\"><a class=\"header-anchor\" href=\"#總結\"></a>總結</h2><p>其實這題不難，只是 coding 有點複雜，query &amp; update 都與正常的線段樹差不多，只是 up 需要思考一下（？）</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 100005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">piece</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> f, s, sz;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( piece a, piece b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.f == b.f &amp;&amp; a.s == b.s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    piece fro, bck, ma;</span><br><span class=\"line\">&#125; seg[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> basic[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">up</span> <span class=\"params\">( node L, node R )</span></span>&#123;</span><br><span class=\"line\">    node res;</span><br><span class=\"line\">    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( basic[L.bck.s] + <span class=\"number\">1</span> == basic[R.fro.f] )&#123;</span><br><span class=\"line\">        piece stop = piece &#123; L.bck.f, R.fro.s, R.fro.s - L.bck.f + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( L.fro, L.bck ) )</span><br><span class=\"line\">            res.fro = stop;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( R.fro, R.bck ) )</span><br><span class=\"line\">            res.bck = stop;</span><br><span class=\"line\"></span><br><span class=\"line\">        res.ma = ( stop.sz &gt; res.ma.sz ? stop : res.ma );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        seg[n].fro = seg[n].bck = seg[n].ma = piece &#123; l, r, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        build ( l, mid, leftSon );</span><br><span class=\"line\">        build ( mid + <span class=\"number\">1</span>, r, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> Index, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( Index &lt;= mid )</span><br><span class=\"line\">        update ( l, mid, Index, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        update ( mid + <span class=\"number\">1</span>, r, Index, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">    seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">node <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l &lt;= nowL &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seg[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + <span class=\"number\">1</span>, nowR, rightSon ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, q, l, r, type;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; basic[i];</span><br><span class=\"line\">    build ( <span class=\"number\">1</span>, n, <span class=\"number\">1</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( q-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            basic[l] = r;</span><br><span class=\"line\">            update ( <span class=\"number\">1</span>, n, l, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, <span class=\"number\">1</span> ).ma.sz &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"[TOJ][391] E. 模數 CANDY","date":"2018-02-07T01:17:56.000Z","_content":"\n## 題目 & 解法\n我先附上題目[連結](http://toj.tfcis.org/oj/pro/391/)\n簡單來說，就是區間取餘數\n然後這東西**可以用線段樹實作**\n<!--more-->\n\n然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法\n在寫區間開根號的時候，我們用的是**區間最大值線段樹**，是的，區間最大值\n\n理由很簡單，因為開根號開到最後，一定會朝向$1$收斂\n所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧\n\n同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹**在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數**\n這應該算是一種剪枝（吧\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\n#define maxN 200005\n\nint seg[maxN << 2];\n\nvoid update ( int l, int r, int index, int value, int n ){\n    if ( l == r )\n        seg[n] += value;\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( index <= mid )\n            update ( l, mid, index, value, leftSon );\n        else\n            update ( mid + 1, r, index, value, rightSon );\n\n        seg[n] = max ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nvoid modify ( int l, int r, int nowL, int nowR, int value, int n ){\n    if ( seg[n] < value )\n        return;\n    if ( nowL == nowR )\n        seg[n] %= value;\n    else{\n        int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( r <= mid )\n            modify ( l, r, nowL, mid, value, leftSon );\n        else if ( mid < l )\n            modify ( l, r, mid + 1, nowR, value, rightSon );\n        else{\n            modify ( l, mid, nowL, mid, value, leftSon );\n            modify ( mid + 1, r, mid + 1, nowR, value, rightSon );\n        }\n\n        seg[n] = max ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, type, l, r, x, in;\n    cin >> n;\n    n--;\n    for ( int i = 0 ; i <= n ; i++ ){\n        cin >> in;\n        update ( 0, n, i, in, 1 );\n    }\n\n    cin >> m;\n    while ( m-- ){\n        cin >> type;\n        if ( type == 1 ){\n            cin >> l >> r;\n            update ( 0, n, r, l, 1 );\n        }        \n        else if ( type == 2 ){\n            cin >> l >> r >> x;\n            modify ( l, r, 0, n, x, 1 );\n        }\n        else\n            cout << seg[1] << '\\n';\n    }\n}\n```\n<del>所以其實這題也不難嘛</del>\n\n為什麼不能打 Lazy Tag？\n\n。。。因為 mod 沒有疊加性啊\n\n\n## 證明\n然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過\n因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）\n所以總複雜度大約為 $O ( log ( max \\lbrace a_i \\rbrace ) )$ 左右\n（此部分感謝 jd3 學長提供）","source":"_posts/TOJ-391.md","raw":"---\ntitle: '[TOJ][391] E. 模數 CANDY'\ndate: 2018-02-07 09:17:56\ntags:\n - TOJ\n - segment tree\n---\n\n## 題目 & 解法\n我先附上題目[連結](http://toj.tfcis.org/oj/pro/391/)\n簡單來說，就是區間取餘數\n然後這東西**可以用線段樹實作**\n<!--more-->\n\n然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法\n在寫區間開根號的時候，我們用的是**區間最大值線段樹**，是的，區間最大值\n\n理由很簡單，因為開根號開到最後，一定會朝向$1$收斂\n所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧\n\n同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹**在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數**\n這應該算是一種剪枝（吧\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\n#define maxN 200005\n\nint seg[maxN << 2];\n\nvoid update ( int l, int r, int index, int value, int n ){\n    if ( l == r )\n        seg[n] += value;\n    else{\n        int mid = ( l + r ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( index <= mid )\n            update ( l, mid, index, value, leftSon );\n        else\n            update ( mid + 1, r, index, value, rightSon );\n\n        seg[n] = max ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nvoid modify ( int l, int r, int nowL, int nowR, int value, int n ){\n    if ( seg[n] < value )\n        return;\n    if ( nowL == nowR )\n        seg[n] %= value;\n    else{\n        int mid = ( nowL + nowR ) >> 1, leftSon = n << 1, rightSon = leftSon | 1;\n        if ( r <= mid )\n            modify ( l, r, nowL, mid, value, leftSon );\n        else if ( mid < l )\n            modify ( l, r, mid + 1, nowR, value, rightSon );\n        else{\n            modify ( l, mid, nowL, mid, value, leftSon );\n            modify ( mid + 1, r, mid + 1, nowR, value, rightSon );\n        }\n\n        seg[n] = max ( seg[leftSon], seg[rightSon] );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, type, l, r, x, in;\n    cin >> n;\n    n--;\n    for ( int i = 0 ; i <= n ; i++ ){\n        cin >> in;\n        update ( 0, n, i, in, 1 );\n    }\n\n    cin >> m;\n    while ( m-- ){\n        cin >> type;\n        if ( type == 1 ){\n            cin >> l >> r;\n            update ( 0, n, r, l, 1 );\n        }        \n        else if ( type == 2 ){\n            cin >> l >> r >> x;\n            modify ( l, r, 0, n, x, 1 );\n        }\n        else\n            cout << seg[1] << '\\n';\n    }\n}\n```\n<del>所以其實這題也不難嘛</del>\n\n為什麼不能打 Lazy Tag？\n\n。。。因為 mod 沒有疊加性啊\n\n\n## 證明\n然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過\n因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）\n所以總複雜度大約為 $O ( log ( max \\lbrace a_i \\rbrace ) )$ 左右\n（此部分感謝 jd3 學長提供）","slug":"TOJ-391","published":1,"updated":"2020-05-03T11:24:07.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsm000ixl9pa201augf","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p>我先附上題目<a href=\"http://toj.tfcis.org/oj/pro/391/\" target=\"_blank\" rel=\"noopener\">連結</a><br>簡單來說，就是區間取餘數<br>然後這東西<strong>可以用線段樹實作</strong></p><a id=\"more\"></a><p>然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法<br>在寫區間開根號的時候，我們用的是<strong>區間最大值線段樹</strong>，是的，區間最大值</p><p>理由很簡單，因為開根號開到最後，一定會朝向$1$收斂<br>所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧</p><p>同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹<strong>在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數</strong><br>這應該算是一種剪枝（吧</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> seg[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        seg[n] += value;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( index &lt;= mid )</span><br><span class=\"line\">            update ( l, mid, index, value, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            update ( mid + <span class=\"number\">1</span>, r, index, value, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( seg[n] &lt; value )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( nowL == nowR )</span><br><span class=\"line\">        seg[n] %= value;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">            modify ( l, r, nowL, mid, value, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, value, rightSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            modify ( l, mid, nowL, mid, value, leftSon );</span><br><span class=\"line\">            modify ( mid + <span class=\"number\">1</span>, r, mid + <span class=\"number\">1</span>, nowR, value, rightSon );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, type, l, r, x, in;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    n--;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">        update ( <span class=\"number\">0</span>, n, i, in, <span class=\"number\">1</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">            update ( <span class=\"number\">0</span>, n, r, l, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class=\"line\">            modify ( l, r, <span class=\"number\">0</span>, n, x, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; seg[<span class=\"number\">1</span>] &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><del>所以其實這題也不難嘛</del></p><p>為什麼不能打 Lazy Tag？</p><p>。。。因為 mod 沒有疊加性啊</p><h2 id=\"證明\"><a class=\"header-anchor\" href=\"#證明\"></a>證明</h2><p>然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過<br>因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）<br>所以總複雜度大約為 $O ( log ( max \\lbrace a_i \\rbrace ) )$ 左右<br>（此部分感謝 jd3 學長提供）</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p>我先附上題目<a href=\"http://toj.tfcis.org/oj/pro/391/\" target=\"_blank\" rel=\"noopener\">連結</a><br>簡單來說，就是區間取餘數<br>然後這東西<strong>可以用線段樹實作</strong></p>","more":"<p>然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法<br>在寫區間開根號的時候，我們用的是<strong>區間最大值線段樹</strong>，是的，區間最大值</p><p>理由很簡單，因為開根號開到最後，一定會朝向$1$收斂<br>所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧</p><p>同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹<strong>在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數</strong><br>這應該算是一種剪枝（吧</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> seg[maxN &lt;&lt; <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">        seg[n] += value;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( index &lt;= mid )</span><br><span class=\"line\">            update ( l, mid, index, value, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            update ( mid + <span class=\"number\">1</span>, r, index, value, rightSon );</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modify</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, <span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( seg[n] &lt; value )</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( nowL == nowR )</span><br><span class=\"line\">        seg[n] %= value;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>, leftSon = n &lt;&lt; <span class=\"number\">1</span>, rightSon = leftSon | <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">            modify ( l, r, nowL, mid, value, leftSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">            modify ( l, r, mid + <span class=\"number\">1</span>, nowR, value, rightSon );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            modify ( l, mid, nowL, mid, value, leftSon );</span><br><span class=\"line\">            modify ( mid + <span class=\"number\">1</span>, r, mid + <span class=\"number\">1</span>, nowR, value, rightSon );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, type, l, r, x, in;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    n--;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">        update ( <span class=\"number\">0</span>, n, i, in, <span class=\"number\">1</span> );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; type;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">            update ( <span class=\"number\">0</span>, n, r, l, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class=\"line\">            modify ( l, r, <span class=\"number\">0</span>, n, x, <span class=\"number\">1</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; seg[<span class=\"number\">1</span>] &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><del>所以其實這題也不難嘛</del></p><p>為什麼不能打 Lazy Tag？</p><p>。。。因為 mod 沒有疊加性啊</p><h2 id=\"證明\"><a class=\"header-anchor\" href=\"#證明\"></a>證明</h2><p>然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過<br>因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）<br>所以總複雜度大約為 $O ( log ( max \\lbrace a_i \\rbrace ) )$ 左右<br>（此部分感謝 jd3 學長提供）</p><!-- rebuild by neat -->"},{"title":"[TOJ][406] C. 軍隊部署","date":"2018-07-18T11:39:09.000Z","_content":"\n## 題目\n老樣子先放連結\n[TOJ](<http://toj.tfcis.org/oj/pro/406/)\n[ZJ](<https://zerojudge.tw/ShowProblem?problemid=c460)\n這是去年（106年）全國學科能力競賽資訊科全國賽的pC\n分類上算是水題一枚（按照去年整體難度來說）\n\n題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊\n<!--more-->\n\n\n## 解法\n\n所以如果我們先不看種族，我們先看能力就好，可以看成：\n* 第一位：是否對空，是為 $1$，否為 $0$\n* 第二位：是否範圍，是為 $1$，否為 $0$\n* 第三位：是否遠距，是為 $1$，否為 $0$\n\n所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$\n然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧\n會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$\n\n接著是種族，有三種族，所以代號為$1, 2, 3$\n\n那麼來做dp陣列的規劃吧\n$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能\n\n然後要求是三種族、三功能都要有，所以**那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族**\n\n呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想\n看 code 可能會比較好瞭解，我 code 放下面\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long dp[5][10];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    long long n, x, y, z, w, ans = 0;\n    cin >> n;\n    for ( int i = 0 ; i < n ; i++ ){\n        cin >> w >> x >> y >> z;\n        dp[w][x * 4 + y * 2 + z]++;\n    }\n\n    for ( int i = 0 ; i < 8 ; i++ )\n        for ( int j = 0 ; j < 8 ; j++ )\n            for ( int k = 0 ; k < 8 ; k++ )\n                if ( ( i | j | k ) == 7 )\n                    ans += dp[1][i] * dp[2][j] * dp[3][k];\n\n    cout << ans << '\\n';\n}\n```","source":"_posts/TOJ-406.md","raw":"---\ntitle: '[TOJ][406] C. 軍隊部署'\ndate: 2018-07-18 19:39:09\ntags:\n - TOJ\n - ZJ\n - 全國賽\n - dp\n---\n\n## 題目\n老樣子先放連結\n[TOJ](<http://toj.tfcis.org/oj/pro/406/)\n[ZJ](<https://zerojudge.tw/ShowProblem?problemid=c460)\n這是去年（106年）全國學科能力競賽資訊科全國賽的pC\n分類上算是水題一枚（按照去年整體難度來說）\n\n題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊\n<!--more-->\n\n\n## 解法\n\n所以如果我們先不看種族，我們先看能力就好，可以看成：\n* 第一位：是否對空，是為 $1$，否為 $0$\n* 第二位：是否範圍，是為 $1$，否為 $0$\n* 第三位：是否遠距，是為 $1$，否為 $0$\n\n所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$\n然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧\n會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$\n\n接著是種族，有三種族，所以代號為$1, 2, 3$\n\n那麼來做dp陣列的規劃吧\n$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能\n\n然後要求是三種族、三功能都要有，所以**那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族**\n\n呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想\n看 code 可能會比較好瞭解，我 code 放下面\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long dp[5][10];\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    long long n, x, y, z, w, ans = 0;\n    cin >> n;\n    for ( int i = 0 ; i < n ; i++ ){\n        cin >> w >> x >> y >> z;\n        dp[w][x * 4 + y * 2 + z]++;\n    }\n\n    for ( int i = 0 ; i < 8 ; i++ )\n        for ( int j = 0 ; j < 8 ; j++ )\n            for ( int k = 0 ; k < 8 ; k++ )\n                if ( ( i | j | k ) == 7 )\n                    ans += dp[1][i] * dp[2][j] * dp[3][k];\n\n    cout << ans << '\\n';\n}\n```","slug":"TOJ-406","published":1,"updated":"2020-05-03T11:24:07.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsp000kxl9p1onw7u55","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>老樣子先放連結<br>[TOJ](&lt;<a href=\"http://toj.tfcis.org/oj/pro/406/\" target=\"_blank\" rel=\"noopener\">http://toj.tfcis.org/oj/pro/406/</a>)<br>[ZJ](&lt;<a href=\"https://zerojudge.tw/ShowProblem?problemid=c460\" target=\"_blank\" rel=\"noopener\">https://zerojudge.tw/ShowProblem?problemid=c460</a>)<br>這是去年（106年）全國學科能力競賽資訊科全國賽的pC<br>分類上算是水題一枚（按照去年整體難度來說）</p><p>題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊</p><a id=\"more\"></a><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>所以如果我們先不看種族，我們先看能力就好，可以看成：</p><ul><li>第一位：是否對空，是為 $1$，否為 $0$</li><li>第二位：是否範圍，是為 $1$，否為 $0$</li><li>第三位：是否遠距，是為 $1$，否為 $0$</li></ul><p>所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$<br>然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧<br>會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$</p><p>接著是種族，有三種族，所以代號為$1, 2, 3$</p><p>那麼來做dp陣列的規劃吧<br>$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能</p><p>然後要求是三種族、三功能都要有，所以<strong>那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族</strong></p><p>呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想<br>看 code 可能會比較好瞭解，我 code 放下面</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[<span class=\"number\">5</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, x, y, z, w, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; w &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class=\"line\">        dp[w][x * <span class=\"number\">4</span> + y * <span class=\"number\">2</span> + z]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">8</span> ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; <span class=\"number\">8</span> ; j++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> k = <span class=\"number\">0</span> ; k &lt; <span class=\"number\">8</span> ; k++ )</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( ( i | j | k ) == <span class=\"number\">7</span> )</span><br><span class=\"line\">                    ans += dp[<span class=\"number\">1</span>][i] * dp[<span class=\"number\">2</span>][j] * dp[<span class=\"number\">3</span>][k];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>老樣子先放連結<br>[TOJ](&lt;<a href=\"http://toj.tfcis.org/oj/pro/406/\" target=\"_blank\" rel=\"noopener\">http://toj.tfcis.org/oj/pro/406/</a>)<br>[ZJ](&lt;<a href=\"https://zerojudge.tw/ShowProblem?problemid=c460\" target=\"_blank\" rel=\"noopener\">https://zerojudge.tw/ShowProblem?problemid=c460</a>)<br>這是去年（106年）全國學科能力競賽資訊科全國賽的pC<br>分類上算是水題一枚（按照去年整體難度來說）</p><p>題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊</p>","more":"<h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>所以如果我們先不看種族，我們先看能力就好，可以看成：</p><ul><li>第一位：是否對空，是為 $1$，否為 $0$</li><li>第二位：是否範圍，是為 $1$，否為 $0$</li><li>第三位：是否遠距，是為 $1$，否為 $0$</li></ul><p>所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$<br>然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧<br>會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$</p><p>接著是種族，有三種族，所以代號為$1, 2, 3$</p><p>那麼來做dp陣列的規劃吧<br>$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能</p><p>然後要求是三種族、三功能都要有，所以<strong>那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族</strong></p><p>呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想<br>看 code 可能會比較好瞭解，我 code 放下面</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[<span class=\"number\">5</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n, x, y, z, w, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; w &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class=\"line\">        dp[w][x * <span class=\"number\">4</span> + y * <span class=\"number\">2</span> + z]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">8</span> ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; <span class=\"number\">8</span> ; j++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> k = <span class=\"number\">0</span> ; k &lt; <span class=\"number\">8</span> ; k++ )</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( ( i | j | k ) == <span class=\"number\">7</span> )</span><br><span class=\"line\">                    ans += dp[<span class=\"number\">1</span>][i] * dp[<span class=\"number\">2</span>][j] * dp[<span class=\"number\">3</span>][k];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"[TOJ][407] D. 警力配置","date":"2018-08-16T13:59:42.000Z","_content":"\n又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =\n<del>別再給我增加工作量啊垃圾</del>\n我還要把舊站的文章搬過來改成 md 檔啊 = =\n\n\n## 題目\n\n我先附上[連結](http://toj.tfcis.org/oj/pro/407/)\n\n題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」\n不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組\n<!--more-->\n有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長\n組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長\n\n**注意：至少有一個 $\\to$ 有兩個也沒關係**\n\n這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫\n<del>（但是不小心撈到73分，我問號）</del>\n\n\n## 解法\n\n很顯然的要先轉成一張圖，這絕對是圖論 = =\n也就是說題意可以被化簡成這樣：\n給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到\n。。。啊不就匈牙利\n既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下[這篇](http://www.csie.ntnu.edu.tw/~u91029/Matching.html)\n然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法\n\n因為這題真的是裸題（？）所以我就直接附 code 了\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n\n#define maxN 200005\n\nvector < int > edges[maxN];\nint match[maxN], visit[maxN], turn;\n\ninline bool dfs ( int n ){\n    visit[n] = turn;\n    for ( auto i: edges[n] ){\n        if ( match[i] == -1 || ( visit[match[i]] != turn && dfs ( match[i] ) ) ){\n            match[i] = n;\n            match[n] = i;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, m, u, v, p, q, ans;\n    cin >> t;\n    while ( t-- ){\n        ans = 0;\n        memset ( match, -1, sizeof match );\n        for ( auto &i: edges )\n            i.clear();\n        cin >> p >> q >> m;\n        while ( m-- ){\n            cin >> u >> v;\n            v += p;\n            edges[u].pb ( v );\n            edges[v].pb ( u );\n        }\n\n        p += q;\n        for ( int i = 0 ; i <= p ; i++ ){\n            if ( match[i] == -1 ){\n                turn++;\n                // 省去每次 dfs 都要 memset 一次 visit 陣列的時間\n                if ( dfs ( i ) )\n                    ans++;\n                    // 如果可以找到新的配對就 ans++\n            }\n        }\n\n        cout << ans << '\\n';\n    }\n}\n```\n\n\n## tips\n\n然後這邊我有用到一個小技巧，可以避免 TLE\n通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow\n不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）\n如果我們把這個陣列開成 int 陣列\n並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪\n這樣就不用浪費時間去 memset 了","source":"_posts/TOJ-407.md","raw":"---\ntitle: '[TOJ][407] D. 警力配置'\ndate: 2018-08-16 21:59:42\ntags:\n - TOJ\n - graph\n---\n\n又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =\n<del>別再給我增加工作量啊垃圾</del>\n我還要把舊站的文章搬過來改成 md 檔啊 = =\n\n\n## 題目\n\n我先附上[連結](http://toj.tfcis.org/oj/pro/407/)\n\n題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」\n不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組\n<!--more-->\n有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長\n組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長\n\n**注意：至少有一個 $\\to$ 有兩個也沒關係**\n\n這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫\n<del>（但是不小心撈到73分，我問號）</del>\n\n\n## 解法\n\n很顯然的要先轉成一張圖，這絕對是圖論 = =\n也就是說題意可以被化簡成這樣：\n給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到\n。。。啊不就匈牙利\n既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下[這篇](http://www.csie.ntnu.edu.tw/~u91029/Matching.html)\n然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法\n\n因為這題真的是裸題（？）所以我就直接附 code 了\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n\n#define maxN 200005\n\nvector < int > edges[maxN];\nint match[maxN], visit[maxN], turn;\n\ninline bool dfs ( int n ){\n    visit[n] = turn;\n    for ( auto i: edges[n] ){\n        if ( match[i] == -1 || ( visit[match[i]] != turn && dfs ( match[i] ) ) ){\n            match[i] = n;\n            match[n] = i;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, m, u, v, p, q, ans;\n    cin >> t;\n    while ( t-- ){\n        ans = 0;\n        memset ( match, -1, sizeof match );\n        for ( auto &i: edges )\n            i.clear();\n        cin >> p >> q >> m;\n        while ( m-- ){\n            cin >> u >> v;\n            v += p;\n            edges[u].pb ( v );\n            edges[v].pb ( u );\n        }\n\n        p += q;\n        for ( int i = 0 ; i <= p ; i++ ){\n            if ( match[i] == -1 ){\n                turn++;\n                // 省去每次 dfs 都要 memset 一次 visit 陣列的時間\n                if ( dfs ( i ) )\n                    ans++;\n                    // 如果可以找到新的配對就 ans++\n            }\n        }\n\n        cout << ans << '\\n';\n    }\n}\n```\n\n\n## tips\n\n然後這邊我有用到一個小技巧，可以避免 TLE\n通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow\n不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）\n如果我們把這個陣列開成 int 陣列\n並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪\n這樣就不用浪費時間去 memset 了","slug":"TOJ-407","published":1,"updated":"2020-05-03T11:24:07.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsq000nxl9p1vtbapif","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =<br><del>別再給我增加工作量啊垃圾</del><br>我還要把舊站的文章搬過來改成 md 檔啊 = =</p><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>我先附上<a href=\"http://toj.tfcis.org/oj/pro/407/\" target=\"_blank\" rel=\"noopener\">連結</a></p><p>題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」<br>不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組</p><a id=\"more\"></a><p>有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長<br>組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長</p><p><strong>注意：至少有一個 $\\to$ 有兩個也沒關係</strong></p><p>這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫<br><del>（但是不小心撈到73分，我問號）</del></p><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>很顯然的要先轉成一張圖，這絕對是圖論 = =<br>也就是說題意可以被化簡成這樣：<br>給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到<br>。。。啊不就匈牙利<br>既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下<a href=\"http://www.csie.ntnu.edu.tw/~u91029/Matching.html\" target=\"_blank\" rel=\"noopener\">這篇</a><br>然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法</p><p>因為這題真的是裸題（？）所以我就直接附 code 了</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> match[maxN], visit[maxN], turn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    visit[n] = turn;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( match[i] == <span class=\"number\">-1</span> || ( visit[match[i]] != turn &amp;&amp; dfs ( match[i] ) ) )&#123;</span><br><span class=\"line\">            match[i] = n;</span><br><span class=\"line\">            match[n] = i;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, m, u, v, p, q, ans;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( match, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> match );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: edges )</span><br><span class=\"line\">            i.clear();</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; p &gt;&gt; q &gt;&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">            v += p;</span><br><span class=\"line\">            edges[u].pb ( v );</span><br><span class=\"line\">            edges[v].pb ( u );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        p += q;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= p ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( match[i] == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">                turn++;</span><br><span class=\"line\">                <span class=\"comment\">// 省去每次 dfs 都要 memset 一次 visit 陣列的時間</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( dfs ( i ) )</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果可以找到新的配對就 ans++</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"tips\"><a class=\"header-anchor\" href=\"#tips\"></a>tips</h2><p>然後這邊我有用到一個小技巧，可以避免 TLE<br>通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow<br>不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）<br>如果我們把這個陣列開成 int 陣列<br>並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪<br>這樣就不用浪費時間去 memset 了</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =<br><del>別再給我增加工作量啊垃圾</del><br>我還要把舊站的文章搬過來改成 md 檔啊 = =</p><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>我先附上<a href=\"http://toj.tfcis.org/oj/pro/407/\" target=\"_blank\" rel=\"noopener\">連結</a></p><p>題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」<br>不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組</p>","more":"<p>有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長<br>組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長</p><p><strong>注意：至少有一個 $\\to$ 有兩個也沒關係</strong></p><p>這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫<br><del>（但是不小心撈到73分，我問號）</del></p><h2 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h2><p>很顯然的要先轉成一張圖，這絕對是圖論 = =<br>也就是說題意可以被化簡成這樣：<br>給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到<br>。。。啊不就匈牙利<br>既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下<a href=\"http://www.csie.ntnu.edu.tw/~u91029/Matching.html\" target=\"_blank\" rel=\"noopener\">這篇</a><br>然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法</p><p>因為這題真的是裸題（？）所以我就直接附 code 了</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 200005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; edges[maxN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> match[maxN], visit[maxN], turn;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    visit[n] = turn;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: edges[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( match[i] == <span class=\"number\">-1</span> || ( visit[match[i]] != turn &amp;&amp; dfs ( match[i] ) ) )&#123;</span><br><span class=\"line\">            match[i] = n;</span><br><span class=\"line\">            match[n] = i;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, m, u, v, p, q, ans;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( match, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> match );</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: edges )</span><br><span class=\"line\">            i.clear();</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; p &gt;&gt; q &gt;&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class=\"line\">            v += p;</span><br><span class=\"line\">            edges[u].pb ( v );</span><br><span class=\"line\">            edges[v].pb ( u );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        p += q;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt;= p ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( match[i] == <span class=\"number\">-1</span> )&#123;</span><br><span class=\"line\">                turn++;</span><br><span class=\"line\">                <span class=\"comment\">// 省去每次 dfs 都要 memset 一次 visit 陣列的時間</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( dfs ( i ) )</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果可以找到新的配對就 ans++</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"tips\"><a class=\"header-anchor\" href=\"#tips\"></a>tips</h2><p>然後這邊我有用到一個小技巧，可以避免 TLE<br>通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow<br>不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）<br>如果我們把這個陣列開成 int 陣列<br>並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪<br>這樣就不用浪費時間去 memset 了</p><!-- rebuild by neat -->"},{"title":"[TOJ][420] C. 藏寶圖","date":"2018-09-10T06:17:57.000Z","_content":"\n今天來講講自己出的題目好了\n這題是我在今年（2018）六月時排名賽出的題目\n搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ\n<!--more-->\n\n\n## 題目\n\n先附上[原題目網址](https://toj.tfcis.org/oj/pro/420/)\n\n題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑\nMST 怎麼做？我這邊選用 Kruskal\n（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）\n\n## 先備知識\n\n在提 Kruskal 前，我們先講講 MST 到底是什麼吧\n\n### 最小生成樹\nMST 的正式全名為「最小生成樹」\n所謂的生成樹就是把這張圖拔掉一些邊後，這張圖*沒有環*以及*所有點都有聯通*\n也就是說：\n假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有*剛好*一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹\n\n而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T'$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹\n\n### 樹直徑\n\n那麼樹直徑又是什麼呢？\n通常樹直徑就是一棵樹上的任意點對的最長距離\n\n## 作法\n\n### Kruskal\n\n我先講講Kruskal是什麼好了\n\n按照MST的定義，有個很直觀的想法\n1. 先按照邊的權重對於所有邊由小到大排序過\n2. 依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中\n\n至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧\n這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)\n詳細內容可以看[這篇](https://miohitokiri5474.github.io/code/dsu/)\n\n### 樹直徑\n\n樹直徑作法通常有兩個：\n1. dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑\n2. 先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案\n\n作法1還挺好瞭解的，只是實作上可能會出包\n作法2有點費時間，但是很好寫\n\n\n## code\n\n總而言之，我的 code 長這樣\n是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 1000005\ntypedef pair < int, int > pii;\ntypedef long long LL;\n#define pb push_back\n#define F first\n#define S second\n\nstruct node{\n    int u, v, w;\n};\n\ninline bool cmp ( node a, node b ){\n    return a.w < b.w;\n}\n\nint dis[maxN];\nLL dist[maxN];\nvector < node > edges;\nvector < pii > mst[maxN];\n\ninline void init ( void ){\n    for ( int i = 0 ; i < maxN ; i++ )\n        dis[i] = i;\n}\n\nint find ( int n ){\n    return dis[n] == n ? n : dis[n] = find ( dis[n] );\n}\n\ninline void Union ( int a, int b ){\n    dis[find ( a )] = find ( b );\n}\n\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b );\n}\n\ninline void Kruskal ( void ){\n    sort ( edges.begin(), edges.end(), cmp );\n    for ( auto &i: edges ){\n        if ( same ( i.u, i.v ) )\n            continue;\n        Union ( i.u, i.v );\n        mst[i.u].pb ( pii ( i.v, i.w ) );\n        mst[i.v].pb ( pii ( i.u, i.w ) );\n    }\n}\n\nvoid dfs ( int n, int p ){ // 樹直徑\n    for ( auto i: mst[n] ){\n        if ( i.F == p )\n            continue;\n        dist[i.F] = dist[n] + i.S;\n        dfs ( i.F, n );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, u, v, w, t, idx, now;\n    LL ma = -1;\n    cin >> n >> m;\n    init();\n    while ( m-- ){\n        cin >> u >> v >> w;\n        edges.pb ( node { u, v, w } );\n    }\n\n    Kruskal();\n\n    dfs ( 0, -1 );\n    for ( int i = 0 ; i < n ; i++ )\n        if ( ma < dist[i] )\n            ma = dist[i], idx = i;\n\n    dist[idx] = 0;\n    dfs ( idx, -1 );\n    ma = -1;\n    for ( int i = 0 ; i < n ; i++ )\n        ma = max ( ma, dist[i] );\n\n    cout << ma << '\\n';\n}\n```\n\n\n## 後記\n\n我這一篇文我有種我是在寫 disjoint set 教學的錯覺\n覺得累\n大半篇幅都是在教 disjoint set\n看來原始 md 檔要破 300 行了呢（倒地\n\n然後還有那一堆數學式子，看到頭都在痛\n我個人還蠻喜歡寫那些東西的\n看起來很猛（就是中二啦 = =\n不過常常寫到一半會開始懷疑\n我沒事寫那麼難動幹嘛\n沒事虐待自己幹嘛\n話雖如此不過還是寫完了啦XD\n\n\n## 更新(2019/03/06)\n\n雖然說不是最近的事了，不過我想我還是提一下好了\n因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了\n所以目前在 TOJ 上寫不到這題喔\n非常抱歉 > <","source":"_posts/TOJ-420.md","raw":"---\ntitle: '[TOJ][420] C. 藏寶圖'\ndate: 2018-09-10 14:17:57\ntags:\n - TOJ\n - MST\n - dsu\n - dfs\n - 樹直徑\n - Kruskal\n---\n\n今天來講講自己出的題目好了\n這題是我在今年（2018）六月時排名賽出的題目\n搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ\n<!--more-->\n\n\n## 題目\n\n先附上[原題目網址](https://toj.tfcis.org/oj/pro/420/)\n\n題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑\nMST 怎麼做？我這邊選用 Kruskal\n（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）\n\n## 先備知識\n\n在提 Kruskal 前，我們先講講 MST 到底是什麼吧\n\n### 最小生成樹\nMST 的正式全名為「最小生成樹」\n所謂的生成樹就是把這張圖拔掉一些邊後，這張圖*沒有環*以及*所有點都有聯通*\n也就是說：\n假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有*剛好*一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹\n\n而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T'$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹\n\n### 樹直徑\n\n那麼樹直徑又是什麼呢？\n通常樹直徑就是一棵樹上的任意點對的最長距離\n\n## 作法\n\n### Kruskal\n\n我先講講Kruskal是什麼好了\n\n按照MST的定義，有個很直觀的想法\n1. 先按照邊的權重對於所有邊由小到大排序過\n2. 依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中\n\n至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧\n這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)\n詳細內容可以看[這篇](https://miohitokiri5474.github.io/code/dsu/)\n\n### 樹直徑\n\n樹直徑作法通常有兩個：\n1. dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑\n2. 先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案\n\n作法1還挺好瞭解的，只是實作上可能會出包\n作法2有點費時間，但是很好寫\n\n\n## code\n\n總而言之，我的 code 長這樣\n是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 1000005\ntypedef pair < int, int > pii;\ntypedef long long LL;\n#define pb push_back\n#define F first\n#define S second\n\nstruct node{\n    int u, v, w;\n};\n\ninline bool cmp ( node a, node b ){\n    return a.w < b.w;\n}\n\nint dis[maxN];\nLL dist[maxN];\nvector < node > edges;\nvector < pii > mst[maxN];\n\ninline void init ( void ){\n    for ( int i = 0 ; i < maxN ; i++ )\n        dis[i] = i;\n}\n\nint find ( int n ){\n    return dis[n] == n ? n : dis[n] = find ( dis[n] );\n}\n\ninline void Union ( int a, int b ){\n    dis[find ( a )] = find ( b );\n}\n\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b );\n}\n\ninline void Kruskal ( void ){\n    sort ( edges.begin(), edges.end(), cmp );\n    for ( auto &i: edges ){\n        if ( same ( i.u, i.v ) )\n            continue;\n        Union ( i.u, i.v );\n        mst[i.u].pb ( pii ( i.v, i.w ) );\n        mst[i.v].pb ( pii ( i.u, i.w ) );\n    }\n}\n\nvoid dfs ( int n, int p ){ // 樹直徑\n    for ( auto i: mst[n] ){\n        if ( i.F == p )\n            continue;\n        dist[i.F] = dist[n] + i.S;\n        dfs ( i.F, n );\n    }\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int n, m, u, v, w, t, idx, now;\n    LL ma = -1;\n    cin >> n >> m;\n    init();\n    while ( m-- ){\n        cin >> u >> v >> w;\n        edges.pb ( node { u, v, w } );\n    }\n\n    Kruskal();\n\n    dfs ( 0, -1 );\n    for ( int i = 0 ; i < n ; i++ )\n        if ( ma < dist[i] )\n            ma = dist[i], idx = i;\n\n    dist[idx] = 0;\n    dfs ( idx, -1 );\n    ma = -1;\n    for ( int i = 0 ; i < n ; i++ )\n        ma = max ( ma, dist[i] );\n\n    cout << ma << '\\n';\n}\n```\n\n\n## 後記\n\n我這一篇文我有種我是在寫 disjoint set 教學的錯覺\n覺得累\n大半篇幅都是在教 disjoint set\n看來原始 md 檔要破 300 行了呢（倒地\n\n然後還有那一堆數學式子，看到頭都在痛\n我個人還蠻喜歡寫那些東西的\n看起來很猛（就是中二啦 = =\n不過常常寫到一半會開始懷疑\n我沒事寫那麼難動幹嘛\n沒事虐待自己幹嘛\n話雖如此不過還是寫完了啦XD\n\n\n## 更新(2019/03/06)\n\n雖然說不是最近的事了，不過我想我還是提一下好了\n因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了\n所以目前在 TOJ 上寫不到這題喔\n非常抱歉 > <","slug":"TOJ-420","published":1,"updated":"2020-05-03T11:24:07.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsr000pxl9pgpf0fzzu","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>今天來講講自己出的題目好了<br>這題是我在今年（2018）六月時排名賽出的題目<br>搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ</p><a id=\"more\"></a><h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>先附上<a href=\"https://toj.tfcis.org/oj/pro/420/\" target=\"_blank\" rel=\"noopener\">原題目網址</a></p><p>題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑<br>MST 怎麼做？我這邊選用 Kruskal<br>（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）</p><h2 id=\"先備知識\"><a class=\"header-anchor\" href=\"#先備知識\"></a>先備知識</h2><p>在提 Kruskal 前，我們先講講 MST 到底是什麼吧</p><h3 id=\"最小生成樹\"><a class=\"header-anchor\" href=\"#最小生成樹\"></a>最小生成樹</h3><p>MST 的正式全名為「最小生成樹」<br>所謂的生成樹就是把這張圖拔掉一些邊後，這張圖<em>沒有環</em>以及<em>所有點都有聯通</em><br>也就是說：<br>假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有<em>剛好</em>一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹</p><p>而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T’$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹</p><h3 id=\"樹直徑\"><a class=\"header-anchor\" href=\"#樹直徑\"></a>樹直徑</h3><p>那麼樹直徑又是什麼呢？<br>通常樹直徑就是一棵樹上的任意點對的最長距離</p><h2 id=\"作法\"><a class=\"header-anchor\" href=\"#作法\"></a>作法</h2><h3 id=\"Kruskal\"><a class=\"header-anchor\" href=\"#Kruskal\"></a>Kruskal</h3><p>我先講講Kruskal是什麼好了</p><p>按照MST的定義，有個很直觀的想法</p><ol><li>先按照邊的權重對於所有邊由小到大排序過</li><li>依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中</li></ol><p>至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧<br>這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)<br>詳細內容可以看<a href=\"https://miohitokiri5474.github.io/code/dsu/\">這篇</a></p><h3 id=\"樹直徑-v2\"><a class=\"header-anchor\" href=\"#樹直徑-v2\"></a>樹直徑</h3><p>樹直徑作法通常有兩個：</p><ol><li>dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑</li><li>先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案</li></ol><p>作法1還挺好瞭解的，只是實作上可能會出包<br>作法2有點費時間，但是很好寫</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><p>總而言之，我的 code 長這樣<br>是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">cmp</span> <span class=\"params\">( node a, node b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\">LL dist[maxN];</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; node &gt; edges;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; pii &gt; mst[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">        dis[i] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[find ( a )] = find ( b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Kruskal</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        Union ( i.u, i.v );</span><br><span class=\"line\">        mst[i.u].pb ( pii ( i.v, i.w ) );</span><br><span class=\"line\">        mst[i.v].pb ( pii ( i.u, i.w ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> p )</span></span>&#123; <span class=\"comment\">// 樹直徑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: mst[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i.F == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dist[i.F] = dist[n] + i.S;</span><br><span class=\"line\">        dfs ( i.F, n );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, u, v, w, t, idx, now;</span><br><span class=\"line\">    LL ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class=\"line\">        edges.pb ( node &#123; u, v, w &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Kruskal();</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs ( <span class=\"number\">0</span>, <span class=\"number\">-1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ma &lt; dist[i] )</span><br><span class=\"line\">            ma = dist[i], idx = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    dist[idx] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dfs ( idx, <span class=\"number\">-1</span> );</span><br><span class=\"line\">    ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">        ma = max ( ma, dist[i] );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ma &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>我這一篇文我有種我是在寫 disjoint set 教學的錯覺<br>覺得累<br>大半篇幅都是在教 disjoint set<br>看來原始 md 檔要破 300 行了呢（倒地</p><p>然後還有那一堆數學式子，看到頭都在痛<br>我個人還蠻喜歡寫那些東西的<br>看起來很猛（就是中二啦 = =<br>不過常常寫到一半會開始懷疑<br>我沒事寫那麼難動幹嘛<br>沒事虐待自己幹嘛<br>話雖如此不過還是寫完了啦XD</p><h2 id=\"更新-2019-03-06\"><a class=\"header-anchor\" href=\"#更新-2019-03-06\"></a>更新(2019/03/06)</h2><p>雖然說不是最近的事了，不過我想我還是提一下好了<br>因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了<br>所以目前在 TOJ 上寫不到這題喔<br>非常抱歉 &gt; &lt;</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>今天來講講自己出的題目好了<br>這題是我在今年（2018）六月時排名賽出的題目<br>搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ</p>","more":"<h2 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h2><p>先附上<a href=\"https://toj.tfcis.org/oj/pro/420/\" target=\"_blank\" rel=\"noopener\">原題目網址</a></p><p>題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑<br>MST 怎麼做？我這邊選用 Kruskal<br>（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）</p><h2 id=\"先備知識\"><a class=\"header-anchor\" href=\"#先備知識\"></a>先備知識</h2><p>在提 Kruskal 前，我們先講講 MST 到底是什麼吧</p><h3 id=\"最小生成樹\"><a class=\"header-anchor\" href=\"#最小生成樹\"></a>最小生成樹</h3><p>MST 的正式全名為「最小生成樹」<br>所謂的生成樹就是把這張圖拔掉一些邊後，這張圖<em>沒有環</em>以及<em>所有點都有聯通</em><br>也就是說：<br>假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有<em>剛好</em>一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹</p><p>而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T’$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹</p><h3 id=\"樹直徑\"><a class=\"header-anchor\" href=\"#樹直徑\"></a>樹直徑</h3><p>那麼樹直徑又是什麼呢？<br>通常樹直徑就是一棵樹上的任意點對的最長距離</p><h2 id=\"作法\"><a class=\"header-anchor\" href=\"#作法\"></a>作法</h2><h3 id=\"Kruskal\"><a class=\"header-anchor\" href=\"#Kruskal\"></a>Kruskal</h3><p>我先講講Kruskal是什麼好了</p><p>按照MST的定義，有個很直觀的想法</p><ol><li>先按照邊的權重對於所有邊由小到大排序過</li><li>依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中</li></ol><p>至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧<br>這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)<br>詳細內容可以看<a href=\"https://miohitokiri5474.github.io/code/dsu/\">這篇</a></p><h3 id=\"樹直徑-v2\"><a class=\"header-anchor\" href=\"#樹直徑-v2\"></a>樹直徑</h3><p>樹直徑作法通常有兩個：</p><ol><li>dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑</li><li>先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案</li></ol><p>作法1還挺好瞭解的，只是實作上可能會出包<br>作法2有點費時間，但是很好寫</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><p>總而言之，我的 code 長這樣<br>是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 1000005</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> F first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> S second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> u, v, w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">cmp</span> <span class=\"params\">( node a, node b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\">LL dist[maxN];</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; node &gt; edges;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; pii &gt; mst[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">        dis[i] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[find ( a )] = find ( b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Kruskal</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> &amp;i: edges )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( same ( i.u, i.v ) )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        Union ( i.u, i.v );</span><br><span class=\"line\">        mst[i.u].pb ( pii ( i.v, i.w ) );</span><br><span class=\"line\">        mst[i.v].pb ( pii ( i.u, i.w ) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> p )</span></span>&#123; <span class=\"comment\">// 樹直徑</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: mst[n] )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( i.F == p )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dist[i.F] = dist[n] + i.S;</span><br><span class=\"line\">        dfs ( i.F, n );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m, u, v, w, t, idx, now;</span><br><span class=\"line\">    LL ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class=\"line\">        edges.pb ( node &#123; u, v, w &#125; );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Kruskal();</span><br><span class=\"line\"></span><br><span class=\"line\">    dfs ( <span class=\"number\">0</span>, <span class=\"number\">-1</span> );</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( ma &lt; dist[i] )</span><br><span class=\"line\">            ma = dist[i], idx = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    dist[idx] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dfs ( idx, <span class=\"number\">-1</span> );</span><br><span class=\"line\">    ma = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; n ; i++ )</span><br><span class=\"line\">        ma = max ( ma, dist[i] );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; ma &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>我這一篇文我有種我是在寫 disjoint set 教學的錯覺<br>覺得累<br>大半篇幅都是在教 disjoint set<br>看來原始 md 檔要破 300 行了呢（倒地</p><p>然後還有那一堆數學式子，看到頭都在痛<br>我個人還蠻喜歡寫那些東西的<br>看起來很猛（就是中二啦 = =<br>不過常常寫到一半會開始懷疑<br>我沒事寫那麼難動幹嘛<br>沒事虐待自己幹嘛<br>話雖如此不過還是寫完了啦XD</p><h2 id=\"更新-2019-03-06\"><a class=\"header-anchor\" href=\"#更新-2019-03-06\"></a>更新(2019/03/06)</h2><p>雖然說不是最近的事了，不過我想我還是提一下好了<br>因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了<br>所以目前在 TOJ 上寫不到這題喔<br>非常抱歉 &gt; &lt;</p><!-- rebuild by neat -->"},{"title":"Disjoint Set 並查集","date":"2018-09-11T00:16:11.000Z","_content":"\n上一篇blog因為介紹並查集的地方太多了，文章太長\n所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了\n然後會在昨天文章上加入這篇的連結\n<!--more-->\n\n## disjoint set 並查集\n\n我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）\n在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$\n至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了\n\n這個時候大概會寫出像這樣的 code\n\n```cpp\n// disjoint set\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 10005\n\nint dis[maxN];\n\ninline void init ( void ){\n    for ( int i = 0 ; i < maxN ; i++ )\n        dis[i] = i;\n}\n\ninline int find ( int n ){\n    return dis[n] == n ? dis[n] : find ( dis[n] );\n}\n\ninline void Union ( int a, int b ){\n    dis[a] = b;\n}\n\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b );\n}\n```\n\n### 路徑壓縮\n\n我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）\n所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰\n下次就可以直接略過中間的點，直接到老大那了\n\nfind 函數會被改成這樣\n親民寫法：\n```cpp\nvoid find ( int n ){\n    if ( dis[n] == n )\n        return n;\n    return dis[n] = find ( n );\n}\n```\n\n然後就是會有人（例如我），會想要把它寫在一起\n所以就變成這樣了XD\n```cpp\nvoid find ( int n ){\n    return dis[n] == n ? n : dis[n] = find ( dis[n] );\n}\n```\n\n最後這個東西的複雜度會變成均攤 $O ( \\log N )$，感覺還不錯\n\n\n### 避免 Stack Overflow\n\n最最最後有個東西也挺重要的\n因為路徑壓縮還是要按照這個點的遍歷往上爬\n又是用遞迴實作\n所以有機會會戳到 Stack overflow\n然後你就吃 RE 了\n恭喜多一個 penalty\n重點是你不知道**這樣會吃到 Stack overflow** 然後就會多吃幾個w\n\n雖然說現在很多 judge 都避免掉了啦\n會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大\n只是難免會戳到那種舊型 judge\n所以還是乖乖學一下怎麼避免 Stack overflow 吧\n\n要壓縮遞迴深度，可以有兩種方法\n\n#### 方法一：random\n\n在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍\n但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦\n\n```cpp\ninline void Union ( int a, int b ){\n    dis[a] = b;\n    find ( rand() % n );\n}\n```\n\n#### 方法二：Union by rank\n\n把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈\n理論上這樣應該不會爆炸，因為深度很平均\n\n```cpp\nint rk[maxN];\n\ninline void Union ( int a, int b ){\n    if ( rk[a] < rk[b] )\n        swap ( a, b );\n    dis[b] = a;\n    rk[b] = rk[a] + 1 ;\n}\n```\n\n這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下\n那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數\n至於那是啥我也不知道，只知道幾乎可以算是常數了\n\n不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用\n\n#### 方法三：Union by size\n\n這也挺直觀的\n把大小比較小的並查集接在大的下面\n比較小，需要做改動的點就比較少，對吧\n\n```cpp\nint sz[maxN];\n\ninline void Union ( int a, int b ){\n    if ( sz[a] > sz[b] )\n        swap ( a, b );\n    dis[a] = b;\n    sz[b] += sz[a];\n}\n```\n\n#### 如果開優化還是爛了呢\n\n通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size\n再爛掉。。。這應該是叫你去寫啟發式合併吧\n據說那東西比並查集還要快\n不過我也沒有實作過，所以我並不清楚\n\n\n### 確認是否屬於同一個並查集\n\n確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內\n\n```cpp\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b )\n}\n```\n\n\n用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了\n\n\n## 後記\n\n我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =\n現在看了一下，我光 dsu 就寫 171 行了@@\n覺得累","source":"_posts/dsu.md","raw":"---\ntitle: 'Disjoint Set 並查集'\ndate: 2018-09-11 08:16:11\ntags:\n - dsu\n - disjoint set\n - data structure\n---\n\n上一篇blog因為介紹並查集的地方太多了，文章太長\n所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了\n然後會在昨天文章上加入這篇的連結\n<!--more-->\n\n## disjoint set 並查集\n\n我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）\n在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$\n至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了\n\n這個時候大概會寫出像這樣的 code\n\n```cpp\n// disjoint set\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define maxN 10005\n\nint dis[maxN];\n\ninline void init ( void ){\n    for ( int i = 0 ; i < maxN ; i++ )\n        dis[i] = i;\n}\n\ninline int find ( int n ){\n    return dis[n] == n ? dis[n] : find ( dis[n] );\n}\n\ninline void Union ( int a, int b ){\n    dis[a] = b;\n}\n\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b );\n}\n```\n\n### 路徑壓縮\n\n我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）\n所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰\n下次就可以直接略過中間的點，直接到老大那了\n\nfind 函數會被改成這樣\n親民寫法：\n```cpp\nvoid find ( int n ){\n    if ( dis[n] == n )\n        return n;\n    return dis[n] = find ( n );\n}\n```\n\n然後就是會有人（例如我），會想要把它寫在一起\n所以就變成這樣了XD\n```cpp\nvoid find ( int n ){\n    return dis[n] == n ? n : dis[n] = find ( dis[n] );\n}\n```\n\n最後這個東西的複雜度會變成均攤 $O ( \\log N )$，感覺還不錯\n\n\n### 避免 Stack Overflow\n\n最最最後有個東西也挺重要的\n因為路徑壓縮還是要按照這個點的遍歷往上爬\n又是用遞迴實作\n所以有機會會戳到 Stack overflow\n然後你就吃 RE 了\n恭喜多一個 penalty\n重點是你不知道**這樣會吃到 Stack overflow** 然後就會多吃幾個w\n\n雖然說現在很多 judge 都避免掉了啦\n會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大\n只是難免會戳到那種舊型 judge\n所以還是乖乖學一下怎麼避免 Stack overflow 吧\n\n要壓縮遞迴深度，可以有兩種方法\n\n#### 方法一：random\n\n在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍\n但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦\n\n```cpp\ninline void Union ( int a, int b ){\n    dis[a] = b;\n    find ( rand() % n );\n}\n```\n\n#### 方法二：Union by rank\n\n把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈\n理論上這樣應該不會爆炸，因為深度很平均\n\n```cpp\nint rk[maxN];\n\ninline void Union ( int a, int b ){\n    if ( rk[a] < rk[b] )\n        swap ( a, b );\n    dis[b] = a;\n    rk[b] = rk[a] + 1 ;\n}\n```\n\n這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下\n那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數\n至於那是啥我也不知道，只知道幾乎可以算是常數了\n\n不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用\n\n#### 方法三：Union by size\n\n這也挺直觀的\n把大小比較小的並查集接在大的下面\n比較小，需要做改動的點就比較少，對吧\n\n```cpp\nint sz[maxN];\n\ninline void Union ( int a, int b ){\n    if ( sz[a] > sz[b] )\n        swap ( a, b );\n    dis[a] = b;\n    sz[b] += sz[a];\n}\n```\n\n#### 如果開優化還是爛了呢\n\n通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size\n再爛掉。。。這應該是叫你去寫啟發式合併吧\n據說那東西比並查集還要快\n不過我也沒有實作過，所以我並不清楚\n\n\n### 確認是否屬於同一個並查集\n\n確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內\n\n```cpp\ninline bool same ( int a, int b ){\n    return find ( a ) == find ( b )\n}\n```\n\n\n用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了\n\n\n## 後記\n\n我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =\n現在看了一下，我光 dsu 就寫 171 行了@@\n覺得累","slug":"dsu","published":1,"updated":"2020-05-03T11:24:07.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsv000rxl9p4nbp4bsz","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>上一篇blog因為介紹並查集的地方太多了，文章太長<br>所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了<br>然後會在昨天文章上加入這篇的連結</p><a id=\"more\"></a><h2 id=\"disjoint-set-並查集\"><a class=\"header-anchor\" href=\"#disjoint-set-並查集\"></a>disjoint set 並查集</h2><p>我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）<br>在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$<br>至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了</p><p>這個時候大概會寫出像這樣的 code</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// disjoint set</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 10005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">        dis[i] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? dis[n] : find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"路徑壓縮\"><a class=\"header-anchor\" href=\"#路徑壓縮\"></a>路徑壓縮</h3><p>我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）<br>所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰<br>下次就可以直接略過中間的點，直接到老大那了</p><p>find 函數會被改成這樣<br>親民寫法：</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( dis[n] == n )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] = find ( n );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然後就是會有人（例如我），會想要把它寫在一起<br>所以就變成這樣了XD</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>最後這個東西的複雜度會變成均攤 $O ( \\log N )$，感覺還不錯</p><h3 id=\"避免-Stack-Overflow\"><a class=\"header-anchor\" href=\"#避免-Stack-Overflow\"></a>避免 Stack Overflow</h3><p>最最最後有個東西也挺重要的<br>因為路徑壓縮還是要按照這個點的遍歷往上爬<br>又是用遞迴實作<br>所以有機會會戳到 Stack overflow<br>然後你就吃 RE 了<br>恭喜多一個 penalty<br>重點是你不知道<strong>這樣會吃到 Stack overflow</strong> 然後就會多吃幾個w</p><p>雖然說現在很多 judge 都避免掉了啦<br>會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大<br>只是難免會戳到那種舊型 judge<br>所以還是乖乖學一下怎麼避免 Stack overflow 吧</p><p>要壓縮遞迴深度，可以有兩種方法</p><h4 id=\"方法一：random\"><a class=\"header-anchor\" href=\"#方法一：random\"></a>方法一：random</h4><p>在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍<br>但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">    find ( rand() % n );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：Union-by-rank\"><a class=\"header-anchor\" href=\"#方法二：Union-by-rank\"></a>方法二：Union by rank</h4><p>把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈<br>理論上這樣應該不會爆炸，因為深度很平均</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> rk[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( rk[a] &lt; rk[b] )</span><br><span class=\"line\">        swap ( a, b );</span><br><span class=\"line\">    dis[b] = a;</span><br><span class=\"line\">    rk[b] = rk[a] + <span class=\"number\">1</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下<br>那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數<br>至於那是啥我也不知道，只知道幾乎可以算是常數了</p><p>不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用</p><h4 id=\"方法三：Union-by-size\"><a class=\"header-anchor\" href=\"#方法三：Union-by-size\"></a>方法三：Union by size</h4><p>這也挺直觀的<br>把大小比較小的並查集接在大的下面<br>比較小，需要做改動的點就比較少，對吧</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sz[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( sz[a] &gt; sz[b] )</span><br><span class=\"line\">        swap ( a, b );</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">    sz[b] += sz[a];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"如果開優化還是爛了呢\"><a class=\"header-anchor\" href=\"#如果開優化還是爛了呢\"></a>如果開優化還是爛了呢</h4><p>通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size<br>再爛掉。。。這應該是叫你去寫啟發式合併吧<br>據說那東西比並查集還要快<br>不過我也沒有實作過，所以我並不清楚</p><h3 id=\"確認是否屬於同一個並查集\"><a class=\"header-anchor\" href=\"#確認是否屬於同一個並查集\"></a>確認是否屬於同一個並查集</h3><p>確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了</p><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =<br>現在看了一下，我光 dsu 就寫 171 行了@@<br>覺得累</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>上一篇blog因為介紹並查集的地方太多了，文章太長<br>所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了<br>然後會在昨天文章上加入這篇的連結</p>","more":"<h2 id=\"disjoint-set-並查集\"><a class=\"header-anchor\" href=\"#disjoint-set-並查集\"></a>disjoint set 並查集</h2><p>我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）<br>在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$<br>至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了</p><p>這個時候大概會寫出像這樣的 code</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// disjoint set</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxN 10005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; maxN ; i++ )</span><br><span class=\"line\">        dis[i] = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? dis[n] : find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"路徑壓縮\"><a class=\"header-anchor\" href=\"#路徑壓縮\"></a>路徑壓縮</h3><p>我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）<br>所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰<br>下次就可以直接略過中間的點，直接到老大那了</p><p>find 函數會被改成這樣<br>親民寫法：</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( dis[n] == n )</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] = find ( n );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>然後就是會有人（例如我），會想要把它寫在一起<br>所以就變成這樣了XD</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>最後這個東西的複雜度會變成均攤 $O ( \\log N )$，感覺還不錯</p><h3 id=\"避免-Stack-Overflow\"><a class=\"header-anchor\" href=\"#避免-Stack-Overflow\"></a>避免 Stack Overflow</h3><p>最最最後有個東西也挺重要的<br>因為路徑壓縮還是要按照這個點的遍歷往上爬<br>又是用遞迴實作<br>所以有機會會戳到 Stack overflow<br>然後你就吃 RE 了<br>恭喜多一個 penalty<br>重點是你不知道<strong>這樣會吃到 Stack overflow</strong> 然後就會多吃幾個w</p><p>雖然說現在很多 judge 都避免掉了啦<br>會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大<br>只是難免會戳到那種舊型 judge<br>所以還是乖乖學一下怎麼避免 Stack overflow 吧</p><p>要壓縮遞迴深度，可以有兩種方法</p><h4 id=\"方法一：random\"><a class=\"header-anchor\" href=\"#方法一：random\"></a>方法一：random</h4><p>在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍<br>但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">    find ( rand() % n );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"方法二：Union-by-rank\"><a class=\"header-anchor\" href=\"#方法二：Union-by-rank\"></a>方法二：Union by rank</h4><p>把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈<br>理論上這樣應該不會爆炸，因為深度很平均</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> rk[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( rk[a] &lt; rk[b] )</span><br><span class=\"line\">        swap ( a, b );</span><br><span class=\"line\">    dis[b] = a;</span><br><span class=\"line\">    rk[b] = rk[a] + <span class=\"number\">1</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下<br>那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數<br>至於那是啥我也不知道，只知道幾乎可以算是常數了</p><p>不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用</p><h4 id=\"方法三：Union-by-size\"><a class=\"header-anchor\" href=\"#方法三：Union-by-size\"></a>方法三：Union by size</h4><p>這也挺直觀的<br>把大小比較小的並查集接在大的下面<br>比較小，需要做改動的點就比較少，對吧</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sz[maxN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Union</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( sz[a] &gt; sz[b] )</span><br><span class=\"line\">        swap ( a, b );</span><br><span class=\"line\">    dis[a] = b;</span><br><span class=\"line\">    sz[b] += sz[a];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"如果開優化還是爛了呢\"><a class=\"header-anchor\" href=\"#如果開優化還是爛了呢\"></a>如果開優化還是爛了呢</h4><p>通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size<br>再爛掉。。。這應該是叫你去寫啟發式合併吧<br>據說那東西比並查集還要快<br>不過我也沒有實作過，所以我並不清楚</p><h3 id=\"確認是否屬於同一個並查集\"><a class=\"header-anchor\" href=\"#確認是否屬於同一個並查集\"></a>確認是否屬於同一個並查集</h3><p>確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b )</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find ( a ) == find ( b )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了</p><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =<br>現在看了一下，我光 dsu 就寫 171 行了@@<br>覺得累</p><!-- rebuild by neat -->"},{"title":"Golang心情隨筆 #1","date":"2019-11-08T07:28:17.000Z","_content":"\n我也有點忘記我最初為什麼會接觸 Golang 了\n應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現\n像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？\n<!--more-->\n而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她\n其中好像就有一本Golang的語法書\n雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了\n所以我就開始翻了起來\n起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱\n像是我可以在 C 裡面 #include<stdio.h> 後，然後就直接用標頭檔裡面的函數\n不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( \"%d\", &n ) 之類的\n（嚴格來說應該是 fmt.Scanf ( \"%d\", &n )）\n但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww\n明明就只是要 print 個 Hello, World! 要寫 class ww\n\n.\n\n最近比較有空，所以想說來複習一下 Golang 怎麼寫（？\n論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽\n或者是拿它來寫程設作業\n什麼？只能用 C 寫喔\n沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ\n\n不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器","source":"_posts/gd-1.md","raw":"---\ntitle: 'Golang心情隨筆 #1'\ndate: 2019-11-08 15:28:17\ntags:\n - Golang\n---\n\n我也有點忘記我最初為什麼會接觸 Golang 了\n應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現\n像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？\n<!--more-->\n而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她\n其中好像就有一本Golang的語法書\n雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了\n所以我就開始翻了起來\n起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱\n像是我可以在 C 裡面 #include<stdio.h> 後，然後就直接用標頭檔裡面的函數\n不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( \"%d\", &n ) 之類的\n（嚴格來說應該是 fmt.Scanf ( \"%d\", &n )）\n但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww\n明明就只是要 print 個 Hello, World! 要寫 class ww\n\n.\n\n最近比較有空，所以想說來複習一下 Golang 怎麼寫（？\n論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽\n或者是拿它來寫程設作業\n什麼？只能用 C 寫喔\n沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ\n\n不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器","slug":"gd-1","published":1,"updated":"2020-05-03T11:24:07.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsw000txl9p3i78h0vv","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>我也有點忘記我最初為什麼會接觸 Golang 了<br>應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現<br>像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？</p><a id=\"more\"></a><p>而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她<br>其中好像就有一本Golang的語法書<br>雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了<br>所以我就開始翻了起來<br>起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱<br>像是我可以在 C 裡面 #include&lt;stdio.h&gt; 後，然後就直接用標頭檔裡面的函數<br>不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( “%d”, &amp;n ) 之類的<br>（嚴格來說應該是 fmt.Scanf ( “%d”, &amp;n )）<br>但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww<br>明明就只是要 print 個 Hello, World! 要寫 class ww</p><p>.</p><p>最近比較有空，所以想說來複習一下 Golang 怎麼寫（？<br>論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽<br>或者是拿它來寫程設作業<br>什麼？只能用 C 寫喔<br>沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ</p><p>不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><p>我也有點忘記我最初為什麼會接觸 Golang 了<br>應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現<br>像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？</p>","more":"<p>而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她<br>其中好像就有一本Golang的語法書<br>雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了<br>所以我就開始翻了起來<br>起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱<br>像是我可以在 C 裡面 #include&lt;stdio.h&gt; 後，然後就直接用標頭檔裡面的函數<br>不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( “%d”, &amp;n ) 之類的<br>（嚴格來說應該是 fmt.Scanf ( “%d”, &amp;n )）<br>但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww<br>明明就只是要 print 個 Hello, World! 要寫 class ww</p><p>.</p><p>最近比較有空，所以想說來複習一下 Golang 怎麼寫（？<br>論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽<br>或者是拿它來寫程設作業<br>什麼？只能用 C 寫喔<br>沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ</p><p>不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器</p><!-- rebuild by neat -->"},{"title":"[ITSA] No.66 詳解","date":"2018-09-13T00:20:50.000Z","_content":"\n## 前言\n\n簡單來說就是我特殊選才的資料不夠\n所以只好來打這東西，不然備審有夠空QQ\n<!--more-->\n\n## problem 1\n\n### 題目\n\n這題就是給你一行整數（數量不定，但是保證 < 11個）\n求該行出現率「超過」一半的整數\n\n### 解法\n\n看到數量不定就會用 getline + stringstream，這很直觀\n然後因為他只有說「給整數」，並沒有限制數字大小\n所以我是用 map 做，而不是陣列（出現負數就尷尬了）\n雖然比較慢但是也比較無腦\n\n為什麼我會在題目那把「超過」加上引號？\n。。。因為我在寫 code 的時候耍智障把判斷式寫成 >=\n然後我就吃 WA 了\n我還跑去問如果有多組解怎麼辦\n結果超過一半的數字只會有一個QQ\n還有把 NO 打成 No\n就多吃兩個 penalty 了，虧爆\n抓到，澪人桐不會寫程式\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nmap < int, int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str;\n    int in, cnt;\n    bool ans;\n    while ( getline ( cin, str ) ){\n        lib.clear();\n        cnt = 0;\n        ans = false;\n        stringstream ss ( str );\n        while ( ss >> in ){\n            lib[in]++;\n            cnt++;\n        }\n\n        for ( auto i: lib ){\n            if ( i.S > cnt / 2 ){\n                cout << i.F << '\\n';\n                ans = true;\n                break;\n            }\n        }\n        if ( !ans )\n            cout << \"NO\\n\";\n    }\n}\n```\n\n## problem 2\n\n### 題目\n\n給一個簡單的一元一次方程式\n保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除\n並保證所有運算元與運算子之間只都有空白隔開\n並且求出 $x$，無條件捨去到小數點第一位\n\n### 解法\n\n要寫字串判斷很麻煩欸 = =\npA寫爆了先來寫這題（？\n手速不知道為什麼爆快\n快到我自己也嚇到\n也沒出什麼 bug，很快就 AC 了 <3\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n\nstring str;\nvector < int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int opt, len, x, a, b, ans;\n    bool flag;\n    while ( getline ( cin, str ) ){\n        len = str.size(), x = 0, ans = 0;\n        flag = false;\n        lib.clear();\n        for ( int i = 0 ; i < len ; i++ ){\n            if ( str[i] == '+' )\n                opt = 0;\n            else if ( str[i] == '-' )\n                opt = 1;\n            else if ( str[i] == '*' )\n                opt = 2;\n            else if ( str[i] == '/' )\n                opt = 3;\n            else{\n                if ( '0' <= str[i] && str[i] <= '9' ){\n                    x = x * 10 + int ( str[i] - '0' );\n                    flag = true;\n                }\n                else{\n                    if ( flag )\n                        lib.pb ( x );\n                    x = 0, flag = false;\n                }\n            }\n        }\n        if ( flag )\n            lib.pb ( x );\n        a = lib[0], b = lib[1];\n        if ( !opt )\n            ans = ( b - a ) * 10.0;\n        else if ( opt == 1 )\n            ans = ( b + a ) * 10.0;\n        else if ( opt == 2 )\n            ans = ( int ) ( ( double ) b / a * 10.0 );\n        else{\n            if ( str[0] == 'x' )\n                ans = ( int ) ( ( double ) b * a * 10.0 );\n            else\n                ans = ( int ) ( ( double ) a / b * 10.0 );\n        }\n        cout << ans / 10 << '.' << ans % 10 << '\\n';\n    }\n}\n```\n\n\n## problem 3\n\n### 題目\n\n給定 $N$ 組字串，請將字串以 $':' or ';' or ','$ 切割\n並輸出出所有字串\n\n### 解法\n\n啊就水題水到爆啊，多開個 string 紀錄就好了\n這題沒有難度（蓋章\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str, swp;\n    int t;\n    cin >> t;\n    getline ( cin, str );\n    while ( t-- ){\n        getline ( cin, str );\n        cout << \"Tokens found:\\n\";\n        swp = \"\";\n        for ( auto i: str ){\n            if ( i == ':' || i == ',' || i == ';' ){\n                cout << swp << '\\n';\n                swp = \"\";\n            }\n            else\n                swp += i;\n        }\n        if ( swp != \"\" )\n            cout << swp << '\\n';\n    }\n}\n```\n\n\n## problem 4\n\n### 題目\n\nzj 上面的是羅馬數字轉阿拉伯數字\n這次 ITSA 出的是要把阿拉伯數字轉羅馬數字\n更水 = =\n\n### 解法\n\n直接按照位數打表輸出就好\n。。。雖然這麼說，但是我還是出 bug 了\n我把4打成\"IIII\"，正確應該是\"IX\"\n垃圾是我QQ\n\n### code\n\n```cpp\n// by.MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstring lib0[10] = { \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\" };\nstring lib1[10] = { \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\" };\nstring lib2[10] = { \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\" };\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, in;\n    cin >> t;\n    while ( t-- ){\n        cin >> in;\n        cout << lib2[in / 100] << lib1[in % 100 / 10] << lib0[in % 10] << '\\n';\n    }\n}\n```\n\n\n## problem 5\n\n### 題目\n\n給定兩個字串，求出這兩個字串所有的 LCS\n\n### 解法\n\n本來只有丟任意解的 LCS\n然後就吃 WA 了，又多一個 penalty\n問官方官方一直沒有回應\n就想說先寫所有解的版本好了\n等到一回覆馬上 judge\n\n然後這就是裸的 LCS 啊 = =\n\n### code\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint dp[105][105], ma;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string a, b, str;\n    set < string > lib;\n    while ( cin >> a >> b ){\n        int szA = a.size(), szB = b.size();\n        lib.clear();\n        memset ( dp, 0, sizeof dp );\n        ma = 0;\n        for ( int i = 0 ; i < szA ; i++ ){\n            for ( int j = 0 ; j < szB ; j++ ){\n                if ( a[i] == b[j] ){\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\n                    ma = max ( ma, dp[i + 1][j + 1] );\n                }\n            }\n        }\n        if ( !ma ){\n            cout << \"No common sequence!\\n\";\n            continue;\n        }\n        for ( int i = 0 ; i < szA ; i++ ){\n            for ( int j = 0 ; j < szB ; j++ ){\n                if ( dp[i + 1][j + 1] == ma ){\n                    str = \"\";\n                    for ( int k = i - ma + 1 ; k <= i ; k++ )\n                        str += a[k];\n                    lib.insert ( str );\n                }\n            }\n        }\n        for ( auto i: lib )\n            cout << i << '\\n';\n    }\n}\n```\n\n\n## 後記\n\n在第 37 分鐘的時候就破台了\n（那時候師大還沒有破台）\n那時候我跟師大的 penalty 差 67\n也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了\n。。。然後師大只吃 66\n80 抽抽不到術師匠的非洲酋長正常發揮QQ\n\n下一次沒意外就會去打 PTC 了\n不過是英文題目\n我覺得我會扛不起來\n在此誠徵英文好的選手一名\n工作：只要幫我翻譯題目就好\n\n然後這一篇的題解我居然寫了 330 行\n喔，這行就 331 了 = =\n雖然看起來很多不過大部分都是 code 就是了","source":"_posts/itsa-66.md","raw":"---\ntitle: '[ITSA] No.66 詳解'\ndate: 2018-09-13 08:20:50\ntags:\n - ITSA\n - Full Contest Solution\n---\n\n## 前言\n\n簡單來說就是我特殊選才的資料不夠\n所以只好來打這東西，不然備審有夠空QQ\n<!--more-->\n\n## problem 1\n\n### 題目\n\n這題就是給你一行整數（數量不定，但是保證 < 11個）\n求該行出現率「超過」一半的整數\n\n### 解法\n\n看到數量不定就會用 getline + stringstream，這很直觀\n然後因為他只有說「給整數」，並沒有限制數字大小\n所以我是用 map 做，而不是陣列（出現負數就尷尬了）\n雖然比較慢但是也比較無腦\n\n為什麼我會在題目那把「超過」加上引號？\n。。。因為我在寫 code 的時候耍智障把判斷式寫成 >=\n然後我就吃 WA 了\n我還跑去問如果有多組解怎麼辦\n結果超過一半的數字只會有一個QQ\n還有把 NO 打成 No\n就多吃兩個 penalty 了，虧爆\n抓到，澪人桐不會寫程式\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nmap < int, int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str;\n    int in, cnt;\n    bool ans;\n    while ( getline ( cin, str ) ){\n        lib.clear();\n        cnt = 0;\n        ans = false;\n        stringstream ss ( str );\n        while ( ss >> in ){\n            lib[in]++;\n            cnt++;\n        }\n\n        for ( auto i: lib ){\n            if ( i.S > cnt / 2 ){\n                cout << i.F << '\\n';\n                ans = true;\n                break;\n            }\n        }\n        if ( !ans )\n            cout << \"NO\\n\";\n    }\n}\n```\n\n## problem 2\n\n### 題目\n\n給一個簡單的一元一次方程式\n保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除\n並保證所有運算元與運算子之間只都有空白隔開\n並且求出 $x$，無條件捨去到小數點第一位\n\n### 解法\n\n要寫字串判斷很麻煩欸 = =\npA寫爆了先來寫這題（？\n手速不知道為什麼爆快\n快到我自己也嚇到\n也沒出什麼 bug，很快就 AC 了 <3\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n\nstring str;\nvector < int > lib;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int opt, len, x, a, b, ans;\n    bool flag;\n    while ( getline ( cin, str ) ){\n        len = str.size(), x = 0, ans = 0;\n        flag = false;\n        lib.clear();\n        for ( int i = 0 ; i < len ; i++ ){\n            if ( str[i] == '+' )\n                opt = 0;\n            else if ( str[i] == '-' )\n                opt = 1;\n            else if ( str[i] == '*' )\n                opt = 2;\n            else if ( str[i] == '/' )\n                opt = 3;\n            else{\n                if ( '0' <= str[i] && str[i] <= '9' ){\n                    x = x * 10 + int ( str[i] - '0' );\n                    flag = true;\n                }\n                else{\n                    if ( flag )\n                        lib.pb ( x );\n                    x = 0, flag = false;\n                }\n            }\n        }\n        if ( flag )\n            lib.pb ( x );\n        a = lib[0], b = lib[1];\n        if ( !opt )\n            ans = ( b - a ) * 10.0;\n        else if ( opt == 1 )\n            ans = ( b + a ) * 10.0;\n        else if ( opt == 2 )\n            ans = ( int ) ( ( double ) b / a * 10.0 );\n        else{\n            if ( str[0] == 'x' )\n                ans = ( int ) ( ( double ) b * a * 10.0 );\n            else\n                ans = ( int ) ( ( double ) a / b * 10.0 );\n        }\n        cout << ans / 10 << '.' << ans % 10 << '\\n';\n    }\n}\n```\n\n\n## problem 3\n\n### 題目\n\n給定 $N$ 組字串，請將字串以 $':' or ';' or ','$ 切割\n並輸出出所有字串\n\n### 解法\n\n啊就水題水到爆啊，多開個 string 紀錄就好了\n這題沒有難度（蓋章\n\n### code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str, swp;\n    int t;\n    cin >> t;\n    getline ( cin, str );\n    while ( t-- ){\n        getline ( cin, str );\n        cout << \"Tokens found:\\n\";\n        swp = \"\";\n        for ( auto i: str ){\n            if ( i == ':' || i == ',' || i == ';' ){\n                cout << swp << '\\n';\n                swp = \"\";\n            }\n            else\n                swp += i;\n        }\n        if ( swp != \"\" )\n            cout << swp << '\\n';\n    }\n}\n```\n\n\n## problem 4\n\n### 題目\n\nzj 上面的是羅馬數字轉阿拉伯數字\n這次 ITSA 出的是要把阿拉伯數字轉羅馬數字\n更水 = =\n\n### 解法\n\n直接按照位數打表輸出就好\n。。。雖然這麼說，但是我還是出 bug 了\n我把4打成\"IIII\"，正確應該是\"IX\"\n垃圾是我QQ\n\n### code\n\n```cpp\n// by.MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstring lib0[10] = { \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\" };\nstring lib1[10] = { \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\" };\nstring lib2[10] = { \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\" };\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    int t, in;\n    cin >> t;\n    while ( t-- ){\n        cin >> in;\n        cout << lib2[in / 100] << lib1[in % 100 / 10] << lib0[in % 10] << '\\n';\n    }\n}\n```\n\n\n## problem 5\n\n### 題目\n\n給定兩個字串，求出這兩個字串所有的 LCS\n\n### 解法\n\n本來只有丟任意解的 LCS\n然後就吃 WA 了，又多一個 penalty\n問官方官方一直沒有回應\n就想說先寫所有解的版本好了\n等到一回覆馬上 judge\n\n然後這就是裸的 LCS 啊 = =\n\n### code\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint dp[105][105], ma;\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string a, b, str;\n    set < string > lib;\n    while ( cin >> a >> b ){\n        int szA = a.size(), szB = b.size();\n        lib.clear();\n        memset ( dp, 0, sizeof dp );\n        ma = 0;\n        for ( int i = 0 ; i < szA ; i++ ){\n            for ( int j = 0 ; j < szB ; j++ ){\n                if ( a[i] == b[j] ){\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\n                    ma = max ( ma, dp[i + 1][j + 1] );\n                }\n            }\n        }\n        if ( !ma ){\n            cout << \"No common sequence!\\n\";\n            continue;\n        }\n        for ( int i = 0 ; i < szA ; i++ ){\n            for ( int j = 0 ; j < szB ; j++ ){\n                if ( dp[i + 1][j + 1] == ma ){\n                    str = \"\";\n                    for ( int k = i - ma + 1 ; k <= i ; k++ )\n                        str += a[k];\n                    lib.insert ( str );\n                }\n            }\n        }\n        for ( auto i: lib )\n            cout << i << '\\n';\n    }\n}\n```\n\n\n## 後記\n\n在第 37 分鐘的時候就破台了\n（那時候師大還沒有破台）\n那時候我跟師大的 penalty 差 67\n也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了\n。。。然後師大只吃 66\n80 抽抽不到術師匠的非洲酋長正常發揮QQ\n\n下一次沒意外就會去打 PTC 了\n不過是英文題目\n我覺得我會扛不起來\n在此誠徵英文好的選手一名\n工作：只要幫我翻譯題目就好\n\n然後這一篇的題解我居然寫了 330 行\n喔，這行就 331 了 = =\n雖然看起來很多不過大部分都是 code 就是了","slug":"itsa-66","published":1,"updated":"2020-05-03T11:24:07.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsy000uxl9pc6w79928","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>簡單來說就是我特殊選才的資料不夠<br>所以只好來打這東西，不然備審有夠空QQ</p><a id=\"more\"></a><h2 id=\"problem-1\"><a class=\"header-anchor\" href=\"#problem-1\"></a>problem 1</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>這題就是給你一行整數（數量不定，但是保證 &lt; 11個）<br>求該行出現率「超過」一半的整數</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>看到數量不定就會用 getline + stringstream，這很直觀<br>然後因為他只有說「給整數」，並沒有限制數字大小<br>所以我是用 map 做，而不是陣列（出現負數就尷尬了）<br>雖然比較慢但是也比較無腦</p><p>為什麼我會在題目那把「超過」加上引號？<br>。。。因為我在寫 code 的時候耍智障把判斷式寫成 &gt;=<br>然後我就吃 WA 了<br>我還跑去問如果有多組解怎麼辦<br>結果超過一半的數字只會有一個QQ<br>還有把 NO 打成 No<br>就多吃兩個 penalty 了，虧爆<br>抓到，澪人桐不會寫程式</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> in, cnt;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( getline ( <span class=\"built_in\">cin</span>, str ) )&#123;</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ans = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span> <span class=\"params\">( str )</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( ss &gt;&gt; in )&#123;</span><br><span class=\"line\">            lib[in]++;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: lib )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i.S &gt; cnt / <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; i.F &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">                ans = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !ans )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NO\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-2\"><a class=\"header-anchor\" href=\"#problem-2\"></a>problem 2</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給一個簡單的一元一次方程式<br>保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除<br>並保證所有運算元與運算子之間只都有空白隔開<br>並且求出 $x$，無條件捨去到小數點第一位</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>要寫字串判斷很麻煩欸 = =<br>pA寫爆了先來寫這題（？<br>手速不知道為什麼爆快<br>快到我自己也嚇到<br>也沒出什麼 bug，很快就 AC 了 &lt;3</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> str;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> opt, len, x, a, b, ans;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( getline ( <span class=\"built_in\">cin</span>, str ) )&#123;</span><br><span class=\"line\">        len = str.size(), x = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'+'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'-'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'*'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'/'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( <span class=\"string\">'0'</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class=\"string\">'9'</span> )&#123;</span><br><span class=\"line\">                    x = x * <span class=\"number\">10</span> + <span class=\"keyword\">int</span> ( str[i] - <span class=\"string\">'0'</span> );</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( flag )</span><br><span class=\"line\">                        lib.pb ( x );</span><br><span class=\"line\">                    x = <span class=\"number\">0</span>, flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( flag )</span><br><span class=\"line\">            lib.pb ( x );</span><br><span class=\"line\">        a = lib[<span class=\"number\">0</span>], b = lib[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !opt )</span><br><span class=\"line\">            ans = ( b - a ) * <span class=\"number\">10.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( opt == <span class=\"number\">1</span> )</span><br><span class=\"line\">            ans = ( b + a ) * <span class=\"number\">10.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( opt == <span class=\"number\">2</span> )</span><br><span class=\"line\">            ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) b / a * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( str[<span class=\"number\">0</span>] == <span class=\"string\">'x'</span> )</span><br><span class=\"line\">                ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) b * a * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) a / b * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans / <span class=\"number\">10</span> &lt;&lt; <span class=\"string\">'.'</span> &lt;&lt; ans % <span class=\"number\">10</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-3\"><a class=\"header-anchor\" href=\"#problem-3\"></a>problem 3</h2><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定 $N$ 組字串，請將字串以 $’:’ or ‘;’ or ‘,’$ 切割<br>並輸出出所有字串</p><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><p>啊就水題水到爆啊，多開個 string 紀錄就好了<br>這題沒有難度（蓋章</p><h3 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str, swp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    getline ( <span class=\"built_in\">cin</span>, str );</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        getline ( <span class=\"built_in\">cin</span>, str );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Tokens found:\\n\"</span>;</span><br><span class=\"line\">        swp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i == <span class=\"string\">':'</span> || i == <span class=\"string\">','</span> || i == <span class=\"string\">';'</span> )&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; swp &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">                swp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                swp += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( swp != <span class=\"string\">\"\"</span> )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; swp &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-4\"><a class=\"header-anchor\" href=\"#problem-4\"></a>problem 4</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>zj 上面的是羅馬數字轉阿拉伯數字<br>這次 ITSA 出的是要把阿拉伯數字轉羅馬數字<br>更水 = =</p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>直接按照位數打表輸出就好<br>。。。雖然這麼說，但是我還是出 bug 了<br>我把4打成&quot;IIII&quot;，正確應該是&quot;IX&quot;<br>垃圾是我QQ</p><h3 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by.MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> lib0[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> lib1[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> lib2[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, in;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; lib2[in / <span class=\"number\">100</span>] &lt;&lt; lib1[in % <span class=\"number\">100</span> / <span class=\"number\">10</span>] &lt;&lt; lib0[in % <span class=\"number\">10</span>] &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-5\"><a class=\"header-anchor\" href=\"#problem-5\"></a>problem 5</h2><h3 id=\"題目-v5\"><a class=\"header-anchor\" href=\"#題目-v5\"></a>題目</h3><p>給定兩個字串，求出這兩個字串所有的 LCS</p><h3 id=\"解法-v5\"><a class=\"header-anchor\" href=\"#解法-v5\"></a>解法</h3><p>本來只有丟任意解的 LCS<br>然後就吃 WA 了，又多一個 penalty<br>問官方官方一直沒有回應<br>就想說先寫所有解的版本好了<br>等到一回覆馬上 judge</p><p>然後這就是裸的 LCS 啊 = =</p><h3 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">105</span>][<span class=\"number\">105</span>], ma;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a, b, str;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"built_in\">string</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> szA = a.size(), szB = b.size();</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> dp );</span><br><span class=\"line\">        ma = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( a[i] == b[j] )&#123;</span><br><span class=\"line\">                    dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    ma = max ( ma, dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !ma )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No common sequence!\\n\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] == ma )&#123;</span><br><span class=\"line\">                    str = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> k = i - ma + <span class=\"number\">1</span> ; k &lt;= i ; k++ )</span><br><span class=\"line\">                        str += a[k];</span><br><span class=\"line\">                    lib.insert ( str );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: lib )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>在第 37 分鐘的時候就破台了<br>（那時候師大還沒有破台）<br>那時候我跟師大的 penalty 差 67<br>也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了<br>。。。然後師大只吃 66<br>80 抽抽不到術師匠的非洲酋長正常發揮QQ</p><p>下一次沒意外就會去打 PTC 了<br>不過是英文題目<br>我覺得我會扛不起來<br>在此誠徵英文好的選手一名<br>工作：只要幫我翻譯題目就好</p><p>然後這一篇的題解我居然寫了 330 行<br>喔，這行就 331 了 = =<br>雖然看起來很多不過大部分都是 code 就是了</p><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>簡單來說就是我特殊選才的資料不夠<br>所以只好來打這東西，不然備審有夠空QQ</p>","more":"<h2 id=\"problem-1\"><a class=\"header-anchor\" href=\"#problem-1\"></a>problem 1</h2><h3 id=\"題目\"><a class=\"header-anchor\" href=\"#題目\"></a>題目</h3><p>這題就是給你一行整數（數量不定，但是保證 &lt; 11個）<br>求該行出現率「超過」一半的整數</p><h3 id=\"解法\"><a class=\"header-anchor\" href=\"#解法\"></a>解法</h3><p>看到數量不定就會用 getline + stringstream，這很直觀<br>然後因為他只有說「給整數」，並沒有限制數字大小<br>所以我是用 map 做，而不是陣列（出現負數就尷尬了）<br>雖然比較慢但是也比較無腦</p><p>為什麼我會在題目那把「超過」加上引號？<br>。。。因為我在寫 code 的時候耍智障把判斷式寫成 &gt;=<br>然後我就吃 WA 了<br>我還跑去問如果有多組解怎麼辦<br>結果超過一半的數字只會有一個QQ<br>還有把 NO 打成 No<br>就多吃兩個 penalty 了，虧爆<br>抓到，澪人桐不會寫程式</p><h3 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> in, cnt;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( getline ( <span class=\"built_in\">cin</span>, str ) )&#123;</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ans = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">stringstream</span> <span class=\"title\">ss</span> <span class=\"params\">( str )</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( ss &gt;&gt; in )&#123;</span><br><span class=\"line\">            lib[in]++;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: lib )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i.S &gt; cnt / <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; i.F &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">                ans = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !ans )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"NO\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-2\"><a class=\"header-anchor\" href=\"#problem-2\"></a>problem 2</h2><h3 id=\"題目-v2\"><a class=\"header-anchor\" href=\"#題目-v2\"></a>題目</h3><p>給一個簡單的一元一次方程式<br>保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除<br>並保證所有運算元與運算子之間只都有空白隔開<br>並且求出 $x$，無條件捨去到小數點第一位</p><h3 id=\"解法-v2\"><a class=\"header-anchor\" href=\"#解法-v2\"></a>解法</h3><p>要寫字串判斷很麻煩欸 = =<br>pA寫爆了先來寫這題（？<br>手速不知道為什麼爆快<br>快到我自己也嚇到<br>也沒出什麼 bug，很快就 AC 了 &lt;3</p><h3 id=\"code-v2\"><a class=\"header-anchor\" href=\"#code-v2\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pb push_back</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> str;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt; <span class=\"keyword\">int</span> &gt; lib;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> opt, len, x, a, b, ans;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( getline ( <span class=\"built_in\">cin</span>, str ) )&#123;</span><br><span class=\"line\">        len = str.size(), x = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'+'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'-'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'*'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( str[i] == <span class=\"string\">'/'</span> )</span><br><span class=\"line\">                opt = <span class=\"number\">3</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( <span class=\"string\">'0'</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class=\"string\">'9'</span> )&#123;</span><br><span class=\"line\">                    x = x * <span class=\"number\">10</span> + <span class=\"keyword\">int</span> ( str[i] - <span class=\"string\">'0'</span> );</span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ( flag )</span><br><span class=\"line\">                        lib.pb ( x );</span><br><span class=\"line\">                    x = <span class=\"number\">0</span>, flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( flag )</span><br><span class=\"line\">            lib.pb ( x );</span><br><span class=\"line\">        a = lib[<span class=\"number\">0</span>], b = lib[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !opt )</span><br><span class=\"line\">            ans = ( b - a ) * <span class=\"number\">10.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( opt == <span class=\"number\">1</span> )</span><br><span class=\"line\">            ans = ( b + a ) * <span class=\"number\">10.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( opt == <span class=\"number\">2</span> )</span><br><span class=\"line\">            ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) b / a * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( str[<span class=\"number\">0</span>] == <span class=\"string\">'x'</span> )</span><br><span class=\"line\">                ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) b * a * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                ans = ( <span class=\"keyword\">int</span> ) ( ( <span class=\"keyword\">double</span> ) a / b * <span class=\"number\">10.0</span> );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans / <span class=\"number\">10</span> &lt;&lt; <span class=\"string\">'.'</span> &lt;&lt; ans % <span class=\"number\">10</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-3\"><a class=\"header-anchor\" href=\"#problem-3\"></a>problem 3</h2><h3 id=\"題目-v3\"><a class=\"header-anchor\" href=\"#題目-v3\"></a>題目</h3><p>給定 $N$ 組字串，請將字串以 $’:’ or ‘;’ or ‘,’$ 切割<br>並輸出出所有字串</p><h3 id=\"解法-v3\"><a class=\"header-anchor\" href=\"#解法-v3\"></a>解法</h3><p>啊就水題水到爆啊，多開個 string 紀錄就好了<br>這題沒有難度（蓋章</p><h3 id=\"code-v3\"><a class=\"header-anchor\" href=\"#code-v3\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str, swp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    getline ( <span class=\"built_in\">cin</span>, str );</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        getline ( <span class=\"built_in\">cin</span>, str );</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Tokens found:\\n\"</span>;</span><br><span class=\"line\">        swp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: str )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i == <span class=\"string\">':'</span> || i == <span class=\"string\">','</span> || i == <span class=\"string\">';'</span> )&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; swp &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">                swp = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                swp += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( swp != <span class=\"string\">\"\"</span> )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; swp &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-4\"><a class=\"header-anchor\" href=\"#problem-4\"></a>problem 4</h2><h3 id=\"題目-v4\"><a class=\"header-anchor\" href=\"#題目-v4\"></a>題目</h3><p>zj 上面的是羅馬數字轉阿拉伯數字<br>這次 ITSA 出的是要把阿拉伯數字轉羅馬數字<br>更水 = =</p><h3 id=\"解法-v4\"><a class=\"header-anchor\" href=\"#解法-v4\"></a>解法</h3><p>直接按照位數打表輸出就好<br>。。。雖然這麼說，但是我還是出 bug 了<br>我把4打成&quot;IIII&quot;，正確應該是&quot;IX&quot;<br>垃圾是我QQ</p><h3 id=\"code-v4\"><a class=\"header-anchor\" href=\"#code-v4\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by.MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> lib0[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"I\"</span>, <span class=\"string\">\"II\"</span>, <span class=\"string\">\"III\"</span>, <span class=\"string\">\"IV\"</span>, <span class=\"string\">\"V\"</span>, <span class=\"string\">\"VI\"</span>, <span class=\"string\">\"VII\"</span>, <span class=\"string\">\"VIII\"</span>, <span class=\"string\">\"IX\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> lib1[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"X\"</span>, <span class=\"string\">\"XX\"</span>, <span class=\"string\">\"XXX\"</span>, <span class=\"string\">\"XL\"</span>, <span class=\"string\">\"L\"</span>, <span class=\"string\">\"LX\"</span>, <span class=\"string\">\"LXX\"</span>, <span class=\"string\">\"LXXX\"</span>, <span class=\"string\">\"XC\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">string</span> lib2[<span class=\"number\">10</span>] = &#123; <span class=\"string\">\"\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"CC\"</span>, <span class=\"string\">\"CCC\"</span>, <span class=\"string\">\"CD\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"DC\"</span>, <span class=\"string\">\"DCC\"</span>, <span class=\"string\">\"DCCC\"</span>, <span class=\"string\">\"CM\"</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t, in;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; lib2[in / <span class=\"number\">100</span>] &lt;&lt; lib1[in % <span class=\"number\">100</span> / <span class=\"number\">10</span>] &lt;&lt; lib0[in % <span class=\"number\">10</span>] &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"problem-5\"><a class=\"header-anchor\" href=\"#problem-5\"></a>problem 5</h2><h3 id=\"題目-v5\"><a class=\"header-anchor\" href=\"#題目-v5\"></a>題目</h3><p>給定兩個字串，求出這兩個字串所有的 LCS</p><h3 id=\"解法-v5\"><a class=\"header-anchor\" href=\"#解法-v5\"></a>解法</h3><p>本來只有丟任意解的 LCS<br>然後就吃 WA 了，又多一個 penalty<br>問官方官方一直沒有回應<br>就想說先寫所有解的版本好了<br>等到一回覆馬上 judge</p><p>然後這就是裸的 LCS 啊 = =</p><h3 id=\"code-v5\"><a class=\"header-anchor\" href=\"#code-v5\"></a>code</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[<span class=\"number\">105</span>][<span class=\"number\">105</span>], ma;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> a, b, str;</span><br><span class=\"line\">    <span class=\"built_in\">set</span> &lt; <span class=\"built_in\">string</span> &gt; lib;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"built_in\">cin</span> &gt;&gt; a &gt;&gt; b )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> szA = a.size(), szB = b.size();</span><br><span class=\"line\">        lib.clear();</span><br><span class=\"line\">        <span class=\"built_in\">memset</span> ( dp, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span> dp );</span><br><span class=\"line\">        ma = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( a[i] == b[j] )&#123;</span><br><span class=\"line\">                    dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = dp[i][j] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    ma = max ( ma, dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !ma )&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No common sequence!\\n\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; szA ; i++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> j = <span class=\"number\">0</span> ; j &lt; szB ; j++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( dp[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] == ma )&#123;</span><br><span class=\"line\">                    str = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> k = i - ma + <span class=\"number\">1</span> ; k &lt;= i ; k++ )</span><br><span class=\"line\">                        str += a[k];</span><br><span class=\"line\">                    lib.insert ( str );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> i: lib )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>在第 37 分鐘的時候就破台了<br>（那時候師大還沒有破台）<br>那時候我跟師大的 penalty 差 67<br>也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了<br>。。。然後師大只吃 66<br>80 抽抽不到術師匠的非洲酋長正常發揮QQ</p><p>下一次沒意外就會去打 PTC 了<br>不過是英文題目<br>我覺得我會扛不起來<br>在此誠徵英文好的選手一名<br>工作：只要幫我翻譯題目就好</p><p>然後這一篇的題解我居然寫了 330 行<br>喔，這行就 331 了 = =<br>雖然看起來很多不過大部分都是 code 就是了</p><!-- rebuild by neat -->"},{"title":"進階資料結構 for NCKU-ICPC Week 9","date":"2020-05-02T09:54:39.000Z","password":"maiismywife","_content":"\n# Week 9 DLC\n\n## 前言\n\n有些內容筆者本來想要放在這週的授課內容中\n不過一來是筆者的期中快要爆炸，沒有空做簡報\n另一方面由於授課內容偏難，放在影片中可能會讓影片長度暴增（像是變成三個小時）\n因此決定另外寫一篇文章來當作補充內容，並且發在自己的部落格\n\n<!--more-->\n\n## 線段樹 Extra\n\n### 持久化\n\n#### 老樣子開始前先看個題目\n\n> 給定一個長度為 $N$ 的序列，並且有 $M$ 條指令，指令內容如下\n>\n> 1. 修改其中一個元素的值\n> 2. 查詢查詢區間 $[l, r]$ 內的最大值\n> 3. 回復到第 k 次修改後的狀態\n>\n> $N, M \\le 10 ^ 5, k \\le$ 當前修改次數, $0 \\le l, r \\lt N$\n\n1, 2 都還是基本的線段樹，那麼 3 呢\n\n感覺可以每修改一次就開一顆新的線段樹，要回朔就複製回去\n\n所以需要開到 $M$ 棵線段樹，所以要開 $4NM$ 的記憶體......先 MLE 了\n再看一下時間複雜度：$O(M(N + \\log N))$ （先複製一遍 $O(N)$，再做單點修改 $O(\\log N)$，最糟糕要執行 $M$ 次）\n從各種方面來看感覺都不會過\n\n#### 先觀察一下\n\n對於每次修改，會修改到的地方只有從根節點到要修改的點的路徑而已\n也就是說 **其他節點沿用舊的資料也沒關係**\n\n> 這邊記得放結構圖\n\n但是用陣列寫就要另外維護節點編號，從實作上來說是幾乎不可能達成的事\n看來我們需要換個想法\n\n#### Hmmm，指標？\n\n沒錯，就是指標\n只要紀錄記憶體位置就好，不用把整個 node 都複製過去\n\n所以現在線段樹要改成指標版本\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n\tnode *l, *r;\n\tint value;\n\n\tnode ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) {}\n\n\tinline void up ( void ){\n\t\tvalue = -1;\n\t\tif ( l )\n\t\t\tvalue = max ( value, l -> value );\n\t\tif ( r )\n\t\t\tvalue = max ( value, r -> value );\n\t}\n} *seg = nullptr;\n\nvoid build ( int l, int r, node *&o ){\n\to = new node ( 0 );\n\tif ( l == r )\n\t\treturn;\n\tint mid = ( l + r ) >> 1;\n\tbuild ( l, mid, o -> l );\n\tbuild ( mid + 1, r, o -> r );\n\n\to -> up();\n}\n\nvoid update ( int l, int r, int index, int value, node *&o ){\n\tif ( l == r )\n\t\to -> value = value;\n\telse{\n\t\tint mid = ( l + r ) >> 1;\n\t\tif ( index <= mid )\n\t\t\tupdate ( l, mid, index, value, o -> l );\n\t\telse\n\t\t\tupdate ( mid + 1, r, index, value, o -> r );\n\n\t\to -> up();\n\t}\n}\n\nint query ( int l, int r, int nowL, int nowR, node *o ){\n\tif ( l <= nowR && nowR <= r )\n\t\treturn o -> value;\n\tint mid = ( nowL + nowR ) >> 1;\n\tif ( r <= mid )\n\t\treturn query ( l, r, nowL, mid, o -> l );\n\tif ( mid < l )\n\t\treturn query ( l, r, mid + 1, nowR, o -> r );\n\n\treturn max ( query ( l, r, nowL, mid, o -> l ), query ( l, r, mid + 1, nowR, o -> r ) );\n}\n\nint main(){\n\tios::sync_with_stdio ( false );\n\tcin.tie ( 0 );\n\tcout.tie ( 0 );\n\n\tint n, m, l, r, in, type;\n\tcin >> n >> m;\n\tbuild ( 1, n, seg );\n\tfor ( int i = 1 ; i <= n ; i++ ){\n\t\tcin >> in;\n\t\tupdate ( 1, n, i, in, seg );\n\t}\n\n\t// type 1: 單點修改\n\t// type 2: 區間查詢最大值\n\twhile ( m-- ){\n\t\tcin >> type;\n\t\tif ( type == 1 ){\n\t\t\tcin >> l >> in;\n\t\t\tupdate ( 1, n, l, in, seg );\n\t\t}\n\t\telse if ( type == 2 ){\n\t\t\tcin >> l >> r;\n\t\t\tcout << query ( l, r, 1, n, seg ) << '\\n';\n\t\t}\n\t}\n}\n```\n\n#### 持久化\n\n因為要保留舊版本，所以對所有需要被修改的節點新開一個位置來\n並且把左右子結點的指標，指向原本左右子結點的位置\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n\tnode *l, *r;\n\tint value;\n\n\tnode ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) {}\n\t// 新增一個建構子，可以直接複製原本的 l, r\n\tnode ( node *o ): l ( o -> l ), r ( o -> r ), value ( o -> value ) {}\n\n\tinline void up ( void ){\n\t\tvalue = -1;\n\t\tif ( l )\n\t\t\tvalue = max ( value, l -> value );\n\t\tif ( r )\n\t\t\tvalue = max ( value, r -> value );\n\t}\n} *seg = nullptr;\n\nvoid build ( int l, int r, node *&o ){\n\to = new node ( 0 );\n\tif ( l == r )\n\t\treturn;\n\tint mid = ( l + r ) >> 1;\n\tbuild ( l, mid, o -> l );\n\tbuild ( mid + 1, r, o -> r );\n\n\to -> up();\n}\n\nvoid update ( int l, int r, int index, int value, node *&o ){\n\t// 把需要修改的節點在修改前先開一個新位置出來\n\to = new node ( o );\n\tif ( l == r )\n\t\to -> value = value;\n\telse{\n\t\tint mid = ( l + r ) >> 1;\n\t\tif ( index <= mid )\n\t\t\tupdate ( l, mid, index, value, o -> l );\n\t\telse\n\t\t\tupdate ( mid + 1, r, index, value, o -> r );\n\n\t\to -> up();\n\t}\n}\n\nint query ( int l, int r, int nowL, int nowR, node *o ){\n\tif ( l <= nowR && nowR <= r )\n\t\treturn o -> value;\n\tint mid = ( nowL + nowR ) >> 1;\n\tif ( r <= mid )\n\t\treturn query ( l, r, nowL, mid, o -> l );\n\tif ( mid < l )\n\t\treturn query ( l, r, mid + 1, nowR, o -> r );\n\n\treturn max ( query ( l, r, nowL, mid, o -> l ), query ( l, r, mid + 1, nowR, o -> r ) );\n}\n\nint main(){\n\tios::sync_with_stdio ( false );\n\tcin.tie ( 0 );\n\tcout.tie ( 0 );\n\n\tint n, m, l, r, in, type;\n    // 紀錄版本用的 vector\n\tvector < node* > version;\n\tcin >> n >> m;\n\tbuild ( 1, n, seg );\n\tfor ( int i = 1 ; i <= n ; i++ ){\n\t\tcin >> in;\n\t\tupdate ( 1, n, i, in, seg );\n\t}\n\t// 記錄初始版本\n\tversion.push_back ( seg );\n\n\t// type 1: 單點修改\n\t// type 2: 區間查詢最大值\n\t// type 3: 回朔到版本 k\n\twhile ( m-- ){\n\t\tcin >> type;\n\t\tif ( type == 1 ){\n\t\t\tcin >> l >> in;\n\t\t\tupdate ( 1, n, l, in, seg );\n\t\t\t// 修改完紀錄版本\n\t\t\tversion.push_back ( seg );\n\t\t}\n\t\telse if ( type == 2 ){\n\t\t\tcin >> l >> r;\n\t\t\tcout << query ( l, r, 1, n, seg ) << '\\n';\n\t\t}\n\t\telse{\n\t\t\t// 回朔到版本 k\n\t\t\tcin >> in;\n\t\t\tseg = version[in];\n\t\t}\n\t}\n}\n```\n\n##### 有修改過的地方\n\n| line   | 修改內容                                |\n| ------ | --------------------------------------- |\n| 12     | 新增一個建構子，可以直接複製原本的 l, r |\n| 36     | 在對節點修改前先開一個新的位置          |\n| 69     | 記錄用的 vector                         |\n| 77, 88 | 修改完成後，記錄當前版本內容            |\n| 94     | 新增一個操作，可回朔到版本 k            |\n\n### 非簡單操作線段樹\n\n#### 我們還是看個題目\n\n> 現在給定一個長度為 $N$ 序列，以及 $M$ 筆操作，操作內容有\n>\n> 1. 修改一個元素的值\n> 2. 查詢區間中最長的「好序列」長度\n>\n> 定義一個「好區間」為：每個元素都是前一個元素 + 1\n>\n> 這邊是一個題目叫大龍貓的濃縮版，完整版題目可以看 [這邊](http://toj.tfcis.org/oj/pro/365/)\n\n現在有點麻煩了，RMQ 我們會，但是這種該怎麼用線段樹實作\n\n我們可以在 node 中紀錄目前最長的好序列長度，以及其開始位置以及結束位置\n每次合併兩個區間就取兩邊紀錄的最長好序列的最大值\n\nEmmm，但是感覺好像怪怪的\n如果合併兩個區間後，交界處那邊形成一個更長的好序列，怎麼辦？\n\n尷尬，那我們只好在每個 node 也記錄從開頭處到結束處的好序列了\n\n聽起來很複雜，但是其實一點也不\n\n為了方便編寫，我們先定義一個 piece，還有如何辨識兩個 piece 是否相同\n\n```cpp\nstruct piece{\n\tint l, r, sz;\n\n\t// 檢查兩個 piece 是否相同\n\tbool operator == ( const piece b ){\n\t\treturn l == b.l && r == b.r;\n\t}\n};\n\n// 不想寫 operator（或是覺得太麻煩）可以這樣寫\ninline bool same ( piece a, piece b ){\n\treturn a.l == b.l && a.r == b.r;\n}\n```\n\n$l, r$ 就是這個區間的左右界\n$sz$ 是大小，可有可無，只是寫 code 上方便\n\n然後是 node\n\n```cpp\nstruct node{\n    piece front, back, ma;\n};\n```\n\n$front, back$ 分別為是記錄當前線段樹區間內，從左邊界開始的好序列長度，以及從右邊屆開始的好序列長度\n$ma$ 則是記錄當前線段樹區間內，最長的好序列長度\n\n接著來寫合併兩個區間的函數吧，因為沒有內建的函數可以用，只能自己寫一下\n\n```cpp\ninline node merge ( node L, node R ){\n    node res;\n\tres.front = L.front, res.back = R.back, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\n\n\tif ( basic[L.back.r] + 1 == basic[R.front.l] ){\n\t\tpiece swp = piece { L.back.l, R.front.r, R.front.r - L.back.l + 1 };\n\n\t\tif ( L.front == L.back )\n\t\t\tres.front = swp;\n\t\tif ( R.front == R.back )\n\t\t\tres.back = swp;\n\n\t\tres.ma = ( swp.sz > res.ma.sz ? swp : res.ma );\n\t}\n\n\treturn res;\n}\n```\n\n合併兩個區間後，要回傳的 res 內容如下\n\n| res 內的 piece | 來源                                             |\n| -------------- | ------------------------------------------------ |\n| front          | l.front                                          |\n| back           | r.back                                           |\n| ma             | l.ma, r.ma, l.back + r.back 這三者中的最長好序列 |\n\n\n\n\n\n## 後記\n\n這篇文章寫的也挺久的，主要是文中的內容大部分都不常用到，在寫的時候還跑去翻了一些文章\n\n正因如此，內容上可能有些錯誤，如有發現，請聯絡 [筆者](https://miohitokiri5474.github.io/code/about/)","source":"_posts/ncku-icpc-2020-week9-dlc.md","raw":"---\ntitle: '進階資料結構 for NCKU-ICPC Week 9'\ndate: 2020-05-02 17:54:39\ntags:\n - Data Structure\n - Segment Tree\npassword: maiismywife\n\n---\n\n# Week 9 DLC\n\n## 前言\n\n有些內容筆者本來想要放在這週的授課內容中\n不過一來是筆者的期中快要爆炸，沒有空做簡報\n另一方面由於授課內容偏難，放在影片中可能會讓影片長度暴增（像是變成三個小時）\n因此決定另外寫一篇文章來當作補充內容，並且發在自己的部落格\n\n<!--more-->\n\n## 線段樹 Extra\n\n### 持久化\n\n#### 老樣子開始前先看個題目\n\n> 給定一個長度為 $N$ 的序列，並且有 $M$ 條指令，指令內容如下\n>\n> 1. 修改其中一個元素的值\n> 2. 查詢查詢區間 $[l, r]$ 內的最大值\n> 3. 回復到第 k 次修改後的狀態\n>\n> $N, M \\le 10 ^ 5, k \\le$ 當前修改次數, $0 \\le l, r \\lt N$\n\n1, 2 都還是基本的線段樹，那麼 3 呢\n\n感覺可以每修改一次就開一顆新的線段樹，要回朔就複製回去\n\n所以需要開到 $M$ 棵線段樹，所以要開 $4NM$ 的記憶體......先 MLE 了\n再看一下時間複雜度：$O(M(N + \\log N))$ （先複製一遍 $O(N)$，再做單點修改 $O(\\log N)$，最糟糕要執行 $M$ 次）\n從各種方面來看感覺都不會過\n\n#### 先觀察一下\n\n對於每次修改，會修改到的地方只有從根節點到要修改的點的路徑而已\n也就是說 **其他節點沿用舊的資料也沒關係**\n\n> 這邊記得放結構圖\n\n但是用陣列寫就要另外維護節點編號，從實作上來說是幾乎不可能達成的事\n看來我們需要換個想法\n\n#### Hmmm，指標？\n\n沒錯，就是指標\n只要紀錄記憶體位置就好，不用把整個 node 都複製過去\n\n所以現在線段樹要改成指標版本\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n\tnode *l, *r;\n\tint value;\n\n\tnode ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) {}\n\n\tinline void up ( void ){\n\t\tvalue = -1;\n\t\tif ( l )\n\t\t\tvalue = max ( value, l -> value );\n\t\tif ( r )\n\t\t\tvalue = max ( value, r -> value );\n\t}\n} *seg = nullptr;\n\nvoid build ( int l, int r, node *&o ){\n\to = new node ( 0 );\n\tif ( l == r )\n\t\treturn;\n\tint mid = ( l + r ) >> 1;\n\tbuild ( l, mid, o -> l );\n\tbuild ( mid + 1, r, o -> r );\n\n\to -> up();\n}\n\nvoid update ( int l, int r, int index, int value, node *&o ){\n\tif ( l == r )\n\t\to -> value = value;\n\telse{\n\t\tint mid = ( l + r ) >> 1;\n\t\tif ( index <= mid )\n\t\t\tupdate ( l, mid, index, value, o -> l );\n\t\telse\n\t\t\tupdate ( mid + 1, r, index, value, o -> r );\n\n\t\to -> up();\n\t}\n}\n\nint query ( int l, int r, int nowL, int nowR, node *o ){\n\tif ( l <= nowR && nowR <= r )\n\t\treturn o -> value;\n\tint mid = ( nowL + nowR ) >> 1;\n\tif ( r <= mid )\n\t\treturn query ( l, r, nowL, mid, o -> l );\n\tif ( mid < l )\n\t\treturn query ( l, r, mid + 1, nowR, o -> r );\n\n\treturn max ( query ( l, r, nowL, mid, o -> l ), query ( l, r, mid + 1, nowR, o -> r ) );\n}\n\nint main(){\n\tios::sync_with_stdio ( false );\n\tcin.tie ( 0 );\n\tcout.tie ( 0 );\n\n\tint n, m, l, r, in, type;\n\tcin >> n >> m;\n\tbuild ( 1, n, seg );\n\tfor ( int i = 1 ; i <= n ; i++ ){\n\t\tcin >> in;\n\t\tupdate ( 1, n, i, in, seg );\n\t}\n\n\t// type 1: 單點修改\n\t// type 2: 區間查詢最大值\n\twhile ( m-- ){\n\t\tcin >> type;\n\t\tif ( type == 1 ){\n\t\t\tcin >> l >> in;\n\t\t\tupdate ( 1, n, l, in, seg );\n\t\t}\n\t\telse if ( type == 2 ){\n\t\t\tcin >> l >> r;\n\t\t\tcout << query ( l, r, 1, n, seg ) << '\\n';\n\t\t}\n\t}\n}\n```\n\n#### 持久化\n\n因為要保留舊版本，所以對所有需要被修改的節點新開一個位置來\n並且把左右子結點的指標，指向原本左右子結點的位置\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node{\n\tnode *l, *r;\n\tint value;\n\n\tnode ( int _val ): l ( nullptr ), r ( nullptr ), value ( _val ) {}\n\t// 新增一個建構子，可以直接複製原本的 l, r\n\tnode ( node *o ): l ( o -> l ), r ( o -> r ), value ( o -> value ) {}\n\n\tinline void up ( void ){\n\t\tvalue = -1;\n\t\tif ( l )\n\t\t\tvalue = max ( value, l -> value );\n\t\tif ( r )\n\t\t\tvalue = max ( value, r -> value );\n\t}\n} *seg = nullptr;\n\nvoid build ( int l, int r, node *&o ){\n\to = new node ( 0 );\n\tif ( l == r )\n\t\treturn;\n\tint mid = ( l + r ) >> 1;\n\tbuild ( l, mid, o -> l );\n\tbuild ( mid + 1, r, o -> r );\n\n\to -> up();\n}\n\nvoid update ( int l, int r, int index, int value, node *&o ){\n\t// 把需要修改的節點在修改前先開一個新位置出來\n\to = new node ( o );\n\tif ( l == r )\n\t\to -> value = value;\n\telse{\n\t\tint mid = ( l + r ) >> 1;\n\t\tif ( index <= mid )\n\t\t\tupdate ( l, mid, index, value, o -> l );\n\t\telse\n\t\t\tupdate ( mid + 1, r, index, value, o -> r );\n\n\t\to -> up();\n\t}\n}\n\nint query ( int l, int r, int nowL, int nowR, node *o ){\n\tif ( l <= nowR && nowR <= r )\n\t\treturn o -> value;\n\tint mid = ( nowL + nowR ) >> 1;\n\tif ( r <= mid )\n\t\treturn query ( l, r, nowL, mid, o -> l );\n\tif ( mid < l )\n\t\treturn query ( l, r, mid + 1, nowR, o -> r );\n\n\treturn max ( query ( l, r, nowL, mid, o -> l ), query ( l, r, mid + 1, nowR, o -> r ) );\n}\n\nint main(){\n\tios::sync_with_stdio ( false );\n\tcin.tie ( 0 );\n\tcout.tie ( 0 );\n\n\tint n, m, l, r, in, type;\n    // 紀錄版本用的 vector\n\tvector < node* > version;\n\tcin >> n >> m;\n\tbuild ( 1, n, seg );\n\tfor ( int i = 1 ; i <= n ; i++ ){\n\t\tcin >> in;\n\t\tupdate ( 1, n, i, in, seg );\n\t}\n\t// 記錄初始版本\n\tversion.push_back ( seg );\n\n\t// type 1: 單點修改\n\t// type 2: 區間查詢最大值\n\t// type 3: 回朔到版本 k\n\twhile ( m-- ){\n\t\tcin >> type;\n\t\tif ( type == 1 ){\n\t\t\tcin >> l >> in;\n\t\t\tupdate ( 1, n, l, in, seg );\n\t\t\t// 修改完紀錄版本\n\t\t\tversion.push_back ( seg );\n\t\t}\n\t\telse if ( type == 2 ){\n\t\t\tcin >> l >> r;\n\t\t\tcout << query ( l, r, 1, n, seg ) << '\\n';\n\t\t}\n\t\telse{\n\t\t\t// 回朔到版本 k\n\t\t\tcin >> in;\n\t\t\tseg = version[in];\n\t\t}\n\t}\n}\n```\n\n##### 有修改過的地方\n\n| line   | 修改內容                                |\n| ------ | --------------------------------------- |\n| 12     | 新增一個建構子，可以直接複製原本的 l, r |\n| 36     | 在對節點修改前先開一個新的位置          |\n| 69     | 記錄用的 vector                         |\n| 77, 88 | 修改完成後，記錄當前版本內容            |\n| 94     | 新增一個操作，可回朔到版本 k            |\n\n### 非簡單操作線段樹\n\n#### 我們還是看個題目\n\n> 現在給定一個長度為 $N$ 序列，以及 $M$ 筆操作，操作內容有\n>\n> 1. 修改一個元素的值\n> 2. 查詢區間中最長的「好序列」長度\n>\n> 定義一個「好區間」為：每個元素都是前一個元素 + 1\n>\n> 這邊是一個題目叫大龍貓的濃縮版，完整版題目可以看 [這邊](http://toj.tfcis.org/oj/pro/365/)\n\n現在有點麻煩了，RMQ 我們會，但是這種該怎麼用線段樹實作\n\n我們可以在 node 中紀錄目前最長的好序列長度，以及其開始位置以及結束位置\n每次合併兩個區間就取兩邊紀錄的最長好序列的最大值\n\nEmmm，但是感覺好像怪怪的\n如果合併兩個區間後，交界處那邊形成一個更長的好序列，怎麼辦？\n\n尷尬，那我們只好在每個 node 也記錄從開頭處到結束處的好序列了\n\n聽起來很複雜，但是其實一點也不\n\n為了方便編寫，我們先定義一個 piece，還有如何辨識兩個 piece 是否相同\n\n```cpp\nstruct piece{\n\tint l, r, sz;\n\n\t// 檢查兩個 piece 是否相同\n\tbool operator == ( const piece b ){\n\t\treturn l == b.l && r == b.r;\n\t}\n};\n\n// 不想寫 operator（或是覺得太麻煩）可以這樣寫\ninline bool same ( piece a, piece b ){\n\treturn a.l == b.l && a.r == b.r;\n}\n```\n\n$l, r$ 就是這個區間的左右界\n$sz$ 是大小，可有可無，只是寫 code 上方便\n\n然後是 node\n\n```cpp\nstruct node{\n    piece front, back, ma;\n};\n```\n\n$front, back$ 分別為是記錄當前線段樹區間內，從左邊界開始的好序列長度，以及從右邊屆開始的好序列長度\n$ma$ 則是記錄當前線段樹區間內，最長的好序列長度\n\n接著來寫合併兩個區間的函數吧，因為沒有內建的函數可以用，只能自己寫一下\n\n```cpp\ninline node merge ( node L, node R ){\n    node res;\n\tres.front = L.front, res.back = R.back, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );\n\n\tif ( basic[L.back.r] + 1 == basic[R.front.l] ){\n\t\tpiece swp = piece { L.back.l, R.front.r, R.front.r - L.back.l + 1 };\n\n\t\tif ( L.front == L.back )\n\t\t\tres.front = swp;\n\t\tif ( R.front == R.back )\n\t\t\tres.back = swp;\n\n\t\tres.ma = ( swp.sz > res.ma.sz ? swp : res.ma );\n\t}\n\n\treturn res;\n}\n```\n\n合併兩個區間後，要回傳的 res 內容如下\n\n| res 內的 piece | 來源                                             |\n| -------------- | ------------------------------------------------ |\n| front          | l.front                                          |\n| back           | r.back                                           |\n| ma             | l.ma, r.ma, l.back + r.back 這三者中的最長好序列 |\n\n\n\n\n\n## 後記\n\n這篇文章寫的也挺久的，主要是文中的內容大部分都不常用到，在寫的時候還跑去翻了一些文章\n\n正因如此，內容上可能有些錯誤，如有發現，請聯絡 [筆者](https://miohitokiri5474.github.io/code/about/)","slug":"ncku-icpc-2020-week9-dlc","published":1,"updated":"2020-05-03T11:24:07.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbcsz000wxl9p6nppdtvo","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">Hey, password is required here.</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"4f43e85fcd1b7347c7895b46fa552eac38aaa7ce1a3b68be42f26a1297b4f69d\">4f11c70cde93ad29e66f0be09f1124977d8d9743a8dc8aacfca075bef2885b79cf252e5b76ea3fdfed85390c2cf3516d21e71fdc64cff9405836d14cef877c488671280ede72d20087dfe86307046985f3b17a075d24aa5002e2424af773e78df4bff73eb7c9b5735329e74a8aced81cab26d2ce45634ff8742f30f94c43b11775fbcc8a261f4838b2e804db469c468b7961cd7ea01ebda753f5e316d914ee5e1a041e98e0c7f60d8465283c6191b4065140765009a6344e0c1e79f317f6bd6ded73607325db44cbc28a3bdaa0d6c9ae771f7fc663813ddc0533943d8caa8af223190db77b18808713b0fa1ae8f6d423bfe5059437e8278ad63cf9bd9af3d55c114e03a6e85c00a31f8a7ee12b5a4277101eb8105a81bf16f4f140d38949c6bba519635caa8a879ba57fab4ba37fe5f368edd0fbd9288536d8258306c8a1ce2aae15e3ee27ba3770b5ac26a79bb15cb8298cb3cf45153dc11a5126221235e07ac91f08314c3e5c73415ddcb74147a6193a00ba72a7c046c981b766b017d6151701472ff994062cceefcc4ecbd87f63d60fb3dd1034c2791b745efa256ddc01dd5fc5f898b34bf26a46efc06d9a92456ae4c61b092fc159facd9c49e765e4111affce7816159f1b9f0ce8abf41b7732292f7e6ad16882fb7bfc981ff3ba0cd041dd6b0b8df6e8a975bb5712a32d2e823857a62032f16d0055baa95f8d695565f65e0bb4bb97dd257f196b3aabe7568ebf445e4d268c04a5ecb277fb358716952e0f57f5fbdd80533b895a82f48f253ed912f8f43df8927791773f277c735fcdae7d7f9d17fdc49a5b74ee1c8fe8f57f6a55974c709533aa7b2629ddd23b71028fcd56c653fca821e0c3d0f765d8475290ff9786eef9a980cd0495abfd82621e15b859100a786820f8e9be603248d6a0fcf026b29aae00c279be62dc9e39737c08881e97af5888187fb8ce4c0fa43462d0627e39abc911cbaaeb271f5e75c713ecf376d45e947766b55be7c4935d332b340ce1e3c8a3292dd27b56b6a86e48ae7c0fbcff200d97de8a9d9777bb4c96a0bfece983f797af578ebd4df23248c9fdf9ebe972c619c926e2b1614bf000caa35ad2705f301cc8d5c3b5e701c94c1ab642f74f3ba5d6438ebd05b436caf4ae543fb8c8bdaade31c04ee3a46af0d46949872d6da03c0b516c40b4cacfa7e3f01094c2ff0a61c064422cc18e1da81a943e83fe81c5b5de31be8cdadb7d7d75d75727ca7a8c5ea2ad3a3ad5877199f2c4933dbafd4c0ce23381340895d5bd0ef2f4a3ddbbac521c63dfba6d72c6af0a504c9683b1c02e2b3cc8dad45187b79350bb8f1ac8f6a2fbbb278ac3d3d46b9cd287bfc86d7a346da4d1c2bd8699ca9acb87ebdbc4711b1a90c93cd16d98cc8d008c77bee0c5c78ef06a0e182becf579791209b8cbadd9080bb05d1def4338dfc5557534a86f0d21d6d56a69406a8e9ce8492467aebb283d2d9fd6f221299449a549f3e630cda33899c4124f5269dc8f9f19a633d90d3f052f3fda5ffa4d9e688bbc263c82399857835c335a0ea3db69acdaeb50fe0009a47fc9604ffe55eb7658de35f8ea305b30d2d23562fd48f4abdf9d1f3f9fa0a9579d1cbcb4460b3124f1400e0f1cde7875e49eda647c03866f257a6cf641eb4f2905bd5d7796bbbef0f77bcfdb6a0eef3aef7d94fdacb25ce141252030baba6a05633073b7dc7c81d3659f1c70aaa733f178fcb1dab16e33839365fd657d0d56e2d3bb3fe96ced87e824ce842b6146731196ba6d52906d4d94ccc11b5e60d389d2d50c08e3062b2fcf6928f8b3dda7799ee32293aedc014a4fe2e7190678814e88b1e1dc165b0ab2e6e333cea36b1d5a142ac3d29f4bb96abb763293eec260ea613833e7b6843213f9c67ca018269a5d4204acabe13259731b97b0d0dbb4a8f2cf16185a560f9fbcc29c2697451bd156377b727394b0420d161efb7f081992ee9b72dadd0b2449c2e5f1a62feca24a02fdb9234403128ec67ef251afce16d064baa7259dc524e8e3d41d135bab42f409e920b6bf923d10d79005e7cec7fde41486521cb7b358825224e39df46a31a053acace8e3df41d1f69647d1eaf8d09fbe4b1790beab5b0f82dfae19752917fa21a9ebacfb84a0964a323788aca8d209812dcf42adc8febab74a7196594b2fd9303262a3b7a1e4e12e582ab9ec4f76166b12580a139560447eb49efa8aba784b91df4bda2bd6c2511f21d92839111972b46143f21c3c4ad0b5f8dbe59a841feb5ec2420e027747d04b3c94a3ef3a77a041cb83dca1e5fe4849dc293584e33e69cacddd3dd498f1d2fbde0f06e22944934a1e29d62fdc617f73c420f69db2e81bfdf9fb90384e5073d5322e1cab6a7a2c54c304bfe36f757597e1155f44b6d7ea00e3a9098f4bfc347cbcfe4392c031e138b430de2257754332831dcd6bcb60bc558e0f6fb2adf5fe1cafc5d29b133f085a2a7cba3ac057a8bdf55e89c6221e845073142666e8b06e0ce4bab8ee27d4c131db17e642cfedcb2eaf90a79bb13d79d75f4a4e327a93cb1d4086869c2013e061be5f1fd063d4ced1139558865fd77a64676845b9babbf52d9b404c156016d47192fdff6bccdd1691a7badc63577390d55c2f9f5c44a18aef6d1210667dcca96b3cebceb9ac2e1cbac2fb66a376227d7ff9de3afda6244559ca3590057063407c08d22167ae8abbd409e1b82c4cbcee625fe425724f8914f9bb3b0f009d7d29771bc5a8206a62903fe09d0092dc15869e278c5b790d87b42561a9f3f1d10b4710dae535ac09c402cdcdade3f658ab4b78b21ea3b1c809d562e1becf64ccc824e47f648416991da807a2b6df8847acec0a7fc5496b1925be33d0ebe06c3956973172f97b049f48491329a96beaf96d4eab8d6065389474ee5fa96b6e6a752f47bfbc52f7dfff6248928bee246bd0cadf2b325e8a711b3098bd937545353b4cef81540c467766eccf4e2ff84a181f9d6c2a2b5ced7b55568e48eb4797d19cf349c830d0b55fb9a380144a3751f84354d79a13a5178a84d665256fc73729453d0cf7a50458756f86e8bd9829446f15d1a7ee417a0fd5a16077b30a48880ffd629a0c7b100a54cd2e3920dc8d0f6e0700e1316e1284a770c0aa2b3967e5a76fe358cf564d428b1213913835d98f8eea85de250d574ab1c7ab29213237d2a14406cbb9a2883ca99dfd652a4839c3152da5ba6b172e0a0fa8aff4755c452a6ada9568c3efba7fa4be49e4125e22f18bbf3d169c7b558b3f9bf5bea8bc1cb7fd54317f75d87dd716b5b12fd428378b4fa811d81b0ab4ad583a9836f4b40f85047fd856fe20852e38744d3db9d4c90ff2f1c4a053d94552efdda6c365f559d4e728107efc503427a2e6cce643e891b20813a900e3cb8c5154f1455d65f2ffd005e159f28c39252b6704910e61df6245ae8e6dd594bc7c190cef0772f8ad20fd1c0d6acb517b56a7fd3c36022af6dcf5dd16d59e2475a5abcf2c25dff799c1ceb96f8fb0eb7099a89486485da267a0a929cd21e39be932d428db87575c53b8a25ddff5f881b3e345e0e84db726dd36a8537f148c6060c8187ac66c58ba4de5b3c715b330a9f5f2933b30649f9d00c7eaa238a2e37d4ed029d78cabf23e9e585fc57afec92d7d752beac13707cf6bb96ec49115eb56c375ea7cc90ecced23d984730f53e5f21af1ee3e7835826ca09003aed9433f7710091e2a704b2c2a8da88f166fa9affeded655f3533f968a0244181e27826de650bd04198bacebeca251badb91bce7107b4d2d66b069720665df130dd02d5621695f7561dcf90d31f59d6111a7ff160a69bcb72c758b0effc2559e0c62cbed918ef3633c72753448392fa67c866e8af5b295c61be216aa0b75577afd09854d37e9cd6e9aacd1b5a139af38192c845c8d8cf08d82cf156471dd242bdce95bb98a06dcecfb8d819db2a717f556ea46cea6bee9e35b500b02f2afab4038b2b75645cd645d78347a4acf82ab80bd48296529d3147009b51c8937f27104818348b5240b73f8a74b6838a9eb109f1d4f74e91435677b2db8003d07ce0ee76228f2b25ad303432e59732d4b186b9e3015a7b8abab549526124abb8758815299c9000bec9d1084e35b9df45e61748932f2c80d67c2369e7325fbe7cd9b9f72ddb05ce1e4a9661abb8bf873b137b692ba71c744a14663440272f48a7ef89acd02cb38be88030b067f7705f59e2ea2a14c6732b0999f96677a9c6159bf072bd2d2dc12a6f9a2d13504ecd493d8f15f23349c12eea2429001c55ff14539ae6819af1f1df76dc7e9a4af0fdc6ff32106de7a4660e0ba329726f5497a9ce5a5e97722810f72888fa254dcf20564be42c88c4ac5eda6180e4488bdfc77ec48c84a713659db30cf5d5a66bce1a22d1a789b78695908cb0f4bea68cc9f5ca81fe587e02ab229993f56e1cc84d05a391f257060a284ce6dcfbfc1c28aa8b14e5441af83d5ade7dbacc05c9e85feee94d2eef23a48d8397bcee7e1901b9fa8ac8ba285753eaa87abd20f164193b8bd05baea35cbf660581f4b09736d7b993233bfd9597fee6f646fc8456d27e0c175b375133f2d94c2d790bf10c74d1c610985dc12288ba8c184d8007dbc034235a8a86b7edd385633e1956d3f8c2b23e4d76c1be02ec49842c073d66b9122c2851132b5d8473f0b7df86b047831ea5f420ae808c7ab0e37f02c95eb49b66f237c5539b4af6bf509ecf22ff62c98374c301ad467d25045ef61e763d47f01ee9d516deece118f72fb4fa7ba16be188b489916e83e0077673bfb3caeb77e5b03e5eebe34cdb799a32d18616368a89f78f43e492963997d3df5c4b954bea2bdba27feb7ced80f1d865d2e7c1ea1486ee7bd6cb3bb67cb41446d6c6653e6d8fcbd7697d32402e880e770ce1acfcc454a44ec93faab85f74f8149755a9f5881eb12dbc7042afd784e039bc466a96ed25155ba2aa919cd73aca96a74d61d1c1b7939dfd43d6db75e9da39ed1cce11fd46d77b9581299070a99cedf805e90807c255d11d32c2ce86b27f22de848dad101b98c60a6690eec5fffcb9e06f363b548f495f9d2cb053ee6d011d1b156e55120e356d85e370adc2a92e62805aabc8e9da9825ea758f5d02937f65c9ef6bc4723ef26b4388baf78f6ccdd50066a05b61a528d92608de7afe03562c2c496172ec68522e9377179bec16be1e96270cec7246f754639bbbecfefe30b62a1fc5fea26a5b1e7877cbd24eb5b6837f3c2027deb0cbd696c0640c92ff94e150dcff7b3f195ff65fe414050633e2e9d5d3005532f52f6fab1c71c26038454fcd2866b48672219ef9eb2f82a7d398ae862bdec4c1eb9d65056705fb0d9a6a70d0a69b6bd88d0cfdafae6db3efc41975664c1a3d180f3366c2ca98efaba4ba95b0249ed1f497470fc4787b9df0b53e6197408cc98f0b5249e4eecc467e2cbffd8360632380fb35e81fa0426ef6d6212321ed641958d5e5c2247544f235e6d6cc29a07f17ef88e6bb42244503761a6d722ca7d08b63f6892d9212f38c27c3f08891ab9d9838e8ae918a0e74c204903258b5d1324d748b12ef4c072ed475a2384af5adbb3e3e647b5cc8c37426da6c8a354f0cc45ef859abac582f03a1573079fc42b800b9402191af820a1d6999c4286015a88f7feee1d5c005e69db2a292015564084cd40729babb349e64cebdc84e72d17ea15f6e802a2633709fbb1e6193bb88380111f8bb59bea369bc49dd30af6c2b33e7288a472c56daf7c3ebd5cbd5cb4c02c8a7bea7605133f1ed2a72002158187b98337868266b5809884267f718d020c885c7c9448ca1fdc859ac0ceb6c989d7b20675f4896e1109d18579dab1a04a0afe4833d9f7a3a6c29d6bb1b65e557258edbbba5ee94c51036f3e2f9586f984b42181c61d23f4bc22d3c7eaa661769437b5e0454deb92ed05b21139d31de917d9ad65ad5070223a9d0926d5dd37de4b62cd14eb07d862a7aff726e6f65b2100849c7aa0e0a87b5278bb03fa78f042cb87160e8f892b6a2a11330be0a7735ee55ac5881406100fd89ecbcdf6b5f7c2f568cb03c445c9717b35351b7f48b3faf4d5f96d27e9953cc8c38df376ae23957d09bfb580ab840bb4df8e3a5c9f306f27536f0f69a0563dd2a86deaee06e2f44d1861bdbba826deed2914ad183d6492c35fea50384cd6967bc922c627238fd12d3c33fd636a5db5730eb3aa0194ec4802ee33065b8e4ac47cbfcfa91ec6f6f4cad6cfea3673c8abf74b38aa6b8c191788f5cc68c7af3f1b3344a97117ef54f3437d9b39abde1df94950af25ba4d68e2b769a5793849824d25812a22658ce6a111b3f7eb3731b98b7e04c5f335093b58d8d5c076c25cfa90fe6096c9a5e56cd69a6718bd01126f5815eb57fb6402deacd5b5d7750a3ec84412d2b66546651bfa3f5f1e141b81144e7c0c40232dd3d1935b410ceaa8b6a976eea87416152721419a9dfe34a97614a971c617c37094cf95e5cc9f964b6ef9621d2e9154c9de6a537ccc2518210319a10b357c27138a898e40a6fb001eb2b53b7ef705890268c6d25bbfd36b8afd5345bbb6a5dd577817b1168a312e49d94ea6710e23cf23a5501356f93fd17248346afc3a23eb51833c88479892795840251bb2f735fbb4dd788ba68d02df2d6fe1a8d42aa26f2290b7178e6f5cc0c0ad9ad077a2df712a8792a80b15592c9797260a9de4c297a027795cc27471f4262097d5137bd9da3ef99d39fa0d43cf4bf055b1abd59d9aec472a659cdb07f0cb6d981fa725c22cc9ce8d12fe8d7723c1fd1f15f7252588a981ac8eb38eec3753e15f0e84229552568a9b5801eabbf5d2ab6e1c6a841dd82cbd1cebf64810a852afc70ba5f6bfd60f59d7eae3d79dcfa04daba3ba6f46187cf1ce38c128e2e9c9c1c60079549b02cd21a12a86a0af732b4da1e39685c446bed9a25889cc1d0dd559d2b4e52967531c68e3820e420b5c3fee0cdedaea0140a8325384744e127ec1a9a051c95cae001958bc6ed6fe136e4f672bf131cc53fab3a992a05f2ef3ff43860c8e5954aa2f402962aba6834d6240305f4a47a8295347b1a5aa527026d150f7eafbd09ec46a570a9b8a1795e3fededd2dd21bd0d8eee89ba9a02baa4b3ba4a8dae873dac343a90c2d5c8cf41c863288bca50720571f16ed26f858e280636308e70d078b0804d12809a5c0726407bc11e96f10266d298c182687a9730c69c0f4062f5cd07285b83922c2d8962a43f6b51d56449e1e0ff9aa357e7aa721764c0f7649a1d104e451e2bba93566ed6eb2d45d02899bcc0daede0c09b72a7ac47d2dee62c8e74c53447b6bf7cd7cdf6f65a079f9ec228dc9fe10830367c4159c35b7ffad4fe05af6acad720ebb3ef840ea7c94b1405bdf46d9cfc624727fd8fc74d7b310e837786cfa653d33d54a57ad15855dea2420686410ed928df1f639f2ac4032b659745bd2652fb8483343a641cd19812a694297014e13d33e1b748206c9c95625f5cfd9cab54cee97be82fcc7a95aeaa1642c89b9735dc3e0d975245532968b9a427003d95f3fe3a837808a2a0ee8c6cde76bb439b4036b9cd4e9772004cfecddbaf46d3b03770c0b7ff45d137b71418b90badf4c3c4f9ac52b0eced4917f5463428094fd332e2dcee7afae139328735bc5e0129fbd7453970a9d56bf4f7f5e8382886927623615729e3a44d969f752539c64d2838b0fba41e0e56b4ac385ad0d121eccfa971cf1b832da095a3a92bd3f07ecc919fce736848f1632218a511fe5b0c6dbf3098f08363e1181c269a0c0e6004b8333824b6a6eeb888724c4b7d5518cd1ea5fd5a9d0bac534848bea7786432647c19cb9426be6abe504ce1c029846b27c2b64bbbf3d075497b36a0f5b2c89ebe7e4cd41a8069b3eb4ce036a2b0fc5a1246554e24abd41f073cca33f4ad9688e77318afcc126b219cd334703995443f4b7be0f477df28dee27866cad6d0540cabb64022876feb1c636ada91e61ccc1f0160effaed2bf297dd2d9c2a1b01a22db82bf0ceff5aa59b22106337903049b32d57def17e51f4dcbc75202ac4db37252593f3ff76ac3e241a74eeeba579c47a1714d7bf5622fb89508beaf645ca0dfe728469b536ba6112c1d11f39788a62114c36c126b1182253360790a302d870bdb89db0728ac86562c089071ba2f474748d0ca09c68f317356135f81a0a66969e0c363235f18b5ac22fc9d2acf4d0e7a043fdcbeda9bfb8a325836dc2582f978a9957435b4138a02dc453cf59641e4272ea76af84cdde6cbd155b691fde248931ad36fe8aa05355a5f1a7dc6b1a35579fa87866c337259ad88c97c4b68b0715aa49ce31fd45a722137814b6facb5fac9666ede6e6fdbec8520f5839b5d18e4e4be0e8ce45e932fa9949597c7c0d5a83f5970d6c50509f46e0046c2e0731eb6f87e3594a72be6b0cde7506b77329a7bbebd9324ada74a0ac367e30844ed5f94ae65bf8fd205d7f22f284cd24968578b60c7a7f4f69ebbc8bb0335a3cdc86a1a1675c66b737672bb331dc897e43bbc49900661967ed44dc363cddfe6f0dd60cb97edcb87c695617a7094c3af455306ca3ce9d2eff7fab363400d65c7eb8b68c968c5f19f9a4d6aa29ef63765718a1d0567d92f39209cef31aa8fe3d236896e5958bdae3d3e145dada5fd0ce50f3c515ff31350e537065755e6eb79d649a6413ff4d8c5f5f7a3b8dd7db510dde7b5accd8578a6b81bd190a93d6d1fdcf99ad4b43c141ec2f078f99ee647d82ca06217d09839372f495e9ea9e1a29a4b568ccb2ae445afc44aff296a64fc573822402de7cab80865683367edfb619d8395377842b640a9995f9718e9f04a59783fcccbba05216bacfa7575528aa015000e61bc74a27458467cec5e262dab63021d4fc23966f979fbb5991566b6a47582ab4262d0afb8713a8206ce4b7636a5e70a946b5c99372aae7d20b5d20ce4116366259e1aca49bd2ac77468698a5ba4f1fb52df95f012000eddd35bedf0612c39b98e81dae2054e62b6724e1f5d48c5583126e2021471b5d9afcb7ff128656f1956e5d449140acbb2a0073fe23cf9b3a40c68d1ed40167c8ac6114c2ca9dab9234bc473b9cdc205b4af5666459bee0b8c62c4a76a320d3ac21cbd3bb01ffe19933d612d261637f5a318e86d86ff67df64f519cab32c0edd70e7bd0f5e5eb6136afa0c4e5d9a65d68f50ce683f95a183f3280f471eaa2e6f2bdf21d3bfa8f42e90213e8aea600bf43c0e2e77db95d64259ec5335d690498d9eac4e903142233d29524c9fe0622aa6ff42380959c6519d45c7296f30eb5606a9c6ddb4159c6e761e5c1bfed94d0b11796f835da46e146fdbdc577bded2985745cda165b5b2d63270b687b9e8ddca8564d820b667beb262451db8a9de9354f401d8522460b2e7ab0e3bd551a1b82cef8078cffe02a66471fdfbbbddc6ec7a06f130653b3b990f22817397f33185a39159a51feee99ed211b4210167686eeec2d3c920ad021b14bb26263bd6ee6c09298938705f7dacd91a103d90b738bc3ffb520502acea26a6f3ae5aaa021e7645014aa76b71a981b50f8a1b680b6ab1c64ee2df081cba8282dfa192f0652d364ddedcd77c329d56d702d4092d7fc08b29e179431550a84e57465c11c21c3e85da5e3509f9bf3d9ac8b724f50fbc80207dc07c0daf233be3f694332ae31d145222c3508089353ec70275077cba23031627e7432a951163e266c2b6e0a633cf47675479ac1123168463585c2a881b52f8ddcb7a096acb7c9ee95f7104704c65be8ea3a05bfbf655f7d239382fce2880f62ad6c043b5f29d10316ef10f933849c2e9824392605900a93dcd3cf52a79dc136ef29478829d8bdc3c5fb4f6057dce0f3bf9878ae07a2480801f8adb8d012ef19e8b01da02b7a584e065ee7c6998704810f146f1a32373c4e281a1dcfe4a1b114542dffbc428684e2dcd81a1be179866cfd159bb5e1e1f153f56682dafd92d860ad5c4157ffbcdbf5d40c2e372be3ad5fbce7b05d92fe6b96571d226f1b91fd72c9ba7f6745cae59f7d271701ce5510ff3eb60b55becf44e07671b86ad6871ec176f1fbd921522fd97064dfae57979213e6d84827fd8ef93b19dfb41d95a869c20c89e9a14cf55f24695ed0981444f329678600dba311eb6e1a57cf000477a575f5734fabb773e6a82c8c320a76abdbde3727b79f242787435e6772c8ae21e4bd0ea1ab64aa5546b5e6233023de565fbb38579ecf8661747159436ae0bb842709fa24ca11dd67a5445a6aa35381541fb55f6bb286ac4681053157ee152454f2223b9934bcd202bba8219f34749ae0d6dd9b4bc12b1bb6c1209686e7b9ba43ee8bfac0def6d0352ace7942b85e7cb60a7ca74f9368152e6a60d08c4a60748070772e146f540adf1cd004a7fe52890f5dc059a3cbde6968f9f27a097b18350f5d34cd384359493b72084d605c107e4884a68a90ccea306df5d24cd946196b2c86e60b11c4f43ab717d2b903012c858f67dde1d6d89216ecf210bbb3ce213b323d04322841b35ab9b8b92746b1f7113214f7d2cba3f783dba2a148d8d139e7daeb503d49cc47b35b1927445cd962c291de13e309af3a0dbb1c8332ae97595532cbf5cd732e784fba17f09584deb7f884f0824876b718df2b79af2c60cc254490a4fe072de29224ca86770bc2e57210b1b3ad1beabb985fc6905180e5de78a749c81659fcce15dfff1ea6cbff7ec29e22c7e1e1c39ec6e678327ce2947ce9962d58540bafcba9a5cf26ee2f0773f3b453a17a1f203211c9738a663a31771528198581a995c99c62f049382f20fa5b9f46cbafe3d91ef11ed41b476609af6db774e56e408246ae74f5bae96d08997bf872317732e3e4a8779d262d786dae0334af72aec4b12e2ac669d51bf5dcfe309e88f48e90a7b1593b34ce619fb18f1cc88a11c688dbcfeb840d6fe12044cefae40a6f29c1676cbcf2a4f26d0b4fb120edcd308ee32b2e9f5a628dc661bde87f020c3f839626f11bba862bb9cfbb8edbe57c324425702ccb932f28b8d4786615831989b49c99fb35a22b44ffe49a19e1bc7dbbc65c956d12f5262dab22aa2998c041b5f6ba4b647ca7b03c29090bad17aa56440b446b1bfe3548f1265a8eed18f76ba0d31424255a8ca6277577575557aec140083c602ad54baa9a3c9a1d09d0c21818acc7fd48a4e423bdc7a36b405e97a56a9182ecb97eeb94c91c7091878bf165bfbd495933e5fad63bc3da06da6ce9c5b5d3b4487ab84938b29172f1ab1d5290990750b1da0ce742b992cd15ccada24b241c9db28ae70996152775e1be966cff79ecb94f633b1b3e3227303c62f7ae924b0c8802e9b9b8088eb627ebf048f5446ef10127f1f6c46848148bfe6e23a65804dac84196537daaee6f85263dfde6e0e39bf6c548c341fc41c3771fe056b5e57b170dfee14bcd908036adab22279c7c7a48b502ae75e00987cb8c10733efb6f89d7e701c9d4a8309fba925b5c36ac25ffb4aa612d3c0fda49046aeef545a0a039f76ae7454666f49ccb3b40e9411794fa864c7852260d1f20fb6ab13b7098fe211e2eef3c11f505fbcb1ac273488c4b4d2afc0dffd60d7e48a29a47d8e43507e87912b988de5675236e613b690b54251d4c8be981e34bc103edccf9d24814c13be3541c65d09e709c7f67dca75a508de394ca872cebeab9823f90a0b61ea505e2c531cd1641f5c9be859c3530d9d025f61e2571c459bc99a8dabfab80db8824783dd74feacbb80296e8543244d1c675553e60a01cb60b30fac131f3135b82a29f6e45ec37553014e2e34480ff1a33334675123328c43005a4beac01e297a322d6387b5da08fe0518abaf471c71d211bdc8cfb34f4276d7585847ce755fc92a2e171dd20589c7a769652f367635dda7174ab07df020c818c6638e75f679d6b71820699bb55bb1ad9b3fc9f340a3766ef08ec6f66739f4fec4a54efdfb2004344d7bca84bf19867f05664fea2e24c26a4c2165f169e52ae67678303e5bb463fd52d778b6da2d2e68ce3e54af10f084f6238a93cd234ac22535db989f01586cd5d33f2aa760bec884cf049fd4ade6a3f3ac4e2723010321512ea31fc9eeee185ee21e97235a4fda94c0f1b6a63649e16d4f024a689d4eebd72e0ed8181dd4762ea7c47018e60baef7faf5b415a9e6dd9c488150211094aad30f8546bde38089a26e1c7f4045562c5de765f707103abd40eb709f5b784a88d3c654d5b5d96748e203dded3e2838b4641a40e307b08c50089b1459db358efc5e01bbd41466050acb347c3573707a43735c72450b677f5c357d4436a2382661c1bc8dc24aa8ad929678b3e46c1a564df1c60e19a660f1e1591a54803f00d3d231c54823595e08581f3f707351d88fd07d448a3c11eb4041ef0ed0400ad04adf300a6a3b660579b9d7716b3a2c8213ca5942e404cf7eb0613ceae5c1250b94f49e28ee38c1d91b990774f2607eb84158576e91a88ab764d3797b4723e56599de8172170d57e97e626e055bb6d6d3d661d1f82b15a5e354b5c1a95a8fc7c46b5832a07c36d925f34bfe0e6346a36b0926d5f9dfe97b2b5697d6d97028856665506e04162b820529e559838ca960928478ed05d8c3331105312dc61173fbd40307a429514885ffcd540fb49d8e06ca3fc425906c929306139f8b05969287d90135468dfd494d493a969d0242eb620fdd3661a87188d071797829ab4777541e7d2883e95826f15199372e27896bf77b496b792548563d60a976ab34705ab35ec72f49ebf57243082da10694506147e6099befc429dbb39f259d5734ddec1b9648ed66d6101a875eb937d29722a049e6813241f1040383d081442513b43e404a31940cbda3acc67d1b018756175c8b1c104fd40a85142d0140303bde6ceb2cc90d96ad3596751d4852b67dbd8ba291becdf7cefc686b486eaf88112eaa8343a59894664bd851f132df2add92a47b595a3806269767734f1c5fe2e46ee1b19b96810e1168dc17d90a3211f949882b7817d3bb300a4f4da5ba563f07425a8481b7d383b85132486684dcbc20c68f20f66f93ed3145518b8c996834b52bc61d08c773e95f2d64e0335c9c09370de80c96f8b557dcf8822845a3b2d739d117a764117dbc58906d12058f612816b333dd0a618f91fd2bdcb8076b3d21942ad941c2d6a5cdf778746d8c717e56a90db377a06fc1af424beecbc91c123c568e4776204e13bfb990549b998da7070b4f79eb6562bccff3718d13d7036601a5c36cac97715e45931f01a96752c4049b948a3b3d58caba3ad31cb5a8f0632c2df13992428ce43b8be5858e2ffd3750f9af389670703fdbc1d94353d001b9d52a88abe8382651950cac03110e9a688440f6c0f11eb31f4ff24830be73251d90da5023df7ad09d9156bbca4fbcf809734977b8163618fd3c64c859d37fd7f34ca75fb596bda537da0520923a4798db9aea4676bc32c53e20f521fa8be4a31dc169c8f5c4980ab71b283c7f250ffed21eb15028e43ac888a9020390fda4128d88e26e7f675b23f466ade81274f4725e4956300d26640a30f76ecf60c892ca7d0a0340ce64aeff29f227d2173f85c49044b4260e74c059433e23655775a64041245aa337348b173ca4dacc780c0f55184929dcde1ce66e8715c5288df49d8dd172906d20502c41c76c12b4234b23035ab9b8000aa797b5015fd0e1b44e8bd58d4e824a64097cbb1716e83aba2096393d3639e5a40fc5173cfa008b81baa0323ba7fcccd38f8364fa0b478837db3abe4b048d3b7c0ed9cb37ab16797d53c9fe40fbcde5449a1341e5df2ac8e6ae746b17de9f6a7d74b9d60dbd8f1f4f7c2ec217f9bb42800284b3d47c6c3d5e09eff20cfea638abb681a9deb95199e6c4acb76da7d633a978b8ee5dac213c5970d080acf9d3a0485281ce5b30987d0548cc252c3cc3562294599497ce1b99e4bd7d1b40f485f25919aa3695f2c2ee9e04a032f495ed3ab7ce5bdd97c9d89c1c36b152b9ca15e1f52259985080d91f0f17f1e65bef674f92d88b6fec3c2426c2b3768ea8e99ff40e9118d7c12bb465f9d342a01bc2255c9da344ac4eca3596d0c8696c7062204ebad2b7b123addfd38920966d373dde35d00c7478c326d9ada354188e9ddbce63b73cf32e28be1c80b24cc1de1c02b9c1f95b539a2fe14be657f71c0aa46826d9f97cbd4606774e46f8ca4fb5cd703a61ca4de5ab0086c80e1929068b2f37e26e42956e403e80de42c837095b79d674fcbd5967100dfdb5a88fdd29ea30cb4afbc8b7fbe1b1152e8c9a33009a16ec376944ea7f9ef5543fd0664f4d87e597ee1ab20c2c25f576f43d042df1a28b1e06eb9de5fef860af2a28440c6b6253d135008562928e46bdf67a83b0b0174cddff7fc0015e134d127a5d7bf340579296cdf86d3312431e265c23517c3ea71f91fddf08b8cb67ec665b5d29881d5d5bf37a03fc11e620dd54c3ad86e183544a675e30ccdb9fcc1ef9e98811967a1584fb067c78a7dc96862186f35c062a6145d42881bfbe5db1a4d88db97b5300a80a1b83324c2c80ee54f2941cb949291f484d6d9baeb9ca5e659f103de504ab51500fc3ba84887fd5ab84e5f557adece780731e54df72b260365603a6fe08933da2c4a45c768e1bedd6426a792e69a6bebd0f3f91a1b9185ca604daee2d83f480e9192f05f3c2200727bed0633f87de903b0af51bf42bf7ca6c68a990fe120f172aa913861d094f63671a291703a6ee7ca6ee517d712f728412e4ef08b7428ea76997c0daa23e8f39cf9e3324d42612916be85f5795dc45d4a9daa4b56d6119781ccc28410632dbee499c4c866b9e90b178a3233a3c5ef6b0639fbfd5e6146a06c3d4f704285af584d416a1b0d211a29c5e3426df28d6c4a1f31300cce7b72c61b39e13f101735104b485f43b9f5a9d8da5c087993ffac41d955deb9d285c3613aed55cc9e20321baa7a62feea9eb48f40cc85fa1c51f81ab1afb4709de71dacfe34976ce8e54ca386478b6c2f2d801ea2fc51b3399591ecf2a7d5a3330d282cd7f6d31c4170007200172505fa4d2f52bf4afbd65b54583e675bb10a1d17092f71772e5bdcd4498839839c412963f66a0fb1f366263e56e7ad2e51a179cb58e7aafe0ab69bd8c15cb290b06e16fa2a86e18c631a58ed33651c293baf4e6b8469d71c03ae9e7a70f416b2fc9e977e3fc78ca90f8ac437df0141d9eea5f03f72c89609e44fa545e5191dd07eed35195da1079941d311fda92d8cba9875b8f3c701f19e42811a940d876c138460bbe78bfb6e9cbeb4d3c9ef9dff8e6f9805c65927c1f5b244a489c202c5e6c5860ab6ac63753df3714f0b47ad6fc7a3f265b4659be51a04b9fd0be909414926b96a58bd3eb0c6a3b918c4ed7f57944b974810889b5e4ca5dc0d857a7018265f058cbf8ecf9e3422a6e1b49ea82b08b074e28d22a932ed78851097b72b2a80a28d0c4ce64ee5a0597bbc58db3afe9a08ecac4323d8dc633658a649d736691160611c971121216c4ae1850f4721344289edf3c27720705c378d52306ad8def31f3ff5941622c4bf8558a8c637e58476026634e74b35eb44341cb4a88d337d9662dafa0389e9b8907488c2a7f7d2a2b790e1203cc49a54ae350961f7904733568821d48239846dd47ff63cd6bd308b4fee0bdb7e29af6c3b3bd557abdb975cf8570d94f278247617fdb7069ce59a110b546ff3dd1b78c0d9ba3e58d0bf750bf9327ebdce242a25b16732ecdca867437a9c3c01344286abc27dbc65bdbc5d5eaeb243a2356cabfaff10d45de98dae97e1753b34f50cfe25a356b5bb053662ff110cb9e7f198bcbfb57099fbc5abe7d7c9671367c2e1c2584ad9b0fd0c3c6338669588440a5a7b67090f33ad15928a0db3a17ce294df444062718a5b2d2032167f3501efb53381d1eb61f0156c8f2e3d8c57c5b018e29b72d356a416963a71ca373118c856b78bf5f6ce4de77f020d50cd185a18d476ef4ce45707e5b8bd12c3d3c27497382cd9d749da943c75f92948e0491e1b72d4b113f4ecb197101d8fdfc1ae462442d64cc1d8fd0ada6fdb61aec59b81fae9670f2b49e7c7f38dc4093a5bd65d01e204f8c1e4ff4357dc83ff23d1a31afac9ec99529c9aaee77bea30e60e2358dff7f7419a58ca4e76878192077953400a08bd9387da72782a8b051d142f15ed8454ecf73d64fdb01ab5a2977636e77e6f819f0735352f4168ffa8f687adaef469f0d2c9d5a0d773871a1620cf9ab3f91543d185a3e0f86a659d0734fe63fcb12f5e392ce10a616617b722b905d1570214f511a5b6af764cebba9353b92e5e3b8046da954d492651ca63edeafb656fe1870921ade460303a36212a5da42e82df28a08692e076b33a06848c572060f2cc962acf2967bba22cdaa4707111d6947c50aaa07116f9b20cc5b903e27e01ad9083a6dbd4f642a7740ef73a4f66c9ece8cdccb001ae59a27b4559bae7df2df1120d7cd59fe2940075536b40238291339761c8498135551300d801cb6d9e1cd9ba9e19055838e56c25f48527373870bf40edfa6a34e4ad5e6ec7100121da306d571f6f24f097b011403c09102e41501c01b8d43866ebf28998a3639c7235a062dc834129b16f6ccd2692436d935e239bf8baf0f703e8953c6ef11262825452a051789e2d505537a350c19c543b345c76d70e7d172384cf982b46edec67dfd9cb4b42919da5bdd2f9a7876f49d4f157cfc8e4a68fe0ac3f21c038c6726976b135869ed24c8eacd6762f8de3da31ab4194fed4ad17f567409f09aba6f4cef3ac03b51972e2a11f51290d41a7f340a1a45dfec9dd64b0b3bb06eed2209db81aecaf214dc47ec424bb791c2ed6d445216ef088b775de7b96ee05e703ec8faee55576522bc69401f26c730d85fef30052b6678f252da6264eebfd648791e17b412e9819df5716fdc0e4ae25db8460d2c197debc59796c66f8a6ae977d42b64bbb8b0ebb2ba25fd46ad6f6b9fd46018344f73f84d82215cc474b21c13ecbef7923881266edd1eb1c755feee2e148c4b556ea31f7805e96275666ccaa7cd5d158e3d51f50a9376d63cca9f4d3859b9ef5d7dfea4087ff2cedd8593ad8b7b3df78a840f5c1f5f30ca31f9b94a71e6e3e9e6d9c68cbed9bd020657ef68a4eb6a1b2092401e4b543890578d12da4d4edbe498a5025c937bdb7ba0f1757e3cd7f04985286f673e044763efefe1f7292462c7f060ab2e964e91f12ca03d28eb5015c91817c3e6f89074aedb3ea0ac5e0131fd97ce6e3723535d579a644549a7056e9d9a91056354d80d110ea36f1defac8540d2158eb75c714dce59bdf53672159a3a196ac223763a7e459c357910a3598de4c6f91bdb07f237457161ceeca5f5867bb738889f7549e792892c840938543f18e50cf696babd8766f8cd1bc4cca5495d4115262d7a638a0a8ca13c4564fccfb354ab6d026961c4e9b6b800efe1b9eef4e91fed8eeb0e606d4f51b663deda14681a7426032cf4d5c282fba4fd002a90e72f8058f0232844d5b3c9943efc8c07cad6072bf47d63d0d7a9bdb5a4b0bead025f429e6807c3152011f53f83c7cd2c29faf4aeba640b64aa6b51c664b352385f79e02b7926a51f2eb4b66ab0f9049f2727a77bccefacb74d30451ed75d69cc40818c48b88b89101e3cc7d1ffd3634e41c978c04a05a3c37f6601c4ce0b42888bdbf38874b9cc033321d55ed0226f4dd9a1439d42281a77ee389e32c2ba6fb94e81c3f428cab92cac32dbba9d9b83126a5370aa37d50c41d8f273abaa709641c613e2346b48974a00c67de53605310d051a549d93de29787e8bb2c66fee4216957455170f53bd956eb25993f733af741822558c37692d8f04579b18cd4a202d4081cb088453013b0ece4f4d275379143bab3838b150b1404054fc8115b25f61252bd0070233a94e491b31f2b42d7ab7ec43c36d151903ebffc03c2348c42eee66cca220df3a5dff5de32b8bae8e9ad41ed4a7d92baf926530814ed82aa801746cb4aa361cf27d6c128faedab26d225ed89ab193b2ee30565c0aba9cd7bcd4044e10c190c74ece9dc423b38ab8d1734dcf227d55bb3a329e5047fcb1e57bc33f7cbecb9e0f56d14f5b2db0c5f10fe892fcdf737c3ae0ee35d052894a2b3a85192dcd6d0622c16a3a49bf79d4be086b9c50c2316eea2e2f9b8c59ca3eb0887beabf22a1a182f0ffbc80362c3ea149b0efba1879c55cf483bc8c084fdd75fb40e235a25f7fa70cc47546822068705118baf07994d097c79efebab72a94c06d0c138fc323d779fb1cb9f92ad05e1ddfc42b6ed57cb5af3d38a96e45f7d0e99be3113c0284821d05a84cab1aa52051c9d79be8f4fa0924eb10a1ceaeafff6fc6f00f15f1ddad6758654eae95d8218da808c779be3d0721ccf0c3802b61d126dc26fcd0e0eb9f29cc0f28ac4b1e4763e6fae887ba6e0efe4f43a7d1e22ee00cf923093dbf64a6ffafffd873072a94fbbe07f00f987690743b7153144abe409c4aa53da18e39e8b15fea173531041bae34879b83efecd5695b33428d225c6b86c97782fb5b2c9a75731857fd5365ac2fed76a5637a67aaa56a766a0c1049159ca84f639ee907e98a7e24f0a27f6fc078eb7273e2db01c6c6cc94567b882381a018b1498f10e988e28955322dd9fc95a1f0123bda699318e882fe2ec5cfec46af5a277c00e654454dc5da17498fb62b770198cf4a414c0d8d59b73648739ebc91b1aa3f31d7651f3d511887fc96ab821d08b01a1cff2cdd72eef4f90ea2a543e079b700a4c88ead5949d023e6a036235c0cd95b39e8717d831d53731147879e1103cc008c4056c8a5ecf55123cea1e77fb4039ca0103c28a06774bd2dfab55ebaaed6042696516a82e1f65658cda3e75386f4c3b0382aa3df0cf39c3c84f1ba12200353c83f7a0d231d44dd205e851b0f31c24cdbdc86ec4960385e9cbd7ccb48a7d4c207a9b57330f68c11ad3d73d0979f9d697c7fd63bc4bb7e48a7f0ca59f8d904a0fe70195f470cb3593a4f0ddd7cbee7069879487b9b58f8a5a63ef53cf26ea409b006d2d0b057e8b8ad5a98235cc3ae02fba4b6154f3fef4ff463b643f450aa36585774f5152aa4dcb6a7f0e25be0a0bb702571377945db0270f41135052f11c4cf36f84cdef20837c72730380b39224a7bbda3e69035b4c1feca31e8e84dfb5c9bc4060ec23b837c56445bf3076bc666c9b09f258feaa059ed3ddfa75627fa0ea8e5962a94a60549dd4d1f931c15a1ed5fa5325a0760b6deda37094fe99ad4cbfb1952e689fd95fb6b892edd9ab4674fc9a5185fbca4d624984d5254c8210584c2402bfabbf1c5c1668e6e29d2004b74d6a217dd6ecd7da95e95e91e7ce60095d49970b5c285241ac32c96b668caf97582f8a469f3c0272e39d16f1d018ac1a21a17a7592db5e2303ed7444080c2f07f431dfd03f0c9cc2cae0076d8cc538412be3fb700af2d36f09f52ebb95584d0f350b89ca10bb015698d8b57cf73d70376ee236fcaac4448b033498d308bcd66966cf476c0f02222e30c1fb86edf80d70470651ff5b57178763535d4bf5e180fde6f578dade6c2cf4ecfc0297ac602df48dc8370299e3db667837edea169ccd619b74a48bbac342ab7aa9f3b79875b0bbd3dcd4ad7cfbff5333a3302b31bbe86a557563813d11d11e61017073e070add0e4ed4ba9523e56d61ce43e7e17c0556d951661a2817d59e9b99f41b7e212aa23e272b96a26dcd4ed25263ca858836873124720583ca89fb7da1801291201ef76c024099a98195b449ccc986f5db57fa1f5778ebb9417599e97156c3adf1be7ecdec8bb1b85d668827147a683d9683ca01ca0e1c2370b760696429b81b833f308b8632ef7c2107158f0ddf4e0a15a8b95c9b53235c508605123b32cd848eec8ce11e1ebcf09e3db93f97a01180e83c48ab718e9d26169f8040e522cf41800bfd9d0c29057e596c9bab51970bb6aa4358fcf7b86b8fc872bd6f637e91393133ec2c7adfb4c978c48926e65778961f31d66a00913607e69588c19f7bd2d88535dea3cb7353c4785c5c47b7d2b470d606d90ef7064148ad633efc9b9e31c58c9595807f081a8b1fe56ddaa621c622a3df2dca5ce61893bfc03df2734d44bb1aeb5318b8e5f544782b8010a186fabf515079592b74952bdc8786892292b976ada5da03a897713227b34bf6aec321b198c34853b6fc10fc336dccfda0c8e036f69a8884494d69d0bfba7c32b9e3f81181cf05f9009ea5fc3c7b79483308561a367a5f02889e300b59701619e042adea36d060ff30cc6d3966460831555cccf783d9fffb5a94aa94fec4cb4a9ffd4f2e7871ae1bcf141af64ec902cccb74d13998585e05379f30482d3a2a0039cce81f6856c032ff8cd011d0149cfd510e0c325369312fa9d9e68310ab7c0ade33b73693fc5c9334f63ecbb4bc157e145e6b2f35dac9a523726b4ca05516d56cdea8357cdf528dff283cc334f93eafd00e18d20e384f268ba3366e8bbf803b05059c6b3ebb762afa3e5d58551dc686e0df3fdcf99a06e69e67b1f03bef19ec3d2b5e99080ac6d18f53c72887e1825134fe0b026d0a2658a4d1d3d78b49b744b205406f528e88d2afdf6b65a14a8609b42f1aaac0a6eac423669d11de79e16742a67dffeef3775519e6005dfbd00bdcc4c0ba9be0e5f3ea161eb247bc1a2fc7178f94e4d0b59d860b699337c39e9dac0937200a7bf09f00b01326b2d3c53fd78a3ea7003024bbd3a2f204d9f8198cd486140b83bb4566805b5f174bd64689b461bc8af965e57c9d400f7c24a638a4294866614f2c640df01b598688bd8ec88eb94c0fa2c52c5417764a4b08073c2058762050cc24dce7f396d47b0fc4ab337ac91faa3bc141198b5c3e53230ed7b12c433dc4967d62df430023feeec1bbd91718f877bd96c96bc16ae3c2e96a576348cf4456a8934192bf7a1a1c9bd861ed44fe7d04a69c3c66da2cfb38eb0a2cba3137461cb9d383a05fa47d934f31aa65a9f224df22f44cee7981d997e9119454504601b6634461e876745bcc57ce52d3739ab5692d91aa6ddf46874bc8154faec705c3379b596736e1ddbd48c31cf84f22b05876745bfb0d883c521f35ebda829417b87c3bef73fbe9be3b8c729827c9cb24de90be978b6ecad2952d34f23f8df04b511f1ddb1c78bcaa28b49c69e3cf2f420ce0078f835b931513059ee359ab358b7d08e40948a2ccc7fc3018738c7fbd217060533fc4091f8f49dc2abd3bc2dc556f01d18a7ab35c486f53e4f2bb76811b3ae13c34e1fdded32f542c2688e9350ba706719b223b9e543966ec50edd874f6de503ae63dd0fcdbf4684081c682519ed0e7b7a954362dcaf0d29682ee14a1337943a2bbc07a3534abe7ee0f54788d4af1458714e0aa6d47cb15974427579ceba971bc99290769b9bbacbec1c1fd6467ec7008bc119fdc2c5a6f58fff6722e953e7a33f633099513f55c91fb216f73663bdce5f1415ca048e1a1f93548bd87bd2fa701b0d2e26c9146fe4fcae4d8274dc86905ba2865c8b1defb4f2242c6ef07fe26f07c937a1fd54552ac910e0a4125c908926e839510845bde75d1a4c11fc19ac649462b691454b7a304e216d102a27424185c9f09ed11e422009541b3b25ef5f1018bf1208c2ccbb6a0dc526d7a7375dd5864c160b5dcf30de2b3f5d83445cad28f0a6e6dac646028fa9c733f642e13d950ce3427bda09d86dd7e71daaa8a116c964d6d5144c030c9b92356a0c6501e34bd2f2ed8e637993e30aae08d1a05c0376f4c530927ed40e998d46cad761a288d1b9b986578d3b8246d63e20b00bebfe033859a618d24ddf49a296f6dca9496f0c7f91d1d8e47b71c195b4925e4d897d711ab243f92f14ec73e6e277da031d15c78d018c90b5895af5ad7b152b795fbeac7af421cd8cee7318b6435fca0841d17b8053b2e4391fe31055a63075b0d247f82a6b49fcc6ea30055cdb725d246e43f4084ee0137379571cf9381bde7e4d81c92bc139a9be3eacf35507ad20bfeb858d48ee6339962eecb3f1cb6cd8eb253073addcc7a3fb3d047815966045bc4eca4959d15d2b9e681dd621f3edf04d53bcb051f9277830690c06dbd79120dfa2759e7f7e5d2aad7735c7848f4a98a6f3bfaad23468f30ba8bf03d4548fd3edd7f42f7df1a1a99a8c8de9e5f6a8c7fc5a1affe2ebb4580876a347332afc7423002e648affd9286f6dca30847dc3bbdc9d51bcb12c6a9ee8f554579068498c151c098541ec78e8e605ed395e8ded522f0f9c2805c3c29d79ed4a85a647b5c4e35e11caa90ed95046d09cc61d800d5994dfda2fb82d6ae665da6ed12140e751cd1fc2fce097f19e80b948536e64ed414772e8a4cc426672bf32ced6643466ddbf260230828e86d45a14e6243732ed55ae327e71c323d4d3035352638aaac43aaa0056d79d54d406ecb1e1ea81a258a5fb37cdc3a112a052432ef2a462a11b843fda47d0d01dd827449232958f0b28af413f1e826cd215e98930bb6cc050fcb21cd51d8f39338cd6f7aa3a53282a3625cecae15ab9bd6bfac9b8c5f588a77996c893f2afae1e8e5b31569173718adc8290e41b2b84cdbfd24676c7798236671b9f24a88dadb505368c693112e54b6245546268fb7d6228b57c58b3da29becc0f825f9843f21d9e5cd39eb2a8e3896211c0a2443dbc4407e456a09def9d8e40ec5c44ae8f0435ed875411f71222b19d6c2146f30876240bd3d17ab1195f812e040677351bb06cae08147cc1d83340ccab61a5677cf6f5011e8778dabd3f2e9748ef7a267adcf1dfc06b4fc1856727ba853a4f007caeef162433cb2fbbe7a0b7554da6288d8f273b8066354c91376a8dbeb4f97b7e42bd4e794eb6bbccf4132a43fe14334367deaa345f948e80bb4634858f62e19e56cb7e25db98c8e0d616eb9a4ec3e96b997b092302cf6a8ae3d6b3ac456634cab9fedf9e03259df0c2f397cda1e7cf7582b9b19057fd2040d5e9ecaa6be2dc55899e22481a89f9ed6b2b75f5cba7f481d4c390d97d58f9e3d0c5ada3a6260c3bb557ad559668af7acda38ff84e36bf75fa39356fbc99ab571b3f85e6d657bece8ca34b89f1660a40ec21c9e19ad235e496a7e50413ab2a82f3558c11b11452a5d3d026dc27de9c44f7e954beecde9bc2f62688ec36b06c5b6c7523c457d1cf2bbaa03de7c956aeb9f6680cbc3da3e01b979c03d762048dd756210d94f5e0828d29ffed24508b5a70a0bd08b40add4f2e841cf051c458df8da14c6005587cb879b05456aafdff41e5938135d8591d717c3b7faa2ab0026f694fdd0a4d5f8f626a80d48dab1ae4ef1770624cb37acda78f66e69153bccd3a45b8c6ec3c547771533f03607473132a542187794d446ddffcc9a67d61c8edeabd15622e266f09dd8bef9985752914e195bb29518ac11328d6bf499923d862477e2a1c4fec2ad13fe19401e3340702f9012819e97c8279fd53816f82efb71bf52b1a827e3e086506d34c605fbf8d665639e90dc28c98be54ec53bb6feecea4807dac59cb62591b2ada0f887a511bb64f99e53ea82c2e6642db2f36240ffef93be26d5e8e09153db9e79a3df2746a2561bdbb3306decc5401b5bc5839616b6bfd6d8e11f2ec93711c443e31242c89c1107e6016b0fe6536ab34423cf6e5bef83a10d384b0c242e4b207581ffe54a3ff24a934ec887695fb37791e639f39d74f2897b988cc01468d482973b60ac05495d31a429fe778e8abdc3d5e44f554bdada1bac7cd9e54cca4efac1cc0599d1371c0bdf46dfe9ddd885c6e37d91dbfdd9f9c867523fb371297f743c7a41f4d49572fef6f573ffb66e8d3f7c6fe95f9a30d32b84ef9e5974b343d20a4b2f6afc6c4cfdd39e81ae4296811fa3dd857d480276f0f01e84dfcf737ead56bd75047761c6758cd2e6f22d91f0e0a8fa5963a84e1973199ff73d066c1b4f6ea59b551b9dcc48611bf9fe903c3bda4de8d16f7154bc43bf45fd40907f893cad86dbb79175c670a783e2f144c40d353dd512fb27fd1db650328d481f96ce78151676b21b59ab00a2208ab87ed8fbe97206f058b8920f7834ef3179357f6e97f82c21a47661bc76a90202b73b6b88229fc8b9c9927063f2a20ff827bec88dfd39a1cf113b9f96330985407cc65d919ebc18029a68e7164155339ecafcb94c5b9d5fc4cac4420f172089f221ea53aaecb79b2055e1b42ca20a9c32eaf4404fdf60bafb8dfedf1657cbabca31ed62e296085f3806df1b96d3bc769ba3a4366959e03a31e8162edc77153fb967c5ced36b8c08094da83d8dc19a848912fd0bd077b5acd342a83f571ae096f6330732c51f3594fd1d3d9e8398bf9c1ddc7d5f056ecd3e2c4b0998e56b585fc9ea8910a5b61418746787ef2d4d61749c5f5314e45a00061881b0e07c190904f04cba43ce43b91e8d9a671f0afd63212e5dbe35af5bcf9ceda1afc7aeab5a9d159ab469686b66033f9e0d76e93d7b349def1dcabc49f8659753d7b4247c757f8eca7d7694673889da215c06b8d2d69277415100d1211afc791ab6eefc7d0be16c2ea573c73f5bf4bd07b486933de03966f37aa9aa114ede1c472f1dc05bfaece6720c56c0576bcb0d87306c50db4fcc05d6a044356c8dfe69dc4758afcef81c5a1cdf2c8e24e582c4dfb32a58d282e885782bb400c935ba282d14544c07a56ad30cda1f96930a5d2d41272a09d1d31abd24609c06db069144520b32700f26268c5d92012d7c060b7629cd514996c41c341c82b07180b19fc997b573f54a4f8d783d1504d0fa222a2d93e18d94bfcf2d7888b609e05fe89298374f315052377874c32f04248a40d9f9276de216060b85f222383942d6ab4edce793af4f4eb0d13b7cacaedf5894b5f0fc0daf33d6bb79983bf8779921425c40cdd9e19e58d3951504cd77575dc92229757bb6f1ca80f83723eb0e5424804b7eeae57b49fc9f3f417167eb804b91193c128fa75f21a5334e3287c79611698c20778857b3cf80136b424ca5d9faab37813126e47b18f4ae0c839bab0a5b645d8d438c5b1dc1c80b3bf4583abf13175a764ff064fcc2166bb74e4b71c9e742befa4c0d409278ea66dfd1dad1a26d24e748c65854ca1ea8b4c62963ae12caf530eca242048c4bca1d9a8255019bfcb976eaad266850185c5e786da273bb7541f53655df8e51f839790a7486460d9b5995d10f025b8017adc368909c89ca66ee40f02c4419e262b2b106736fd62e3f8b1662b4023ffedf8c0f9dc5303dce91118cd4a79c257a1b7604d7da17e42dd2bb80b4bd9bb9a254df4fef233428f07073f65856f9613573dbde0a7c610b0ce481f36804a05f90451117a7101c8773c042bdfb24500dbada33303509f8b30ad199ff132699ed3bdcf484a9e29d71b4a514049bcd5a48483b0bf6960f52a07c58c02e47ada391e58d5c21230fc1a24725b1edfadb98218e771c646bd16211531b963053721ebd61ae4ba0310630c5999606986372b8e38de055bdde31449936eee22b51c1ffe75e7964537b598ad584dee5ea95aa719b4050c70315166566d84412aea49550b72d4e9cfd1a74684e1050eba71d1c5acde4fce96db8861930129182bdb272f3c2bbbdb83f098a057b180d28bfae074c0e9811da3d0c02c749826af8376fc632b6f83b7b1d66e49b774302f5525dc744b4b30ccc1312e8203b859dd5bc1b02634a4f631d2a8e9658f6d8a65f81aa3db870fedec8c538e9a8cbd6b6a3245799ca77410471b52ccb45968801ed0dfab06e0b6ecb764316a222b152c6554b2a2be220871fb5b41cce6ac0b3ce55b6c29d6fd918ddc870cb8215f4e9d8e38b2edd0ec7b10bbece50a82fc96abbe3a63991c35b7feef0e46f4480e9e4f713b64034188a1cf327a752c3d5ff5a4460dea0a7f1afe776ee914a4cdfc74a9ebf3352bded7f0ac83c00a3566bfe7e17b02f6887717f1668177f8f8dfef15c4531aa2ca7cbd4d601c9edb9754b03d6dd2bcfd38d263b064522c556f5b9952374aaa8f15c78baf6424e2fc11f592e67ccc7695fe3cffd8ad7881e858958dc07ce94ef0edd8e74bb26421f4ca4f2832083e5b591b367cc163c4ec5f05a12a70f785b5c3ef63ca542f2bdba2d7597619edd2932f25a8eedecb79e2a58ead022e9d9e43b989b7f36ace0aa42e10d41223c3cdd6314577b0c40e68f94a65e1fe774c5f5de5b0c69eeb1116b68f88af8657a7d44da761e4204fd3274683ffb37456c843af64b025e0039314e200348277777f2370bf6f47472a4f26370345798229da13df3c2b16dd0fe746cd4a25a7c0cd4d72f83ca513310c9b6fdea30ac59cc52ee81ba2e50c34583e310036e8a6c3b4f61825a977f1cfde2caa026a8de22811a5d4548f8e40968fd1bff463729df722450a09a213164823325b17e55be3afa3bfd3a7ab7dbb79034ee1ae6886ef7378a5a9825349932b9c25281353501a4b466488db7063b4c0ce91a3d7f5cbbe88af0b07b43ee4fb26559ada3b1e535d31066d8c22edac1fe035ef9d8b9ada63f5baf763114800f3554c81a21b0dfbfac9a6b18cc74a9a182e43196571a9955270a4d9b68ca1bcaa90c3b103ae73e9bc6861ce63eac8deb59fda1292989a166139f44237f0587a38679fae06b1e3cb372fd37c4c6db63711d1aa3f608fbd81f468cab4b4c2ff7e5b7219e9d2d902435fccb9a72f441b1e71b0576f5bd8a69df998b315d395f567ee87a6e70f2680caabb4df1ade30ea0cb771a0ccc75bc634487068338a7dffe2a88259f055f5e15935d01b2b4031f8f3ee090bfa93c7f8b4e0ed2bd44ce0681f0ba28c2f472adbd0cff64e44d63f81c8d00bb8a87a2a9c1b012c366f6509223afae6154ec5441f132af8fd74dbca09c7a94c83bd9393640e039b05756b863c9eb9067d922c05584ff117aba445c5895bcd836c960af0c359d9a9ee416d969d7516a561b0b9503c51affd69920600de61da2ac22ea5503b012e5fe3d48316c46d587411496bbb5cc6003b4025b908e2a1c388c61fb568b589978823458d0700246c6c5eaae471ed0582c8f6697eb74a8a33ffefdc8e90650480841c8ab3970127bd7d788f5d968a2700a6cf442f486e97a515dd666019df762dbade9c99c09fefdb394cae68a8b4d006f9dc435fcf864a3aebc3bccf0bf7ef6da0aa9042000b2264e2f85a82b19aa74cfd0470d271c2b5cbda68e6fbeb8c0fd8690ce2b38caa48af10eba1c6dc2e1fb0db8d1b9db2a0184a22a815eae08b20e3afee1e653614042d74f36e5f11bf68a5e2f9989c3da4a0ad3430b728134627a65243632025e446db29b979c1d59b7e317c37524a8fd37a41d484fd0b486d6f15f3e9f190d64562c1f066289e1a06a61ec7135e7f0332ff3ab39eb09575b783bb1727008171b1f8c8c09b0557ce0f249047861865bdfbbdd5b9621d9c3b74dc3a24c01078735fc0a7dc8c5812adbd935bcbb6273fc9d8069afd845988fe850964c028a4ae766eae5fdd7d88d7561eacbfe9459e5c2929ccdde7673591133705a5c0ad6c6fedf6c6df343ac409c46f0146f2db1a545ab9b21ab96764393f1106b858090f1e2dcf87a601d97277ef440684d84a8144b2579e06c118537e4b1e4c3942b1dab5e98f44830f49fd2b6378dc9aaff85a0cb2e35d0faef7769f5890cb07618823344088cfdca554fd253d79b695b7cdec3a9c5ba5865227d52c5710e0e2f330128ac8a6bd08b7cfdf182e9fa3e3fcf0038903f46bffaed57b556203d3fae3584e81781956d5d132be1d273c75b6e140adba03f28b266a98eaab8f57941e831748dab56f3f2b326b541bc93f212b374dded5bbd0db39810ea38e9215e1baef8f1cf609d428fd8de9b16eab8aeea0f207bc3fc2b2198561f7fe1453ff9592bddbdcf3ea1ea0afb92079d8487b89ce434a89ee862d054cad0d38bbbf86dc40f3a7ea3e81bc8337b1b3836151f72c21a068a64779a354b48ca2cf668a93e6c9b1c41581bf00f2d94ff8c40cccc5daa9602186a7611c0858c7650aefbdd44fdeef5e6334a02569f0620adead351afcf33320b431a16bf07ace117f882be04b8c6802d02bba7354fd7bf88e78876772ac1e72bab0dcc746cb8f735f70bb6b83dd24f5d2457777675c969f1c1c9ec90a406e884c45e269d2e5422dc6e3f3ab7ae9e50580bf8290d8f671a93a0b2c70fbbf7a3da806aa6ec9a29692405e189295bf7daa722bd62ad48d6a4842f74e8f427019a4127b9c8744bbc44c39864977838bd460bfb5116996b4d0b8c0778a90d0cebbc29f34acc1dd57ab27833c5c3ab74dff39976ea08f4f9b770667b7ea4718cd4958e7356b288e05132106ec2ed8ddd4736c4ec0d5de3868a10c39580427705e6c4c0b1411dca1b47c7f131ca5676f2f66432f7bf588862ed3a2db0c04a249f42f37ac0e39fcfd90cf5d00296c77029a6072744b5bd8f84f67fc9946a484928328bef7b13b0e9a9b364df85345139d41d7cfdabad3efa62afc511a5ade16bfdbebcb5cf5d60cdeee4d7c139ea9ef73b2732636a216fc4609386ba788ecc4be929fc2b1ac6f28115b512a0e13e397b3345eae62800076dfcf5e5c692f81aca48ff0cbbca16e38922f169763aa6eb837f73a7945cb5a62eccbaebd25a017048437a822b171be3984986b7bbab91a6a21542b7611fbb788642e77483feea4bed44289377ed6f96a0400bee09e2db23c00deb67b48228688b445392a5c10fdb609bc1f0271f154cbdbf5de4e42490b7e1bfa5bf8b0d6814942f44af97ddf924b40cf2b2deb25b928c12f1c262478b20d8f2417be50a4ae0db8bc33162364214fbd8a4d9cc7075954071465b6e5aeae946fae625bea5a5ea7c7d6849111f147f001aa887cad96c0499679826eaabdf0083142e89e5a90e8fb3702517ad4731b8c5ff6f193bc495e9ead65873cf08405a7f1c3fd68b59b9d82268d6cb5bee49e37279e7386cd407ebde9daf66d6dadcd738a29912b83f9439e704c78075bb0285d0ce3ec258ee43b4ffec05169a4465c1d753f36eb3dd68a63d9548d06e3682501b45d672ff336784c8604cda7474cb22db3621ac82eedf9112aff8df23b6ea4e6f33b84c3f0cf676f19ba875fdb80a5bc44456edb4cb1003d919744c9f41b5c0e7995764a5ba8832deddba3e0755386618fe2c626940462a7623e3ee73cc547df72a9536530876af46126e6a72532357ca4570ffa5696ee247047ab91056f2bd976686b686533a98a4e18a8959975bcf7d9ebfe06fb510115cf8e0c9400e25f40cd43c9455db652448f684d86d9f07799545c23fd99afaaf0e7f2c96d810458c7714615b3e828e9ad5c95707962ef41345d0730b02802d31cbd9d2b6498bc1bb91289ce3a7f0c841fa28f239f39002c815c44276f15762069c925b737768a66224b3c426dd21ca4eca7f6a85bfe94f3751bd06fdb1ae95a93e8bb504e318107ada91cd9861e7b486bdd2c444b5de7f73161fa5be6dc925769b3cf031ae1aa924d56b6da62324fed38ac5a8fd5a176de32d90e1f946ece96ee6199b0bf46f6941c2ea8362a59c95b25391bb25cb4cc0d6f1a0ed8eed27f7d88c5c579220a2d5078b9fb1876d03d3ac8a1bde7e13b01639a9c1d893d87b86f7028d8f2a3527a53f6089db2212f01b96e62cb01d194749a6350a7f2c1fcef457c81627e1e5515ef30f2987748c9a61ed2d3cf7024df01ea61daa108fa36aa81d2577d4c5c3e4095c44a97112cc19a9a5a14468657e3820d07ef8a6051f5150ba93b8f1338502869ec817ff96146d4f852d9c71cee1b94fef19a839811d65f7335ebb94ac7acf3442e18519d9fe4c8a39df9cf00fa0b1694b586909201f953aff441257a0d2ddd1ba1e856ea2773b88fa2af0339e4f9e889606b16acc15ac2135083bf7260e47015b04cfc1bb3591ff30135932026709b80f7b211d8f7b09b85c11d36aaffe208445a147dc05c0660c713e3f7abd7043fa322d9c327c1a0db7d02ba641748dd22b570a213a30d548d7494a35f53ca45929d142b2be88c18406b24a1b696524171168ee69501f619aa57adef12283377e9d4af62aa7f53839f465a8fe5a0cb69d52856d62b89f1931255c525b1a3282095e720fd9d09055e75ab54cb302c0fb4608638e81d22b7bec74167fd12c892d2eb5187d01ca924184e354bf1cd1aecd0466b55aa8c99f1ff47aa8b1814ab11e2d5773833c8803d5e39866fca179d6a80a667e53d0d30b696f97e0a5421d8cbeca768977501c9d3448630b3b7af37b08c0ce0d8300a61fb5325c81cf4672af3ec21bf5433dfae3ccb5a3345fe8f30315da7f006039eabb9fb577ed08f202d270583cff9221926bd89c982657ec36c24c619e408a36801404cbb3ad9f49f900dc35fa2d2c0dfe89660928418b87feb194b2812614d91f3bb656a72824d3be9d4386f6429405d7676d92bab2d7c70eca5bb0ba5e8ad868c53744335f5fdf284f69b8cbb9361cd4333ad47dbc94932ff7913e87457ffeb4b69bae5670b15506372e686977a594a37ebcb16a01c36df9fbaf1bf1df57356dbd0650c5c71d60845eaef100ff155f4890604b82113edc7b6089edd0dc6b36eee3c8913ebf134fad85779ecaecee8b9520652445b9e83749b5f99468dd173b5aad2b41af8a0c804d07838e39e3cfaaf81c4a3fb9d030447d25cbcd0ae1aa5622d29f197e77da1cc1aa266a1cd3de792168a5843560bd42fa857f001670fba2ef60978dc88d91ab4cbe331a154e66816e3e071f5c18ac6fc54795331f9b43a9256b3acc5a2b67f1ded5a49d018503ee4379e2fa79f650b0dce317952291024652f8129976491ff94e203a846f26b4eb1f0eba6e6993f319c10b95dda76ecd46b2d70b44e49038b42883769e1aa2ff51b9902a46b72d67078126f352b185b7095d9347db5358d3393ff7d1f24a03a7ebc85bbd660ce4697fdb42d39b9da8dd304ae13136376953219de5db66182e276aef3e01692252b68266ed28468918956f320a8497b254b281ba3590724f34f5bec657d305150974c576576ff66ab78ff11a27c127d603f5e003d290b1eea4ea2e4d4d8ad3f1e11ec5c887184f5ba42f32837adbbd449e3b79b67005d484a60d66367594f534763c5e688ffb539808437ba2d1f4677779e480fbd99a605c595d18e6d58841c66b0b1e9cdc63b2b5a31249c9e15cb4875e0ec6b1ea671ed29e970f8bddaff7e92fb28fe9ec50bef39a855d2aa3a629eb446f50636975b2e3335d96031b49857798c66aba6f66e943aef0205a46ee42a36e2d593575d367c4d55da11fbbd1e59087d12843cdb0b0f013fbd664fc07025af3549d4c9c0c9f6dbff5afb371d370c73f8484bcd62e099fd80209988a5fd686a2dc53f3ad3d613270ddff0a857e99af7564273ae8f65542871768984adcfc67c5d06a75e8575a7c4a65b4329da628856551763392d8ace2b7bf4a9981299a237dfaf45991d0397e91922ef91a2200cc917414d92e8ef809ea905ad647d92a551a8bfd2381550f2a7a5fcf514e64e32f3bc95247d3fa98532c83d6db04a654ec5a3d7929ffb86791c028dabf0353bfbd80a985938bb6a637edb46913ab3456850b9adf02c7a383f5d38741d605c11e7f35c7de7d4c635f4dd5ec4eafb1bb362a0c6b265f44fe469c6e66334427c4198a85ae98de7296b924a35826d8770e7a0cd1762f6a75efdc5fd61b862d5e10032df34ab526c47494fff308910c8ea08644ccaabfe0d4d846e01afcaf76159f26026fbbef889474f0fea291e675052b59a6773b8c6c744e2ce541e4b7538e4ca41e4e1c2df3922e26bfc17c3442573f3ed7f6424f429b3c46919cda8b910de1dc816c31422982786de86a1d634ce8268e86d3c017697341441fabb8e03967ee878180988d57fc257f3b950df30884a14523027b943366992a6f5156db2f5afe4c10c8704ff9a30411468715cff95b3d68010debf262123622fa234fb1398cec32352765d14aed3014128ed9143a85c40bb300f07b1eb7be6fcfbbbbc391d53163be91d4e39e4da08c7a914177fbbc73810b7cd70b751a836222632c6fa8d47ad9697b55853fa7c4cb804db02a384a70d9fa60dc8e0d7d2d437196ad41eed529ee90d53eca45ad4f0c493e8c1a2ecf7398a345c1a0d1ee3da919d26c6fe81c7139b6f3ebd87bd04f736d26fd6ca9d1837d7b1ab389264da20c6c642277dcf2415e73912cbf7bbb1e42ebe9c4e608a302c7c7730545503c4239b8347089b06e958dfc6d6507e49040150eaede2f4eb7a8f6ef9e3a4f59f947b7d627f24696826e772743df1036ca8852fa3450240274e6f07ec2fb0ad717fc84874ee412be937f707f71d16af36cd3b86024a176666d74c4d5398dc0eb4b04f36cf067ee7d910259177f928b40dd4cc037f8d0cc62d292a47909dd5c6bcc7634f5eb6f035ae4abaf13a4b88ffa9fe855176524e722ceda6c5b5993ad298cbca907af57c625fdd1eccd951c46ad81618fbf812e435790fd0dd4c17bdc2003d0cce1c93f6e8c896c913ca0cb067cc8e71efbc00894be26d2063b7e24a42b040c495cf8d8eb9b5628527d9407f7adcf33d267d17e0eab121a646138d828a85cb719f0c84fae1706ce63b387c1bb9d5f8a835b9e5f78bee59aeb84ad7d45d32ea13256f016cddefd5092a458a2f84efbd9c84bea56bf45650a84103d694fa2c59c2a786b030544724a294577ed2fdf86d8eee7944d1c1253e14298c21d5ca68026ab8ec015709f51ca947817ebb228b4854e3c96076d1580493c7914b7f48967a061b527b201379c0218468b0a8b4be029e93c3707586bd9773871174752099b757f016d3f6162b5855a79e95788a9030fe40b1e5548bcf1946973abb01cc4d8f6a1352eecea30fda4ddfeb8b8d9ea0c59da01df9d2261b9f1342d38566b516304ea24b6e170e7eb623699aee426efe39b6ae52aa257e08d31bec0a35d9bc7ce1de349c19c9ac2285b94c23039a23d5c353216a438d64fe543af8cbb8b941fc74b7083aa51684390df29538282afc25f6675a8c5905a9aebd2a4724ae104150e699d379d465de8b0e8621dd22a5f42ff523fe4f3faa95b7672e980ec0e870100bb77d7a70e529f634f76e0d2a672d4e7a2616899266f8982d7eb71409dd830ed2a95858fc60fd09ab30ef1fe34923b3553042dd7f14dc0037031f871569d17f1f146d7685c7c0b0d0ec778d737e33e16561c37ec8523454e9c5b72599e74df07da11f9757941cd99a36fd135c9ba7767f88623bcb9db0abc385e503cf7f13ed9cb8635b0d3e76df70a6e7c7a4a40c955bb7e424b01cbd10d6b1f8394d541cd24371db740e17da8e983d7bbfdf6768e41e289143e820a31334331038520b76b54f738a79003b53ad519f62eaec12276575a51be09433418656e3675e2bd0a4a80d3b49c2d395ae656cac2657f45ecd5b1ae2e001e3e4849beba85481d623033ea1124ecb0a66f51d091adcdbaff9145d8b1563ae325b46d276ac82baa1be985ccbc9f1d3f548003b3111c390ab2739f41f87794961cd45b4bb272ffd1224b2a4310384b21cdc7cdd4fe7b8f3a1960a9e530b0470d897f25a66700def43a1a857cdd3d9f909a78c7193d4bf638f61ee3f6e7a7b0f88a31f9ec47f300da5d936d9057ab55768374883391274d2e0bb43991fae41835d3be1a555c2417bf96e2a355ef9cda22da0194d6c15c8fbf94158c560f1bbb67fea9e6c1be4a8486de6428748b1dc53f441a1e001aa5fde7df755f3f010bad7a79fb41d6afb4e4bac6a0f976383f6544fa445874bbdbcb75eeefb5461ee243a33c4dc6f5c2f5b66c4ffc89f453cea09d90f2b207fc448fecc50adca5b3dcca6628b1cb9a98d5313fe1644cafa28493b88b688787b7dbac4605b9c1e4ca55f06dc593d4d84a703435e810a3d0d5b5dfd52e44f34b30dbdf4bb9f3270a4ef3f8891e725d3eb8b0229cece22aab61f2f1663c4bc74427df2a81557c3a604444d48e7f5b0da1a95d5f9b672bbc6552ff316f0cd9eaa08d89380f094754354e34a7f655f98fb077bfa570aa465ff19cbe9f3e30ffeb06f7a5b766223b261c7e542f4ccafbb4310483728013a6d3a9de2521d380b0219dd07d4fbe4ef1fc1070f14dadf929cee2d572a10f3b146a43f9fe0e1e391058f0a9809fb5f88f354b2c4da9a5d8f1f72fa6b9a87ea943cf733c81a6c97504fbdcd38dc1f709d8511c10c4886e3f774d1a21c4deb5cd731384857396fef8375ec38afa0d2557a4fbe5617bd1f4070a613af3cfe6163fb9242e52ddabf0207381b1f50f826eb8f7f0e7c9e2fc3366dc6c623fa5ffcd66577c3fff9fb22bb868460e8d70d71947f9c7233361d05f3cfb5c473fc41f5a535857aaf3585215d340b9e91381f8ff4afb363cde74642a9f45ebc11796acfea427e3b3b14a07b70b45dc9f2c54e2de979886e0264c9b2d07191a229a3a7a2bfc15531727847d0cecc14702be243c7d24b9ff1699265ca3964e6859fc79cc2607d7b35b5f1a895ad758cef853014cea6d41f999d533168f8296d130b00786ff7c95b8ea8b63977a4d96f6b4efde46af51ad72c5f7b59a6dc1e3160db1674c9537751ff4e0c4cf4fc9b54852f089acf25be61874878f8101db552eeedd80c11b3f458dc6cbb6508597ca4133c97d9862ef54f7cf3bbb56aa29cbbdd1b81b29f05fa48776192c09abfa473d5ade5237f86c6fb5ad9aacd2dc38f0cc69e743d4f619e63d07d18c8181c4240184338c9446ec9a70b3a32b9c280f860994a80eb4b6a170d3594efa215719c80c9a7d830f2a9b04f05020f368d6a2245106f7449e8353b6fce22fe6a930084b9ab50502eb968de519d44c278b088e15839ca43740eb23c2ffa3b3f7a084e1bd6928af3fc80d391d38bb25cfa5368393cfe0aa51647ccccf67f4db2ec2fb958d6bfdc16dce31080768cf823c1867e995afbffcff36d7295e39147caf1edba5ba773b5587d519a53e29f27d489731b0a7ad09588e190b37d38156dcd9de1cfcd521cf82f5d0dd91afc62137f8c8b1108a505240f60a686f95479e5892f2c5080fbbbf250f5bd0041282f0a0c06ec7385192110aaca19518cb5f13383c2e10209eb97b18558cfcdc57e5d4c7880deaf15ce924c449c1a86a257750a7aaf4da20bb69627ac9ac5b0ac9b41bbf49ebccb2983ec358e111cf4e2d37d4f706c01894cdce04cf2832160b1b41c25eaabdca3e50c7d68587ac59ffab05dad817c44a8af0ace57e75825e77de284ceba81acbc3744563b9008b41a6ea66b0d646341f9af0590f2f1b0d239a69593e90fad6885525aa02faf39516833f16a50472e66535744be6e4e66bdcc79f6d2786aa4477d87be6a07794182a55de8a9ff783ab4e0de465b1aa032ab1a3d8f66feb8d6b4f32fb9a3781e42650ccae49c634eedf742709412b62f7446e4bd0da4bc7dc4936e1e15bf0ed8e975eb624ef008a2db77dbc10b03a28525fb272bcc852a1a5fc900d7e0e229244fd71ff8073364eef71a0cf09412af7c3599d2f1d300df830972a604bb81e27ace2e893ddbb8ddcf53fd1327bd2528fe4ea67b3bd8c0855a8791369fec9fb6ec2186f9f1820c1736e1da518be9552636298608d717aa26d064e6d861c2db641c088bf2b5f1125ec32bb353923224f654eb96ac637bc210767ea2f5d3dc56a29bb9d4f9f38b02334f9fc5efe4e74fd645bbe547d1462d71a2f1ae8d300421857d0d443b1a52ef9da7865cc3858f59bd62895c01bf4f2385ffb08ca637ab4cdeeebf916b6d48d816d7e3a3659b139ee2eeab6d3285ae7d4454fac18ba6144ed80ce09800fde3beb607c36457ce08c550b9e32f0e37cef4cf8fa972ca83cb2e25fd93bbb047eea3ad943a36c2ec6622d05ffcb9182ebd2ec816037c1cdb36446525c0d1bb3327ec6c272d7692725e9208b768866989f7fe78300119e5fbddb26ef86b3f56a29583706079ab7241a99ba3e8430cbae3c9f260fb3fe667647df79604797f5a883f3006b348333177e3cb19142f50c823688f2906ca1eeaee4d6e9649e98593cefb15fe2d465408fa501e20ed45c01e77638379086e0986957744dcf7a44b42d96b2fd80c00876ce8cb97ad8a7f02d867da5603f4195f0a713a5d0b6a8e6643673b422e2936b3fb7e77f5dac9e012d23e3aee707e6e7d002534b2712237135d17bc4ef09334a4820ec8e4e15da9e657be9deefbaa439ff492205b64dc1c0b19c33f5bb5d88d6ece705cde0c2e37efaf40d475d65cc4a34af042a4954d2a932e5c086bbfb912d31aaacaa0f439287322cdf0c9dcbcda44b576803c6b9423cdbb6e9ce167fd4eb6e3d8a39e7e6340c634b7c40545b3254311fecd7cc1b539bcc273d1f007bf5171dd8f7176594e42f72c27c7235ff1a8c144e4988e3292a057ba5c695c4cb0f7889a3f339b713ccc1d93a33d834bef386f528a6efa54e68cde11c34b78588d2608392d56c7f000d6fd23f7bb73ba55d64c88cdff70543ca0babf7d9db03093f538b8f694d35988b47fb3385fa80db83c14380110f760190e1bc1331fcc46a635004d8139ba45370984542e2d222b542e7fb588708f6f320fee2512f4c942ad11e13de5c2a6d04ac76e53004b7e4b882c1d8782408813516765a0337c77cb1685eef348b2c84006d049734ce5892b05183f38f638be6c88512bffe8a12910586bdbbf1a38ca28ec07024c3818cd370a56c59f86fbc30ec91d8c25695093d85e8b7af068fc91297e92dc916c1d5f97e9b7f7d3293ba8210855e15aaad60d95c26f2b1ae15c804b2b5078e36138bb2ef0d9cae9aafabbaeda46f6402ca793225402bc4728f755c7b90340abf7b24a9670d8d1b006838536582dfb96542441e0d70ba60f6703d2eb4525af468729ca3c9cbd9ff397b58f37618d0b9a71bf39af477710715046f2e18b8e44f9bcacf996bcd79887b32c97247a48f2d0898635c3485d15e69c1156a2ee276278049911ba4383cc769f65e25847dc59d18af0ddfc5d40b1b08494f2dc329830eb79cb154ffb3f957a8fe20de5623d1b6180ed9aec54dea6707fa166a0b7163e134451db7cafc48f05f2aa63a93be0b5767a5429246b9e8281195a4619b981d2b7bbec7c7c3b6c695823e32261b7cce03fa76472c1f7ad6b6b7b7fc34ba223e563f7390cb6e108fbb5be8daf2c675300a9411cefde6a152a41193ac3a0c3dbba020f7dd2b85da4815ad0e07a30f83365c673b8356d733ae29da08d565f8f1855039c85795d360b7426d2223c79aef1e7200ae09385e453aeeb23be2dd0d1174d7073904b17b4697a3855fe658fcaefa9a0b7a25aff603a6ef37339f5171853533cd84eb04c7f5810a01c51aac3ad01b61a684b731b32a90536a78ce0dd5928c20948dc4240828358f79d4ef0ae3639026504674513553fffb6e93e897aaef505042185d3336ef67c29847f65bbf5982870efc59b1228ff0560ca5372fc6ec3b91488d592fc6f49f79788e09abd169f41fae257485b38f6690191ee23ff14b42a67cc8ad64c44b0276be7a4155e7404ffb34801e7c578c82475b5a98553278016c38d0e45ae97f4a6d332fd7b21d3b7220a733f8af670beac4798b8c7b2c69f7c120b76dab3850f818d53ebf629e20cec462b555cc963d32dd0f60d7fd6c740c7744bf5fede97980f70f7e0e01fb5d33b0f48657108121cc8408ab803312ba1d4f64bd4675a26ac020983dc1cb1966aeccc71da3d95e585ed5929b22ff4aa377958fc59b7714c41a3af0ea0f764faef7100aa144d55188eed490782d323e9eda044621ce9879a4d6e0cc7158fdcf75fbfaa1355540c68fb28b0f5a70371b71c4c2eb2b0ad588ad7c27060feec656a5a7acf1a33700f23ee1445fd6b41a792beb1b1538cd515eefbeec5c09ae145ffcd951dc2c48381b0c296a605fea996d636c3c784d548be7eed695508cef3ba5a2b4f7076ee8c9e895906443aaeb6a4227f59f981a10c8da95eef2ae7139fe0a3510db885fb6748bc88e41b28a2b146871481e0fc9160c0524886be896d1a1e76713b0fa50c3f0be1e5613407572a9aa47d2edd9a23a729551ef7c8c24e77a156fbfd0787bfd3e0ce33b98bc33db532dc56ccc744f05f712c704dbe8f084a03180af40bce18c52ede03d7fb049d573c7df298f746f55bb8163943c7ab11781f1f9a986ced5c4f4981eef91517893c912499500f2b7cd6099207826cac7397de1194ee4382731f9ab6183ffd9090636692252fdd12065231faee752b01182ba5a325388d5e15b5387741ab0992a64f77c10829c801e1d5ca179588a99921c22fc24b237e1014de7a085f68b170d2112e80e29e6d800c003bc455b09d83a05fa3d3e4974c9b150297b5504317b5fdcaa7e4cd41a11654c47e57254f2475bec37356cb205895bc48f122a584eafc2f898ac1e0602d80e3f2ed645e21864d80366fc61a951fddcc4ab33fb243ddf06fe40f24d72f16e60882a5b14a5c1fe4ff3608095c7ae506421befd2ec5776b5facaca3133ce24b3a0a93c04534860a232cd70165e73497eae69ef3885a17ffe12b11a49e4f100ddbbb3f37fc176aaa24216be4451ccd5bcb2cfe199d9ed37f484bae9b4da48cfc2bb59beff577901fed2b63686563eff58a8e0d707e27f56bc1b74c69e903beea387976a8bb649dafc10780f3b51bffddd3e141819704dc2ac83985cc816b8f91b74e6be04119aefddaa39abb5e207c58794dec05cb1fe145182fc909415143ace4752a135d15042c18bc04301b4034ec21b7e26d57295c92a29620688b855cb85cafb29f89b69c32e89af71eb0bc9064b073bf22911f0e8cd76387c1772d46c0b5f79c0f565bb57613fb9d924137fa03512fed98548c058f958d2e2c39ecc127901ca847a3e705951fabca654cc54aedb92e649b8967631f4bf705e568bfb322b0190808295a19f3908d644d139b0baf5fdac71a84385af3e51e94241d6d10d3d03e6b49add98e3e1d593d1e5f9b6e5344e5af0503e2d3323d03e8818fc3b66d85e45253959114116e92e1a2a57b027e244a537a62bcf553b7f6f3295f8f145cf73241b3aca01aaa5da6fe37fd54a01fefaf04b7ac74bc8426dd268789a7b741faace6a907008e78e72c034759b83b5cd1c6ef66f6937c2a0c42c68b961dc1b896a7d4486906aef040d94ec131a4e4d298a198efe1125dc7fbf1d1943ebcd07de210240d3a1c8181effde4514b6883650d67830cb069a16f42ce9f83813546794c5b356b2befa94c614a9186dc5b7966cfe98c04937e1b315736aeec390a3890f860478b908de0bcd543d8233cc47bfdd0193af901535a7f4001acf6b64e90ca6f635b90bfa4e59a69d540770ca548133756f7d3c71ed69aa5c428e9085f0ad42240e9bb460fae3018ed876304132eacbafbfdbd86f052a94fc03797da9526f30281a88f608f9a8ac3014b321baf97782b6000567fa16bdcc3639d8779e58c9307a65519d5033ed9e7e2a8ca0dcfb5820a47eac09f2c86b4836d729f5626ac6df901f327dffd04495a43bd09f98b85db0aa574d681b8dbafe9d31970087d7e5d95eff4aae6e27f6922ef49f4c3a3704d60c7be06da5def73b363e7105828dd174671825a0b1b068e403988675b78bbe1a7172e0295ce6e9ba927c3a9a733e96dabd69d6ed174adaf6e9a8863a0df7f8eb954926af7f51c2e8ded5024633ad8c5fe98d87d690bfeba23bf90a4b6b9b2970f06cb29374c3bf7f68a89dce91379c8162e0701f5a02a44c12011ca8152dd0e10ee73a550e707891c65abb7c1d1d3eb9aa8770a4f2c8b5bee92aa0dbfb607af8e16bf205b55024a9c65d7344cc30d42a1a263dfe0dbd4644886d23113eb02a9ff41cd5ef0d50ec34a098c8d79a52557cea481720650ac4ad6e9cea9961d40a75e9433ad5bf0342441cd1d58d033b88827a77972a1ab5e18a3ec513bbdf240e1394c0c9d04913b1fa398c151ea754a65f6cfc3abe30be3adca8afd0fdab76c18f0122f48706ede56a2feb9ed2a535a67d0b5c155d6dc0609e704642bd456cef8937688f92b5487e3c96b7e6d3cb9548432c553db5b6b1c8273106d55235ccbe6a47ae4ba1cd5c39bdf74782fab7135f8b0b1ca291658fe9262bfc01416786fe075c21b1216ae0e879ed31aa75e942373b5c89ffaa4bb46b027f04c3a610925ad2449879fd5b2b6b79b89070c4f0865eae5cb13dfa03c98fb891d35dbdf52fa5f6a42f2af592dac62ed162c1aabc79cd3253e0ce7582500ae5a4fd6fdccfb2295c583bf0134ff6dd628beb17ad5f5b6c58b8ba39392cd59ced362797efdd58c37b2261570db8f55c89fde407b026993435f7bf85957f057494dad87eb5dede82167afedd9b2553b108039949b0873358c8845a20f961feb66eab223d32cec981625b9620e52ed099f61f1bfbc9725f0d8da539d2800cf84b532c1a05178715630dd9bf9a85799cf549ae9355a6a4dbba0a1a0c5bfc35530f681512a5c9f430d4519ba936e5422ca92e8c7937a99e3e2cdb948a2ac0e8ab7ce086a12495b5763b4a55f9b09a7f6a3c39d10e68d2e0c866a351280c462ef5444414dcf34d88e88e37352066356788af4247c030b3ca1e45e654f69d38e35deeed4ae805f27d2bf0e198cf67d4440ff2ac3d6926f14bbc943f3efed3755fda28430d84f0749b65b5a6a6c0343d8a518c9b90c670211dd1a626d7b139114a4ab947420505b0e494e5dbc09652a12f9e567d3ab0516b501ab157f8a4e316acbf48b1d1b199ac30a558f17ea233ae18107191e20e91d0861ba46e8cd7faad4fafd57326558f316c0f24181c24200a7d3d4d2001bf53768bcbcc819b3c3551e7f737236136466f7e3078810d40b2348f88d670ddfb578fc2e1c800ad9f14466426d8f73cc967d18ce3c580e70bf151269f1a83e96d8cadc6e9df7d70811be58e366b5faeefd72f0505a22dc1f301d5b654cd8c3be5771e86da9c491896658414bc094cac8296e5f6b2fe428687a70fa13c8781c0477b5332f384ec96c5936cb074fff515e966e49cc7e48eaf0e19f9395fb4380869ffd12d21389d912b65e2214a549432f347f6ff6d047a102de4776d746ad417702a37e180d7251896f2dd0c0f127fadec9d7c7d51aac63f23a643220b4b5a0df94377e15337fe81f8c48d4236e4a7ddf3ee63cff4463433acd2f3f202568401c105e0e3be9357e003ee39cf82bfe93dca476f0b7413f65a4c90a3fbfe9812a6273dc0868a27af057fb988f1ff86e953e9a73f9e0e648e0cae863fa6d6f1775e79bc00589e22ee34f5be183e365a79719379de54ae0177898957e46c4f4f11ad7952e72569fb0f6e98604232311eeedacae2b51327bb7acd977e518c56eb6853ceafe2c8b380674c3a27e0c56e13bfb21d18f8ff6a1ed656de74914134695a61d89375d9662c2bcd7e7dc2eb0ddd292622697c75b0fb2f934effa5dc78b433501e8abb2ea9c5251eba474eeafbb27c1e461a7cc9da491b6e4e8b9dd0a41c464977f21c61bf7e3118d0e13265dc87076d463c429026d2b66b73fa21ae5171140574e8f89f9af3e7c8ec6822a0fa188498a5a2dca5faf16b50ce3a2c0c60a97b5de130cdace0624db645916e2368bef84bf4d1e3283e4e48a93d6d7ed469e6dd749db39bb899fabc85f5cac3375f4b8d009e015b3e5c9090ec8479e6c04ddb397467bba5820cd678f6dd84b539445f517a9e51ebd2b7c670d8891a752817536f8f64ff846820ee317826f6f4c1bb4acb9910f9347ebd9fd0f02520a988c311896f19945ed2f655ce7eb7414d70d9695183cfe43ab011357563bc12322ed9d3604b3db7bf52d1de5185853abebbb9efcdc91e94c3d611480f6931287b20f50d8c1ade5c9398d084ecb9c073b724fec020e44293879c8cd73fc29356d30dd345f187e7a0742663c8dd32e070d3dfc31ec087fe5d45af2fc403d8fcdf926312d4ab736cb36787f35e881bf08c3948ec58d01f1a9d9e7bd0b3607e4ca749b57ed1e1ef74e5d7a881062a05047bb85b9d867051d3cf749f4611b6302acec751e1eda262259dcbf0f6b7191a0432efdfff36a0542c9ab18a3098c8f70863695a82b071aaa88514576e1565046d396325cefa6ca469bb6a3c12eada5c34b4123000a7a24f9726d5245b281d18e05c469be23d2b241f5ab482385a58686ba732f49979d589202008ac3b4bf2bbc3e3e128bd854851a7e9e19a669d918baf531cab7f79d55a9c4a6fc89b4e5c931adeec0866e43de08a77611158f119820d4dca4af9f2e44108b6be8e0acfbb619b2edd2d6af98b5696b16f7ac07230baa048b3644dcbf4194329b31b19afea98632024c8a4d049051e1f940217ba2c5d362eeeb1c36829ecf9fbdd55ba27b3fd6eec74ba1e0eb72cf1975a16eb476db33fdc16abbcc3fa811ce510b620aa51009741186c97ab496543d1737126b55d4089119a4ebbfee68d73d5fb644da68e42e0f29e3accc88f566eabfb01c5dae1835357d108ae698c490b38be042fa6e2beabe0b067e5e1ea1c73d3e7b0f3ec902ed069cc878c980d7c96a040f0cc5ae803b990cdc2c280695e4275e440af0c7d6a955e5ac4a63c5da09b3687c58806699fb8eaff277fb1e1a09a28fbaa7f00581ce95672ff3b5cb5249ea34c4b84b62c8933833c0f5c723c43eab38989d28a4711629b51c64ba24248352129b7d01e373e11417196023717b7567476093ab91ec9ae02219e681009f3d6280103d997c8523f08c1ea03dde4fd401b40fad129b54dd4e01c40e508ac1c65559f4cfd33a1df49fd53ff71bd117aa232a5681c4e684c21d73360e7ca0df99c28766760f0fe2d712526dc4a0a4ab69970ad74f46b3558267ac59e0d1e3fec300b1e9373a1520e0b3d94cfb48261e1c3be1134bb9e3342c464d5f71d76a02f83015180e460d297011651d2a28eecb9d4423afe674db6b19fafdb9de116cc899ff828768ba6bf7cfdacc32366c8c6a5ddf804aa0f7cd4a698a0cfc3595991b8198b39db8f256579330d1de8f81f627645f9f49ecb83cb3ee1dc0b7507c76a4b1b78559769266270660642104bc78b219f2770607f99feda1aca7efdb8c5a3bcbc236a02c1960df82614efe417f495aa47e9c27091c9784d439862a779fe73ae30edaf82bb925b2db5e58f82f63b52950d553b18022318cbb64cc6f8b050f15c46d5c8d886f34232df0e7ead115222d744e055092d56bc02d3464a42f9f354887d9af6871869580feb8e2608fbd719c14f91d6596903da0665d17bb111bbadfa5466480610057996aafbbd237913ef9f72db9db3235f7191d8e44dbd864fc6c27324d61376aa564c5eb1bd171bdeb666438c048c735f01f002f7e6502fdb4fb762db8ef93aabee945e9b1cc8403b2eb21a81c0c90ea49d9fc154b24d61a045eac3fd2fc48d7ac1c6a591a81c9744412785197f1191fe4bea09b396ec90dd835cda4b14ae62e2e95f51a4b6f50046f37b59f7c8eb27ed71393b9f3facdc03235e6f472e513fefeaa18a4442f4c1f23dc3ced19ade2b6460fe798b614740549caf6441f2de682b2bf2376441a688f882236b0848810a399e0e34199fec31b47706364453db77b8f46a4694f565c5e4932c952ec7bafe7183636b905f439b1a2fb2f163f10e834d76240835e34802577e5f083b74d1ee60898511745f5d9feef8dea20cb65e85a393d56600b885abf7af4f61cac8620211d0271328969856ad874931da5aa5b23e81e2576890932d79701975afc70aa4a7a6b856f4f0e3f795117906da48a597da3985cb08a13a4e13525d13a6caa42fdd8b3eba64bd697bac145e6d5b7badfce7fdce784cad67ebabfda2f29e820d81950dccd85617cfec40da329b63cb445e46995cd415633e0da28dcc895735455e6407cd316d154902106d582b6336b06928942282f5bac528c9835a6cb7a01fc66106301cde6ffaaad88d59d2adf7f7880cb502402796ddd86c38f65bb6300abab8c9a198e6b673b2fe2ef639ccf0eddd0a7c65db10c136b90bb2528f647ee1dd948e93725137cf8b1aa52969290244ee297662caca954aeeb8aedd3c7e2179384d1e80a2572b08bd8ecbcd32db2482b203fd6a0a4f0e34eb932195ab52f8e21b5b66137cd5f0f5e778e046009c5e9687a362f0951ec6cf02cb8d87218ee73d0e2efbfbb6f6b07c49e4c8a9ac1b3f2c2c9eb3814b16df97ac201675489281f658c8a720fbe49d96a44398386eef93e1beb74184cbf0b357d7d5e2909c0ad5ac021a609194b02759502bfc2529456abf18a1f588ff360feeba31729f7e011ba183a1d91b0cbf188f73544b19b36093886bbc21cddc38700f14aac16117ec80591fee257ad410c3c0d1c9be142adf7977a69bfc78e0ad0cc578cb59d8e5dc69956c2bc3d35598cbfc9e4db4dd9f256bd148c5934182e3e885701a083c9cb264794969c8bf6c9e6babcb18aebd44711c76b7930aa1b6e8a3103217c04d0ef80667d1e2678e1684bde9d69ef1986088eddcb15e321c3ef9427aacf91d4f7cc298d638058996fb6042d971e9e2dcdffaa1de5ea876d88c58401fc2ea42f9ec5a96635cafa293c3d002bf6ee862244d22284c365258be8fdb3f3d7fde27087b454a1ed5ff28c90ab939bbe451621120213b6adb994d356f2670a079bc5af83d2ab7a44f3523f698c052abe7d3f70703af63a22cfd97d092bb9b3c50c1ce3567b5b30cee29d81edd74b847d6dc6b370b4326980a123710b7c5f2d42353adca32c2a3215ebfd69d7091c57faf9421dd3de7d12d9251f9699aa0b15d6318bbe1bc2631e1adf331e0b978128b6f17148ba35e811b1616d29c2a904b5ab9b00c464fcb546a88192de535a350e9aee5f6c6644c56ea93cb071cba17cf76f602666864e73252799f93db137d430ced3ef6edc0631ca103965918498ee931c6bb75adc0e999b081e93707d852ba4ea5424aa29fa878033424c74acd6274d981ee0d85fe1dd3dadac4f0c490cbab35c37229f69b59c014a911564d67e8705259125a3851d2aab16432aa6046552ba4bc8238f02aa008e935d107bca7cfc9e4f7747635bd2e912cb8eac7f801b353258ba64f3eb887d80d2af7dfe68ea6a95b3cb18363241e3b1591ff9b8e1cb73ce52b29caed21e1883251ccc36e5899edddad3b07d580e98bd61a72edc03814acc8be4912a1b56e52c2ae8aaaabef8ac65be402dbae706857091f76359c87e2ff1b2bc570914380babbf31a1e248b63a5f3d1feca93a634411d4f9c1999fe681bfc6ec517bd7f3e06985df397a003ba9fd4e2bbec787</script>\n</div>\n<script src=\"/code/lib/blog-encrypt.js\"></script><link href=\"/code/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h1 id=\"Week-9-DLC\"><a class=\"header-anchor\" href=\"#Week-9-DLC\"></a>Week 9 DLC</h1><h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\"></a>前言</h2><p>有些內容筆者本來想要放在這週的授課內容中<br>不過一來是筆者的期中快要爆炸，沒有空做簡報<br>另一方面由於授課內容偏難，放在影片中可能會讓影片長度暴增（像是變成三個小時）<br>因此決定另外寫一篇文章來當作補充內容，並且發在自己的部落格</p><a id=\"more\"></a><h2 id=\"線段樹-Extra\"><a class=\"header-anchor\" href=\"#線段樹-Extra\"></a>線段樹 Extra</h2><h3 id=\"持久化\"><a class=\"header-anchor\" href=\"#持久化\"></a>持久化</h3><h4 id=\"老樣子開始前先看個題目\"><a class=\"header-anchor\" href=\"#老樣子開始前先看個題目\"></a>老樣子開始前先看個題目</h4><blockquote><p>給定一個長度為 $N$ 的序列，並且有 $M$ 條指令，指令內容如下</p><ol><li>修改其中一個元素的值</li><li>查詢查詢區間 $[l, r]$ 內的最大值</li><li>回復到第 k 次修改後的狀態</li></ol><p>$N, M \\le 10 ^ 5, k \\le$ 當前修改次數, $0 \\le l, r \\lt N$</p></blockquote><p>1, 2 都還是基本的線段樹，那麼 3 呢</p><p>感覺可以每修改一次就開一顆新的線段樹，要回朔就複製回去</p><p>所以需要開到 $M$ 棵線段樹，所以要開 $4NM$ 的記憶體…先 MLE 了<br>再看一下時間複雜度：$O(M(N + \\log N))$ （先複製一遍 $O(N)$，再做單點修改 $O(\\log N)$，最糟糕要執行 $M$ 次）<br>從各種方面來看感覺都不會過</p><h4 id=\"先觀察一下\"><a class=\"header-anchor\" href=\"#先觀察一下\"></a>先觀察一下</h4><p>對於每次修改，會修改到的地方只有從根節點到要修改的點的路徑而已<br>也就是說 <strong>其他節點沿用舊的資料也沒關係</strong></p><blockquote><p>這邊記得放結構圖</p></blockquote><p>但是用陣列寫就要另外維護節點編號，從實作上來說是幾乎不可能達成的事<br>看來我們需要換個想法</p><h4 id=\"Hmmm，指標？\"><a class=\"header-anchor\" href=\"#Hmmm，指標？\"></a>Hmmm，指標？</h4><p>沒錯，就是指標<br>只要紀錄記憶體位置就好，不用把整個 node 都複製過去</p><p>所以現在線段樹要改成指標版本</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\tnode *l, *r;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode ( <span class=\"keyword\">int</span> _val ): l ( <span class=\"literal\">nullptr</span> ), r ( <span class=\"literal\">nullptr</span> ), value ( _val ) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">up</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">\t\tvalue = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( l )</span><br><span class=\"line\">\t\t\tvalue = max ( value, l -&gt; value );</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( r )</span><br><span class=\"line\">\t\t\tvalue = max ( value, r -&gt; value );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; *seg = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, node *&amp;o )</span></span>&#123;</span><br><span class=\"line\">\to = <span class=\"keyword\">new</span> node ( <span class=\"number\">0</span> );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\tbuild ( l, mid, o -&gt; l );</span><br><span class=\"line\">\tbuild ( mid + <span class=\"number\">1</span>, r, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\to -&gt; up();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, node *&amp;o )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">\t\to -&gt; value = value;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( index &lt;= mid )</span><br><span class=\"line\">\t\t\tupdate ( l, mid, index, value, o -&gt; l );</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tupdate ( mid + <span class=\"number\">1</span>, r, index, value, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\to -&gt; up();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, node *o )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l &lt;= nowR &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o -&gt; value;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> query ( l, r, nowL, mid, o -&gt; l );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> max ( query ( l, r, nowL, mid, o -&gt; l ), query ( l, r, mid + <span class=\"number\">1</span>, nowR, o -&gt; r ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, l, r, in, type;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">\tbuild ( <span class=\"number\">1</span>, n, seg );</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">\t\tupdate ( <span class=\"number\">1</span>, n, i, in, seg );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// type 1: 單點修改</span></span><br><span class=\"line\">\t<span class=\"comment\">// type 2: 區間查詢最大值</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; type;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; in;</span><br><span class=\"line\">\t\t\tupdate ( <span class=\"number\">1</span>, n, l, in, seg );</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, seg ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"持久化-v2\"><a class=\"header-anchor\" href=\"#持久化-v2\"></a>持久化</h4><p>因為要保留舊版本，所以對所有需要被修改的節點新開一個位置來<br>並且把左右子結點的指標，指向原本左右子結點的位置</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\tnode *l, *r;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode ( <span class=\"keyword\">int</span> _val ): l ( <span class=\"literal\">nullptr</span> ), r ( <span class=\"literal\">nullptr</span> ), value ( _val ) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 新增一個建構子，可以直接複製原本的 l, r</span></span><br><span class=\"line\">\tnode ( node *o ): l ( o -&gt; l ), r ( o -&gt; r ), value ( o -&gt; value ) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">up</span> <span class=\"params\">( <span class=\"keyword\">void</span> )</span></span>&#123;</span><br><span class=\"line\">\t\tvalue = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( l )</span><br><span class=\"line\">\t\t\tvalue = max ( value, l -&gt; value );</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( r )</span><br><span class=\"line\">\t\t\tvalue = max ( value, r -&gt; value );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; *seg = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, node *&amp;o )</span></span>&#123;</span><br><span class=\"line\">\to = <span class=\"keyword\">new</span> node ( <span class=\"number\">0</span> );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\tbuild ( l, mid, o -&gt; l );</span><br><span class=\"line\">\tbuild ( mid + <span class=\"number\">1</span>, r, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\to -&gt; up();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> value, node *&amp;o )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 把需要修改的節點在修改前先開一個新位置出來</span></span><br><span class=\"line\">\to = <span class=\"keyword\">new</span> node ( o );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l == r )</span><br><span class=\"line\">\t\to -&gt; value = value;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid = ( l + r ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( index &lt;= mid )</span><br><span class=\"line\">\t\t\tupdate ( l, mid, index, value, o -&gt; l );</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tupdate ( mid + <span class=\"number\">1</span>, r, index, value, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\to -&gt; up();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span> <span class=\"params\">( <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> nowL, <span class=\"keyword\">int</span> nowR, node *o )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( l &lt;= nowR &amp;&amp; nowR &lt;= r )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o -&gt; value;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> mid = ( nowL + nowR ) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( r &lt;= mid )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> query ( l, r, nowL, mid, o -&gt; l );</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( mid &lt; l )</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> query ( l, r, mid + <span class=\"number\">1</span>, nowR, o -&gt; r );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> max ( query ( l, r, nowL, mid, o -&gt; l ), query ( l, r, mid + <span class=\"number\">1</span>, nowR, o -&gt; r ) );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n, m, l, r, in, type;</span><br><span class=\"line\">    <span class=\"comment\">// 紀錄版本用的 vector</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span> &lt; node* &gt; version;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">\tbuild ( <span class=\"number\">1</span>, n, seg );</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">\t\tupdate ( <span class=\"number\">1</span>, n, i, in, seg );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 記錄初始版本</span></span><br><span class=\"line\">\tversion.push_back ( seg );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// type 1: 單點修改</span></span><br><span class=\"line\">\t<span class=\"comment\">// type 2: 區間查詢最大值</span></span><br><span class=\"line\">\t<span class=\"comment\">// type 3: 回朔到版本 k</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ( m-- )&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; type;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( type == <span class=\"number\">1</span> )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; in;</span><br><span class=\"line\">\t\t\tupdate ( <span class=\"number\">1</span>, n, l, in, seg );</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 修改完紀錄版本</span></span><br><span class=\"line\">\t\t\tversion.push_back ( seg );</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( type == <span class=\"number\">2</span> )&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; query ( l, r, <span class=\"number\">1</span>, n, seg ) &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 回朔到版本 k</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cin</span> &gt;&gt; in;</span><br><span class=\"line\">\t\t\tseg = version[in];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h5 id=\"有修改過的地方\"><a class=\"header-anchor\" href=\"#有修改過的地方\"></a>有修改過的地方</h5><table><thead><tr><th>line</th><th>修改內容</th></tr></thead><tbody><tr><td>12</td><td>新增一個建構子，可以直接複製原本的 l, r</td></tr><tr><td>36</td><td>在對節點修改前先開一個新的位置</td></tr><tr><td>69</td><td>記錄用的 vector</td></tr><tr><td>77, 88</td><td>修改完成後，記錄當前版本內容</td></tr><tr><td>94</td><td>新增一個操作，可回朔到版本 k</td></tr></tbody></table><h3 id=\"非簡單操作線段樹\"><a class=\"header-anchor\" href=\"#非簡單操作線段樹\"></a>非簡單操作線段樹</h3><h4 id=\"我們還是看個題目\"><a class=\"header-anchor\" href=\"#我們還是看個題目\"></a>我們還是看個題目</h4><blockquote><p>現在給定一個長度為 $N$ 序列，以及 $M$ 筆操作，操作內容有</p><ol><li>修改一個元素的值</li><li>查詢區間中最長的「好序列」長度</li></ol><p>定義一個「好區間」為：每個元素都是前一個元素 + 1</p><p>這邊是一個題目叫大龍貓的濃縮版，完整版題目可以看 <a href=\"http://toj.tfcis.org/oj/pro/365/\" target=\"_blank\" rel=\"noopener\">這邊</a></p></blockquote><p>現在有點麻煩了，RMQ 我們會，但是這種該怎麼用線段樹實作</p><p>我們可以在 node 中紀錄目前最長的好序列長度，以及其開始位置以及結束位置<br>每次合併兩個區間就取兩邊紀錄的最長好序列的最大值</p><p>Emmm，但是感覺好像怪怪的<br>如果合併兩個區間後，交界處那邊形成一個更長的好序列，怎麼辦？</p><p>尷尬，那我們只好在每個 node 也記錄從開頭處到結束處的好序列了</p><p>聽起來很複雜，但是其實一點也不</p><p>為了方便編寫，我們先定義一個 piece，還有如何辨識兩個 piece 是否相同</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">piece</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l, r, sz;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 檢查兩個 piece 是否相同</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> == ( <span class=\"keyword\">const</span> piece b )&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> l == b.l &amp;&amp; r == b.r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不想寫 operator（或是覺得太麻煩）可以這樣寫</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">same</span> <span class=\"params\">( piece a, piece b )</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a.l == b.l &amp;&amp; a.r == b.r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>$l, r$ 就是這個區間的左右界<br>$sz$ 是大小，可有可無，只是寫 code 上方便</p><p>然後是 node</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    piece front, back, ma;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>$front, back$ 分別為是記錄當前線段樹區間內，從左邊界開始的好序列長度，以及從右邊屆開始的好序列長度<br>$ma$ 則是記錄當前線段樹區間內，最長的好序列長度</p><p>接著來寫合併兩個區間的函數吧，因為沒有內建的函數可以用，只能自己寫一下</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">merge</span> <span class=\"params\">( node L, node R )</span></span>&#123;</span><br><span class=\"line\">    node res;</span><br><span class=\"line\">\tres.front = L.front, res.back = R.back, res.ma = ( L.ma.sz &gt; R.ma.sz ? L.ma : R.ma );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( basic[L.back.r] + <span class=\"number\">1</span> == basic[R.front.l] )&#123;</span><br><span class=\"line\">\t\tpiece swp = piece &#123; L.back.l, R.front.r, R.front.r - L.back.l + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( L.front == L.back )</span><br><span class=\"line\">\t\t\tres.front = swp;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( R.front == R.back )</span><br><span class=\"line\">\t\t\tres.back = swp;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tres.ma = ( swp.sz &gt; res.ma.sz ? swp : res.ma );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>合併兩個區間後，要回傳的 res 內容如下</p><table><thead><tr><th>res 內的 piece</th><th>來源</th></tr></thead><tbody><tr><td>front</td><td>l.front</td></tr><tr><td>back</td><td>r.back</td></tr><tr><td>ma</td><td><a href=\"http://l.ma\" target=\"_blank\" rel=\"noopener\">l.ma</a>, <a href=\"http://r.ma\" target=\"_blank\" rel=\"noopener\">r.ma</a>, l.back + r.back 這三者中的最長好序列</td></tr></tbody></table><h2 id=\"後記\"><a class=\"header-anchor\" href=\"#後記\"></a>後記</h2><p>這篇文章寫的也挺久的，主要是文中的內容大部分都不常用到，在寫的時候還跑去翻了一些文章</p><p>正因如此，內容上可能有些錯誤，如有發現，請聯絡 <a href=\"https://miohitokiri5474.github.io/code/about/\">筆者</a></p><!-- rebuild by neat -->","encrypt":true},{"title":"[UVA][00459]GRAPH CONNECTIVITY","date":"2017-12-27T10:49:17.000Z","_content":"\n## 題目 & 解法\n\n[原題目網址](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=400)\n\n簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。\n\n喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）\n<!--more-->\n\n最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\\le 26$) 所以就直接用 set 了\n\n後來發現。。。就算重複了也無仿啊 = =\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\ntypedef long long LL;\n\n// define tools\n#define REPP(i,f,s) for ( int i = f ; i < s ; i++ )\n#define REPALL(i,n) for ( auto &i: n )\n#define MEM(n,i) memset ( n, i, sizeof n )\n\ntypedef set < int > si;\n#define CLR(n) n.clear()\n\n#define GL(n) getline ( cin, n )\n\nsi edge[30];\nbool go[30];\n\ninline void dfs ( int n ){\n    go[n] = true;\n    REPALL ( i, edge[n] )\n        if ( !go[i] )\n            dfs ( i );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str;\n    int n, u, v, ans, cnt = 0, t;\n    cin >> t;\n    t++;\n    while ( t-- ){\n        GL ( str );\n        MEM ( go, 0 );\n        REPP ( i, 0, 30 )\n            CLR ( edge[i] );\n\n        n = str[0] - 'A';\n        ans = 0;\n        while ( GL ( str ) ){\n            if ( EMP ( str ) )\n                break;\n\n            u = str[0] - 'A', v = str[1] - 'A';\n            edge[u].insert ( v );\n            edge[v].insert ( u );\n        }\n\n        n++;\n        REPP ( i, 0, n )\n            if ( !go[i] ){\n                ans++;\n                dfs ( i );\n            }\n\n        if ( !cnt++ )\n            continue;\n        if ( cnt++ > 2 )\n            cout << '\\n';\n\n        cout << ans << \"\\n\";\n    }\n}\n```","source":"_posts/uva00459.md","raw":"---\ntitle: '[UVA][00459]GRAPH CONNECTIVITY'\ndate: 2017-12-27 18:49:17\ntags:\n - UVa\n - graph\n - dfs\n---\n\n## 題目 & 解法\n\n[原題目網址](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=400)\n\n簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。\n\n喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）\n<!--more-->\n\n最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\\le 26$) 所以就直接用 set 了\n\n後來發現。。。就算重複了也無仿啊 = =\n\n\n## code\n\n```cpp\n// by. MiohitoKiri5474\n#include<bits/stdc++.h>\n\n#pragma GCC optimize ( \"O3\" )\n#pragma loop_opt ( on )\n\nusing namespace std;\n\ntypedef long long LL;\n\n// define tools\n#define REPP(i,f,s) for ( int i = f ; i < s ; i++ )\n#define REPALL(i,n) for ( auto &i: n )\n#define MEM(n,i) memset ( n, i, sizeof n )\n\ntypedef set < int > si;\n#define CLR(n) n.clear()\n\n#define GL(n) getline ( cin, n )\n\nsi edge[30];\nbool go[30];\n\ninline void dfs ( int n ){\n    go[n] = true;\n    REPALL ( i, edge[n] )\n        if ( !go[i] )\n            dfs ( i );\n}\n\nint main(){\n    ios::sync_with_stdio ( false );\n    cin.tie ( 0 );\n    cout.tie ( 0 );\n\n    string str;\n    int n, u, v, ans, cnt = 0, t;\n    cin >> t;\n    t++;\n    while ( t-- ){\n        GL ( str );\n        MEM ( go, 0 );\n        REPP ( i, 0, 30 )\n            CLR ( edge[i] );\n\n        n = str[0] - 'A';\n        ans = 0;\n        while ( GL ( str ) ){\n            if ( EMP ( str ) )\n                break;\n\n            u = str[0] - 'A', v = str[1] - 'A';\n            edge[u].insert ( v );\n            edge[v].insert ( u );\n        }\n\n        n++;\n        REPP ( i, 0, n )\n            if ( !go[i] ){\n                ans++;\n                dfs ( i );\n            }\n\n        if ( !cnt++ )\n            continue;\n        if ( cnt++ > 2 )\n            cout << '\\n';\n\n        cout << ans << \"\\n\";\n    }\n}\n```","slug":"uva00459","published":1,"updated":"2020-05-03T11:24:07.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9qzbct0000xxl9pdtw0drkv","content":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=400\" target=\"_blank\" rel=\"noopener\">原題目網址</a></p><p>簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。</p><p>喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）</p><a id=\"more\"></a><p>最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\\le 26$) 所以就直接用 set 了</p><p>後來發現。。。就算重複了也無仿啊 = =</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// define tools</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REPP(i,f,s) for ( int i = f ; i &lt; s ; i++ )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REPALL(i,n) for ( auto &amp;i: n )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MEM(n,i) memset ( n, i, sizeof n )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; si;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CLR(n) n.clear()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GL(n) getline ( cin, n )</span></span><br><span class=\"line\"></span><br><span class=\"line\">si edge[<span class=\"number\">30</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> go[<span class=\"number\">30</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    go[n] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    REPALL ( i, edge[n] )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !go[i] )</span><br><span class=\"line\">            dfs ( i );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, u, v, ans, cnt = <span class=\"number\">0</span>, t;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    t++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        GL ( str );</span><br><span class=\"line\">        MEM ( go, <span class=\"number\">0</span> );</span><br><span class=\"line\">        REPP ( i, <span class=\"number\">0</span>, <span class=\"number\">30</span> )</span><br><span class=\"line\">            CLR ( edge[i] );</span><br><span class=\"line\"></span><br><span class=\"line\">        n = str[<span class=\"number\">0</span>] - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( GL ( str ) )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( EMP ( str ) )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            u = str[<span class=\"number\">0</span>] - <span class=\"string\">'A'</span>, v = str[<span class=\"number\">1</span>] - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            edge[u].insert ( v );</span><br><span class=\"line\">            edge[v].insert ( u );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        REPP ( i, <span class=\"number\">0</span>, n )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !go[i] )&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                dfs ( i );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !cnt++ )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( cnt++ &gt; <span class=\"number\">2</span> )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"excerpt":"<!-- build time:Sun May 03 2020 19:36:01 GMT+0800 (Taipei Standard Time) --><h2 id=\"題目-解法\"><a class=\"header-anchor\" href=\"#題目-解法\"></a>題目 &amp; 解法</h2><p><a href=\"https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=400\" target=\"_blank\" rel=\"noopener\">原題目網址</a></p><p>簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。</p><p>喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）</p>","more":"<p>最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\\le 26$) 所以就直接用 set 了</p><p>後來發現。。。就算重複了也無仿啊 = =</p><h2 id=\"code\"><a class=\"header-anchor\" href=\"#code\"></a>code</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// by. MiohitoKiri5474</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> GCC optimize ( <span class=\"meta-string\">\"O3\"</span> )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> loop_opt ( on )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> LL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// define tools</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REPP(i,f,s) for ( int i = f ; i &lt; s ; i++ )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> REPALL(i,n) for ( auto &amp;i: n )</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MEM(n,i) memset ( n, i, sizeof n )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">set</span> &lt; <span class=\"keyword\">int</span> &gt; si;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CLR(n) n.clear()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GL(n) getline ( cin, n )</span></span><br><span class=\"line\"></span><br><span class=\"line\">si edge[<span class=\"number\">30</span>];</span><br><span class=\"line\"><span class=\"keyword\">bool</span> go[<span class=\"number\">30</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span> <span class=\"params\">( <span class=\"keyword\">int</span> n )</span></span>&#123;</span><br><span class=\"line\">    go[n] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    REPALL ( i, edge[n] )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !go[i] )</span><br><span class=\"line\">            dfs ( i );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::sync_with_stdio ( <span class=\"literal\">false</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>.tie ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, u, v, ans, cnt = <span class=\"number\">0</span>, t;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; t;</span><br><span class=\"line\">    t++;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( t-- )&#123;</span><br><span class=\"line\">        GL ( str );</span><br><span class=\"line\">        MEM ( go, <span class=\"number\">0</span> );</span><br><span class=\"line\">        REPP ( i, <span class=\"number\">0</span>, <span class=\"number\">30</span> )</span><br><span class=\"line\">            CLR ( edge[i] );</span><br><span class=\"line\"></span><br><span class=\"line\">        n = str[<span class=\"number\">0</span>] - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ( GL ( str ) )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( EMP ( str ) )</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            u = str[<span class=\"number\">0</span>] - <span class=\"string\">'A'</span>, v = str[<span class=\"number\">1</span>] - <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            edge[u].insert ( v );</span><br><span class=\"line\">            edge[v].insert ( u );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        REPP ( i, <span class=\"number\">0</span>, n )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( !go[i] )&#123;</span><br><span class=\"line\">                ans++;</span><br><span class=\"line\">                dfs ( i );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !cnt++ )</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( cnt++ &gt; <span class=\"number\">2</span> )</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; ans &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"}],"PostAsset":[{"_id":"source/_posts/APCS-19-06/img.jpg","slug":"img.jpg","post":"ck9qzbcsc0006xl9php5lb5yb","modified":1,"renderable":0},{"_id":"source/_posts/GCJ-2019-QuR/pB.jpg","post":"ck9qzbcsg000axl9pahg355ej","slug":"pB.jpg","modified":1,"renderable":1},{"_id":"source/_posts/GCJ-2019-QuR/scb.jpg","post":"ck9qzbcsg000axl9pahg355ej","slug":"scb.jpg","modified":1,"renderable":1},{"_id":"source/_posts/APCS-19-06/per.png","post":"ck9qzbcsc0006xl9php5lb5yb","slug":"per.png","modified":1,"renderable":1},{"_id":"source/_posts/APCS-19-06/score.png","post":"ck9qzbcsc0006xl9php5lb5yb","slug":"score.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"ck9qzbcrq0000xl9phik32wvv","tag_id":"ck9qzbcs50004xl9pb99qgnvh","_id":"ck9qzbcsp000jxl9p9ihw84r5"},{"post_id":"ck9qzbcrq0000xl9phik32wvv","tag_id":"ck9qzbcse0008xl9pdu2qbq1s","_id":"ck9qzbcsq000lxl9peq6j10il"},{"post_id":"ck9qzbcrq0000xl9phik32wvv","tag_id":"ck9qzbcsh000bxl9pfa0lbmkb","_id":"ck9qzbcsr000oxl9pdu5fgsdk"},{"post_id":"ck9qzbcrq0000xl9phik32wvv","tag_id":"ck9qzbcsk000exl9pf6290rds","_id":"ck9qzbcsu000qxl9p7hyu1339"},{"post_id":"ck9qzbcs10002xl9pc18rciho","tag_id":"ck9qzbcs50004xl9pb99qgnvh","_id":"ck9qzbct1000zxl9pg87xd4vr"},{"post_id":"ck9qzbcs10002xl9pc18rciho","tag_id":"ck9qzbcsq000mxl9phazo1nkj","_id":"ck9qzbct20010xl9p5vre4dg6"},{"post_id":"ck9qzbcs10002xl9pc18rciho","tag_id":"ck9qzbcsv000sxl9pa3ofc0xc","_id":"ck9qzbct20012xl9p6ua3hkvg"},{"post_id":"ck9qzbcs10002xl9pc18rciho","tag_id":"ck9qzbcsy000vxl9phg0ahrxe","_id":"ck9qzbct30013xl9p90qw17nx"},{"post_id":"ck9qzbcs70005xl9p02a47hut","tag_id":"ck9qzbct1000yxl9pai35fx1o","_id":"ck9qzbct30015xl9pgcaefic8"},{"post_id":"ck9qzbcsc0006xl9php5lb5yb","tag_id":"ck9qzbct20011xl9pa0mfew1j","_id":"ck9qzbct40017xl9phi8kh9lq"},{"post_id":"ck9qzbcsc0006xl9php5lb5yb","tag_id":"ck9qzbct30014xl9p9bx5gvil","_id":"ck9qzbct40018xl9p3cm39tq3"},{"post_id":"ck9qzbcsd0007xl9p91cq9v1v","tag_id":"ck9qzbcs50004xl9pb99qgnvh","_id":"ck9qzbct6001cxl9p22bhhgf4"},{"post_id":"ck9qzbcsd0007xl9p91cq9v1v","tag_id":"ck9qzbcsq000mxl9phazo1nkj","_id":"ck9qzbct7001dxl9p25qc53ys"},{"post_id":"ck9qzbcsd0007xl9p91cq9v1v","tag_id":"ck9qzbct30014xl9p9bx5gvil","_id":"ck9qzbct7001fxl9p7wdic3bw"},{"post_id":"ck9qzbcsd0007xl9p91cq9v1v","tag_id":"ck9qzbct5001axl9p2pylgacy","_id":"ck9qzbct7001gxl9p090a3w4z"},{"post_id":"ck9qzbcsf0009xl9pa11w10b4","tag_id":"ck9qzbct6001bxl9phd06exq5","_id":"ck9qzbct8001ixl9pd1zw8d4e"},{"post_id":"ck9qzbcsf0009xl9pa11w10b4","tag_id":"ck9qzbct7001exl9p62pi2wdk","_id":"ck9qzbct8001jxl9p7c1z8qsz"},{"post_id":"ck9qzbcsg000axl9pahg355ej","tag_id":"ck9qzbct7001hxl9pfbes5e39","_id":"ck9qzbcta001mxl9pce650rd8"},{"post_id":"ck9qzbcsg000axl9pahg355ej","tag_id":"ck9qzbct30014xl9p9bx5gvil","_id":"ck9qzbcta001nxl9p3rml33w8"},{"post_id":"ck9qzbcsh000cxl9pfgah96pn","tag_id":"ck9qzbct6001bxl9phd06exq5","_id":"ck9qzbctb001qxl9p1hmb5576"},{"post_id":"ck9qzbcsh000cxl9pfgah96pn","tag_id":"ck9qzbct7001exl9p62pi2wdk","_id":"ck9qzbctb001rxl9p3pmwhu82"},{"post_id":"ck9qzbcsj000dxl9pe0fj4efv","tag_id":"ck9qzbct6001bxl9phd06exq5","_id":"ck9qzbctd001uxl9p9m5p1e7v"},{"post_id":"ck9qzbcsj000dxl9pe0fj4efv","tag_id":"ck9qzbct7001exl9p62pi2wdk","_id":"ck9qzbctd001vxl9p9wfy08s3"},{"post_id":"ck9qzbcsk000fxl9p7xuk7c9h","tag_id":"ck9qzbct6001bxl9phd06exq5","_id":"ck9qzbcte001yxl9p51za9nd6"},{"post_id":"ck9qzbcsk000fxl9p7xuk7c9h","tag_id":"ck9qzbcsv000sxl9pa3ofc0xc","_id":"ck9qzbcte001zxl9pfbbpa7x6"},{"post_id":"ck9qzbcsl000gxl9pain010a9","tag_id":"ck9qzbcte001xxl9pgennamxt","_id":"ck9qzbctf0021xl9p4yzb5lg9"},{"post_id":"ck9qzbcsl000gxl9pain010a9","tag_id":"ck9qzbcsh000bxl9pfa0lbmkb","_id":"ck9qzbctf0022xl9per5a95m9"},{"post_id":"ck9qzbcsm000ixl9pa201augf","tag_id":"ck9qzbcte001xxl9pgennamxt","_id":"ck9qzbctg0024xl9p8ozzeoi7"},{"post_id":"ck9qzbcsm000ixl9pa201augf","tag_id":"ck9qzbcsh000bxl9pfa0lbmkb","_id":"ck9qzbctg0025xl9pel7lflyt"},{"post_id":"ck9qzbcsp000kxl9p1onw7u55","tag_id":"ck9qzbcte001xxl9pgennamxt","_id":"ck9qzbcti002axl9p0a306wac"},{"post_id":"ck9qzbcsp000kxl9p1onw7u55","tag_id":"ck9qzbctg0026xl9pcq7p7nl8","_id":"ck9qzbcti002bxl9p982aez44"},{"post_id":"ck9qzbcsp000kxl9p1onw7u55","tag_id":"ck9qzbcth0027xl9p09iq6u7f","_id":"ck9qzbctj002dxl9p120o13o7"},{"post_id":"ck9qzbcsp000kxl9p1onw7u55","tag_id":"ck9qzbct5001axl9p2pylgacy","_id":"ck9qzbctj002exl9pbeag1tlc"},{"post_id":"ck9qzbcsq000nxl9p1vtbapif","tag_id":"ck9qzbcte001xxl9pgennamxt","_id":"ck9qzbctj002gxl9p9xks5ter"},{"post_id":"ck9qzbcsq000nxl9p1vtbapif","tag_id":"ck9qzbcsv000sxl9pa3ofc0xc","_id":"ck9qzbctj002hxl9p5twm3uch"},{"post_id":"ck9qzbcsr000pxl9pgpf0fzzu","tag_id":"ck9qzbcte001xxl9pgennamxt","_id":"ck9qzbctl002oxl9pe2qgg537"},{"post_id":"ck9qzbcsr000pxl9pgpf0fzzu","tag_id":"ck9qzbctj002ixl9p8w0rf330","_id":"ck9qzbctl002pxl9pe4tmhdkl"},{"post_id":"ck9qzbcsr000pxl9pgpf0fzzu","tag_id":"ck9qzbctk002jxl9pgvk8f77m","_id":"ck9qzbctm002rxl9p17ef580q"},{"post_id":"ck9qzbcsr000pxl9pgpf0fzzu","tag_id":"ck9qzbcsy000vxl9phg0ahrxe","_id":"ck9qzbctm002sxl9p46oscn8m"},{"post_id":"ck9qzbcsr000pxl9pgpf0fzzu","tag_id":"ck9qzbctk002lxl9p3n62bz2a","_id":"ck9qzbctm002uxl9pbciy12wp"},{"post_id":"ck9qzbcsr000pxl9pgpf0fzzu","tag_id":"ck9qzbctl002mxl9p5jfr2v5i","_id":"ck9qzbctm002vxl9p9kchcyxg"},{"post_id":"ck9qzbcsv000rxl9p4nbp4bsz","tag_id":"ck9qzbctk002jxl9pgvk8f77m","_id":"ck9qzbctn002xxl9p1xx58oeh"},{"post_id":"ck9qzbcsv000rxl9p4nbp4bsz","tag_id":"ck9qzbctl002qxl9p6i7e1g8u","_id":"ck9qzbctn002yxl9p96415bip"},{"post_id":"ck9qzbcsv000rxl9p4nbp4bsz","tag_id":"ck9qzbcsk000exl9pf6290rds","_id":"ck9qzbctn0030xl9p3axbdwfx"},{"post_id":"ck9qzbcsw000txl9p3i78h0vv","tag_id":"ck9qzbctm002txl9p9t5n6ptr","_id":"ck9qzbctn0031xl9p4ct6ctgj"},{"post_id":"ck9qzbcsy000uxl9pc6w79928","tag_id":"ck9qzbctm002wxl9pal383v56","_id":"ck9qzbcto0033xl9p70hj08q0"},{"post_id":"ck9qzbcsy000uxl9pc6w79928","tag_id":"ck9qzbct30014xl9p9bx5gvil","_id":"ck9qzbcto0034xl9p224f8kvw"},{"post_id":"ck9qzbcsz000wxl9p6nppdtvo","tag_id":"ck9qzbctn0032xl9p1hljfjpy","_id":"ck9qzbctp0037xl9ph1n99qmw"},{"post_id":"ck9qzbcsz000wxl9p6nppdtvo","tag_id":"ck9qzbcto0035xl9pagzt78v8","_id":"ck9qzbctp0038xl9ph8s50jsz"},{"post_id":"ck9qzbct0000xxl9pdtw0drkv","tag_id":"ck9qzbcto0036xl9p3w0kbziw","_id":"ck9qzbctp0039xl9pe9wu74g6"},{"post_id":"ck9qzbct0000xxl9pdtw0drkv","tag_id":"ck9qzbcsv000sxl9pa3ofc0xc","_id":"ck9qzbctp003axl9pboxcch5k"},{"post_id":"ck9qzbct0000xxl9pdtw0drkv","tag_id":"ck9qzbcsy000vxl9phg0ahrxe","_id":"ck9qzbctp003bxl9pc2pg1vvw"}],"Tag":[{"name":"CodeForces","_id":"ck9qzbcs50004xl9pb99qgnvh"},{"name":"Education Round","_id":"ck9qzbcse0008xl9pdu2qbq1s"},{"name":"segment tree","_id":"ck9qzbcsh000bxl9pfa0lbmkb"},{"name":"data structure","_id":"ck9qzbcsk000exl9pf6290rds"},{"name":"div.3","_id":"ck9qzbcsq000mxl9phazo1nkj"},{"name":"graph","_id":"ck9qzbcsv000sxl9pa3ofc0xc"},{"name":"dfs","_id":"ck9qzbcsy000vxl9phg0ahrxe"},{"name":"C","_id":"ck9qzbct1000yxl9pai35fx1o"},{"name":"APCS","_id":"ck9qzbct20011xl9pa0mfew1j"},{"name":"Full Contest Solution","_id":"ck9qzbct30014xl9p9bx5gvil"},{"name":"dp","_id":"ck9qzbct5001axl9p2pylgacy"},{"name":"TIOJ","_id":"ck9qzbct6001bxl9phd06exq5"},{"name":"math","_id":"ck9qzbct7001exl9p62pi2wdk"},{"name":"GCJ","_id":"ck9qzbct7001hxl9pfbes5e39"},{"name":"TOJ","_id":"ck9qzbcte001xxl9pgennamxt"},{"name":"ZJ","_id":"ck9qzbctg0026xl9pcq7p7nl8"},{"name":"全國賽","_id":"ck9qzbcth0027xl9p09iq6u7f"},{"name":"MST","_id":"ck9qzbctj002ixl9p8w0rf330"},{"name":"dsu","_id":"ck9qzbctk002jxl9pgvk8f77m"},{"name":"樹直徑","_id":"ck9qzbctk002lxl9p3n62bz2a"},{"name":"Kruskal","_id":"ck9qzbctl002mxl9p5jfr2v5i"},{"name":"disjoint set","_id":"ck9qzbctl002qxl9p6i7e1g8u"},{"name":"Golang","_id":"ck9qzbctm002txl9p9t5n6ptr"},{"name":"ITSA","_id":"ck9qzbctm002wxl9pal383v56"},{"name":"Data Structure","_id":"ck9qzbctn0032xl9p1hljfjpy"},{"name":"Segment Tree","_id":"ck9qzbcto0035xl9pagzt78v8"},{"name":"UVa","_id":"ck9qzbcto0036xl9p3w0kbziw"}]}}