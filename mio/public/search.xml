<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[APCS] 2019年十月場實作題詳解]]></title>
    <url>%2Fcode%2FAPCS-19-10%2F</url>
    <content type="text"><![CDATA[前言因為上次差一題觀念就5 + 5，加上為了以後家教做準備，所以還是去考了成績unknow，這次是在考完當天就動筆寫了 因為這次比較晚報名，所以我是在台南大學考的，不是成大老樣子又assume考場沒換，等到了之後才發現換了 = =所以又急急忙忙的跑過去好險有趕到 免責聲明：因為code都是出了考場後才寫的，手邊沒有測資，所以並不保證在rewrite的過程中沒有出bug problem 1題目原題目太長，以下是濃縮版本 給定一序列，假設有任意 $|Arr[i]-Arr[i - 1]| > 5$ 則把 $Arr[i]$ 改成前三項的中位數（前三項不用改） 解法我是暴力做一下啦，詳細可以看code code123456789101112131415161718192021222324252627282930// by.MiohitoKiri5474#includeusing namespace std;#define pb push_backint main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n; cin >> n; vector < int > data ( n ), lib; for ( auto &i: data ) cin >> i; for ( int i = 3 ; i < n ; i++ ){ if ( abs ( data[i] - data[i - 1 ] ) > 5 ) lib.clear(); for ( int j = 0 ; j < 3 ; j++ ) lib.pb ( data[i - j] ); sort ( lib.begin(), lib.end() ); data[i] = lib[1]; } for ( auto i: data ) cout < i < m; vector < int > data ( n ), option ( m ), a, b; for ( auto &i: data ) cin >> i; for ( auto &i: option ) cin >> i; reverse ( option.begin(), option.end() ); for ( auto op: option ){ a.clear(), b.clear(); if ( op == 1 ){ for ( int i = 0 ; i < n ; i++ ) if ( i & 1 ) b.pb ( data[i] ); else a.pb ( data[i] ); data = a; for ( auto i: b ) data.pb ( i ); } else if ( op == 2 ){ int aidx = 0, bidx = 0; for ( int i = 0 ; i < n / 2 ; i++ ) a.pb ( data[i] ); for ( int i = n / 2 ; i < n ; i++ ) b.pb ( data[i] ); data.clear(); for ( int i = 0 ; i < n ; i++ ) if ( i & 1 ) data.pb ( b[bidx++] ); else data.pb ( a[aidx++] ); } else{ for ( int i = 0 ; i < n - op ; i++ ) a.pb ( data[i] ); for ( int i = n - op ; i < n ; i++ ) b.pb ( data[i] ); data = b; for ( auto i: a ) data.pb ( i ); } } for ( auto i: data ) cout < i < p >> l >> r; data.resize ( n ); for ( auto &i: data ) cin >> i; cout < dfs ( > p >> l >> r; vector < int > data ( n ); for ( auto &i: data ) cin >> i; for ( int i = 0 ; i < n ; i++ ){ if ( i - l >= 0 ) edges[i].pb ( i - l ); if ( i + r < n ) edges[i].pb ( i + r ); } queue < int > q; memset ( dis, INF, sizeof dis ); q.push ( 0 ); dis[0] = 0; inQ[0] = true; while ( !q.empty() ){ inQ[now = q.front()] = false; q.pop(); for ( auto i: edges[now] ){ if ( dis[i] > dis[now] + 1 ){ dis[i] = dis[now] + 1; if ( !inQ[i] ){ inQ[i] = true; q.push ( i ); } if ( dis[data[i]] > dis[i] ){ dis[data[i]] = dis[i]; if ( !inQ[data[i]] ){ inQ[data[i]] = true; q.push ( data[i] ); } } } } } cout < dis[p] <]]></content>
      <tags>
        <tag>APCS</tag>
        <tag>Full Contest Solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C語言中 char 字串轉換成數字]]></title>
    <url>%2Fcode%2FC-atoi%2F</url>
    <content type="text"><![CDATA[前言今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字 方法 使用內建函數atoi 自己寫 內建函數的用法可以去cpprefrence查到，所以這邊就不解說了只有講自己寫的做法 原理如果要在一個數字的尾端加上一位數，該如何操作？有一種方法：先把原數字 * 10，然後再把那一位數加上去所以就可以有下面這種code 123456789int translate ( char *c, int len ){ int i, res = 0; for ( i = 0 ; i < len ; i++ ){ res *= 10; res += ( c[i] - '0' ); } return res;} 然後解說一下code中第五行char之間的相減就是ASCii code的值的差所以可以用這種方法把原本的數字還原出來]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[APCS] 2019年六月場實作題詳解]]></title>
    <url>%2Fcode%2FAPCS-19-06%2F</url>
    <content type="text"><![CDATA[前言因為想要拼5 + 5，於是又報名了這次的APCS至於成績如何那就晚點再說吧，算是個小伏筆（？ 即便考場在家附近，我還是提早出門了還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎趕快google一下才發現跑錯棚了，應該是在校區的另一邊所以我又趕快跑過去，差一點點遲到好險有提早出門（汗 problem 1題目給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節求出主場最終的輸贏 兩場全贏：勝 兩場全敗：敗 一勝一敗：平手 保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題 解法直接實作一下就好了 code1234567891011121314151617181920212223242526272829303132333435363738394041// by. MiohitoKiri5474#includeusing namespace std;int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int a = 0, b = 0, ans = 0, swp; for ( int i = 0 ; i < 4 ; i++ ){ cin >> swp; a += swp; } for ( int i = 0 ; i < 4 ; i++ ){ cin >> swp; b += swp; } ans += ( a > b ? 1 : -1 ); a = b = 0; for ( int i = 1 ; i < 4 ; i++ ){ cin >> swp; a += swp; } for ( int i = 1 ; i < 4 ; i++ ){ cin >> swp; b += swp; } ans += ( a > b ? 1 : -1 ); if ( !ans ) cout < 0 ) cout < mp[i][j] ) mi = mp[i][j], x = i, y = j; } cout < dfs ( x, y, > m; for ( int i = 0 ; i < m ; i++, c++ ) basic += c; while ( n-- ){ cin >> str; // 這邊為了要把順序都統一，所以先做一下排序 sort ( str.begin(), str.end() ); // 這邊則是要把重複的字元壓掉 str.erase ( unique ( str.begin(), str.end() ), str.end() ); lib[str]++; } for ( auto j: lib ){ str = basic; // 把出現過的直接刪掉 for ( auto i: j.F ) str.erase ( lower_bound ( str.begin(), str.end(), i ) ); ans += j.S * lib[str]; } // 因為會重複計算到兩次 ans /= 2; cout < ans < m; for ( int i = 0 ; i < m ; i++ ) ori |= ( 1 < i );> str; // 這邊為了要把順序都統一，所以先做一下排序 sort ( str.begin(), str.end() ); // 這邊則是要把重複的字元壓掉 str.erase ( unique ( str.begin(), str.end() ), str.end() ); lib[translate ( str )]++; } for ( auto j: lib ) ans += ( j.S * lib[ori ^ j.F] ); // 因為會重複計算到兩次 ans >>= 1; cout < ans < n >> m; vector < int > data ( n ), lib; for ( auto &i: data ) cin >> i; // 離散化 lib = data; sort ( lib.begin(), lib.end() ); lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() ); for ( auto &i: data ) i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin(); queue < int > q; set < int > s; for ( int i = 0 ; i < n ; i++ ){ q.push ( data[i] ); s.insert ( data[i] ); cnt[data[i]]++; if ( q.size() >= m ){ cnt[q.front()]--; if ( !cnt[q.front()] ) s.erase ( q.front() ); q.pop(); } if ( s.size() == m ) ans++; } cout < ans < n >> m; vector < int > data ( n ), lib; for ( auto &i: data ) cin >> i; // 離散化 lib = data; sort ( lib.begin(), lib.end() ); lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() ); for ( auto &i: data ) i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin(); // 這邊的話就不用set了 queue < int > q; for ( int i = 0 ; i < n ; i++ ){ // 不斷pop直到這個數字前面沒有出現過 while ( !q.empty() && cnt[data[i]] ){ cnt[q.front()]--; q.pop(); } q.push ( data[i] ); cnt[data[i]]++; if ( q.size() == m ) ans++; } cout < ans <]]></content>
      <tags>
        <tag>APCS</tag>
        <tag>Full Contest Solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Code Jam 2019 Qualification Round]]></title>
    <url>%2Fcode%2FGCJ-2019-QuR%2F</url>
    <content type="text"><![CDATA[前言我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了 只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了下一場是在這週六晚上九點～十一點半撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走 總之，過 Qualification Round 應該就算比去年好了去年在耍廢直接爆炸。。。 希望今年可以去 Round 2 先放上這次的題目連結 problem A題目現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$多筆測資 解法顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$一臉就是在跟你說開 string 存啊所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$然後把這兩個數字輸出注意不能有前導零 code123456789101112131415161718192021222324252627282930313233// by. MiohitoKiri5474#includeusing namespace std;int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int t, mi; string n; cin >> t; for ( int tms = 1 ; tms]]></content>
      <tags>
        <tag>Full Contest Solution</tag>
        <tag>GCJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TIOJ][1909] 勇者出征]]></title>
    <url>%2Fcode%2FTIOJ-1909%2F</url>
    <content type="text"><![CDATA[題目原題目連結據說是 2015TOI 三模的題目簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有： 從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個 假設 $D$ 可以連結到 $A$ 的話（$D的高度 \lt A$），那麼$A$也可以到 $D$ 求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號如果有多組解，輸出編號最小的 解法我們先來釐清一下什麼是簡單路徑好了所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑 建圖看到路徑，我第一個想到的是圖論我們先想一下，要怎麼把圖建出來 暴力 $O ( N^2 )$$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較12345678910111213141516171819202122232425#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )for ( int i = 0 ; i < n ; i++ ){ int l = -1, r = n; for ( int j = i - 1 ; j >= 0 ; j-- ) if ( data[j] > data[i] ){ l = j; break; } for ( int j = i + 1 ; j < n ; j++ ) if ( data[j] > data[i] ){ r = j; break; } if ( l == -1 && r == n ) continue; if ( l == -1 ){ UNI ( r, i, edges ); continue; } if ( r == n ){ UNI ( l, i, edges ); continue; } UNI ( ( data[l] < data[r] ? l : r ), i, edges );} 線段樹 $O ( NlogN )$然後我就想到線段樹了$index$ 是做離散化後的數字，$value$ 是編號然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值一開始右手邊的最小值線段樹，裡面有$N$個點每處理完一個點，就把這個點拔掉丟到左邊去code大概像這樣123456789101112131415161718192021222324252627282930313233343536#define UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )#define INF 0x3f3f3f3f// function// 線段樹1是紀錄最小值、右手邊的線段樹// 而線段數2是紀錄最大值、左手邊的線段樹int seg1[maxN <]]></content>
      <tags>
        <tag>graph</tag>
        <tag>TIOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF]Round 521]]></title>
    <url>%2Fcode%2FCFR521%2F</url>
    <content type="text"><![CDATA[前言身為一個垃圾，當然要打的像垃圾一樣先是校內爆掉，現在換 div.3 爆掉。。。pC 沒開 long long 溢位被 hack 成智障的就是我坐等晚上 rating change沒意外應該會噴掉啦 先放上所有題目的連結 problem A題目大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正） 解法阿不就直接暴力就好算一下會往左次往右幾次，算一下就好 code1234567891011121314151617181920212223// by. MiohitoKiri5474#includeusing namespace std;typedef long long LL;int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); #define int LL int t, k, a, b, swp, ans; cin >> t; while ( t-- ){ cin >> a >> b >> k; swp = a - b; ans = swp * ( LL ) ( k / 2 ); if ( k & 1 ) ans += a; cout < ans < n; vector < int > data ( n ), lib; for ( auto &i: data ) cin >> i; for ( int i = 1 ; i < n - 1 ; i++ ){ if ( !data[i] && data[i - 1] && data[i + 1] ) lib.push_back ( i ); } m = lib.size(); while ( lib.size() > 1 ){ if ( lib[1] - lib[0] == 2 ){ ans++; lib.erase ( lib.begin() ); lib.erase ( lib.begin() ); } else{ ans++; lib.erase ( lib.begin() ); } } if ( !lib.empty() ) ans++; cout < ans < n; vector < int > data ( n ), ans; for ( auto &i: data ){ cin >> i; sum += i; lib[i]++; } for ( int i = 0 ; i < n ; i++ ){ sum -= data[i]; if ( sum & 1 ){ sum += data[i]; continue; } sum >>= 1; if ( ( lib[sum] == 1 && sum != data[i] ) || lib[sum] > 1 ){ ans.push_back ( i + 1 ); } sum]]></content>
      <tags>
        <tag>Full Contest Solution</tag>
        <tag>CodeForces</tag>
        <tag>div.3</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TIOJ][1615] A! + B! problem]]></title>
    <url>%2Fcode%2FTIOJ-1615%2F</url>
    <content type="text"><![CDATA[前言好久沒有寫 code 發題解了最近因為一些事情沒有時間（也沒有心情）認真寫 code（因為上次 CodeForces 連續掉分我心情有點糟）（啊還有學科校內爆炸也是我心情糟的原因之一）（開始懷疑我到底這一年努力是為了什麼，之類的）然後今天想說寫個題目、發個題解刷一下存在感，之類的所以跑去 TIOJ 翻題目然後看到這題。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼 題目 & 解法大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數原網址我放在這 很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數因為要加一，所以我想了很久感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）但是我真的沒有想法所以就寫了個 $O ( N^2 )$ 的解法。。。然後過了，wtf就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查就這樣。。。我一臉懵逼的坐在電腦前傻了一下才開始動手打這篇文章 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// by. MiohitoKiri5474#includeusing namespace std;typedef long long LL;#define maxN 1000000bitset < maxN > lib;vector < LL > prime;int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); #define int LL lib[0] = lib[1] = true; for ( int i = 2 ; i < maxN ; i++ ){ if ( !lib[i] ){ prime.push_back ( i ); for ( int j = i ; j < maxN ; j += i ) lib[j] = true; } } int a, b, len = prime.size(); LL ans, stp; while ( cin >> a >> b ){ if ( a > b ) swap ( a, b ); ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin(); stp = 1; for ( int i = a + 1 ; i]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ITSA] No.66 詳解]]></title>
    <url>%2Fcode%2Fitsa-66%2F</url>
    <content type="text"><![CDATA[前言簡單來說就是我特殊選才的資料不夠所以只好來打這東西，不然備審有夠空QQ problem 1題目這題就是給你一行整數（數量不定，但是保證 < 11個）求該行出現率「超過」一半的整數 解法看到數量不定就會用 getline + stringstream，這很直觀然後因為他只有說「給整數」，並沒有限制數字大小所以我是用 map 做，而不是陣列（出現負數就尷尬了）雖然比較慢但是也比較無腦 為什麼我會在題目那把「超過」加上引號？。。。因為我在寫 code 的時候耍智障把判斷式寫成 >=然後我就吃 WA 了我還跑去問如果有多組解怎麼辦結果超過一半的數字只會有一個QQ還有把 NO 打成 No就多吃兩個 penalty 了，虧爆抓到，澪人桐不會寫程式 code123456789101112131415161718192021222324252627282930313233343536// by. MiohitoKiri5474#includeusing namespace std;map < int, int > lib;int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); string str; int in, cnt; bool ans; while ( getline ( cin, str ) ){ lib.clear(); cnt = 0; ans = false; stringstream ss ( str ); while ( ss >> in ){ lib[in]++; cnt++; } for ( auto i: lib ){ if ( i.S > cnt / 2 ){ cout < i.F <]]></content>
      <tags>
        <tag>Full Contest Solution</tag>
        <tag>ITSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Disjoint Set 並查集]]></title>
    <url>%2Fcode%2Fdsu%2F</url>
    <content type="text"><![CDATA[上一篇blog因為介紹並查集的地方太多了，文章太長所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了然後會在昨天文章上加入這篇的連結 disjoint set 並查集我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了 這個時候大概會寫出像這樣的 code 12345678910111213141516171819202122232425// disjoint set#includeusing namespace std;#define maxN 10005int dis[maxN];inline void init ( void ){ for ( int i = 0 ; i < maxN ; i++ ) dis[i] = i;}inline int find ( int n ){ return dis[n] == n ? dis[n] : find ( dis[n] );}inline void Union ( int a, int b ){ dis[a] = b;}inline bool same ( int a, int b ){ return find ( a ) == find ( b );} 路徑壓縮我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰下次就可以直接略過中間的點，直接到老大那了 find 函數會被改成這樣親民寫法：12345void find ( int n ){ if ( dis[n] == n ) return n; return dis[n] = find ( n );} 然後就是會有人（例如我），會想要把它寫在一起所以就變成這樣了XD123void find ( int n ){ return dis[n] == n ? n : dis[n] = find ( dis[n] );} 最後這個東西的複雜度會變成均攤 $O ( \log N )$，感覺還不錯 避免 Stack Overflow最最最後有個東西也挺重要的因為路徑壓縮還是要按照這個點的遍歷往上爬又是用遞迴實作所以有機會會戳到 Stack overflow然後你就吃 RE 了恭喜多一個 penalty重點是你不知道這樣會吃到 Stack overflow 然後就會多吃幾個w 雖然說現在很多 judge 都避免掉了啦會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大只是難免會戳到那種舊型 judge所以還是乖乖學一下怎麼避免 Stack overflow 吧 要壓縮遞迴深度，可以有兩種方法 方法一：random在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦 1234inline void Union ( int a, int b ){ dis[a] = b; find ( rand() % n );} 方法二：Union by rank把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈理論上這樣應該不會爆炸，因為深度很平均 12345678int rk[maxN];inline void Union ( int a, int b ){ if ( rk[a] < rk[b] ) swap ( a, b ); dis[b] = a; rk[b] = rk[a] + 1 ;} 這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數至於那是啥我也不知道，只知道幾乎可以算是常數了 不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用 方法三：Union by size這也挺直觀的把大小比較小的並查集接在大的下面比較小，需要做改動的點就比較少，對吧 12345678int sz[maxN];inline void Union ( int a, int b ){ if ( sz[a] > sz[b] ) swap ( a, b ); dis[a] = b; sz[b] += sz[a];} 如果開優化還是爛了呢通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size再爛掉。。。這應該是叫你去寫啟發式合併吧據說那東西比並查集還要快不過我也沒有實作過，所以我並不清楚 確認是否屬於同一個並查集確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內 123inline bool same ( int a, int b ){ return find ( a ) == find ( b )} 用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了 後記我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =現在看了一下，我光 dsu 就寫 171 行了@@覺得累]]></content>
      <tags>
        <tag>data structure</tag>
        <tag>dsu</tag>
        <tag>disjoint set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][420] C. 藏寶圖]]></title>
    <url>%2Fcode%2FTOJ-420%2F</url>
    <content type="text"><![CDATA[今天來講講自己出的題目好了這題是我在今年（2018）六月時排名賽出的題目搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ 題目先附上原題目網址 題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑MST 怎麼做？我這邊選用 Kruskal（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal） 先備知識在提 Kruskal 前，我們先講講 MST 到底是什麼吧 最小生成樹MST 的正式全名為「最小生成樹」所謂的生成樹就是把這張圖拔掉一些邊後，這張圖沒有環以及所有點都有聯通也就是說：假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有剛好一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹 而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T’$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹 樹直徑那麼樹直徑又是什麼呢？通常樹直徑就是一棵樹上的任意點對的最長距離 作法Kruskal我先講講Kruskal是什麼好了 按照MST的定義，有個很直觀的想法 先按照邊的權重對於所有邊由小到大排序過 依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中 至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)詳細內容可以看這篇 樹直徑樹直徑作法通常有兩個： dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑 先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案 作法1還挺好瞭解的，只是實作上可能會出包作法2有點費時間，但是很好寫 code總而言之，我的 code 長這樣是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// by. MiohitoKiri5474#includeusing namespace std;#define maxN 1000005typedef pair < int, int > pii;typedef long long LL;#define pb push_back#define F first#define S secondstruct node{ int u, v, w;};inline bool cmp ( node a, node b ){ return a.w < b.w;}int dis[maxN];LL dist[maxN];vector < node > edges;vector < pii > mst[maxN];inline void init ( void ){ for ( int i = 0 ; i < maxN ; i++ ) dis[i] = i;}int find ( int n ){ return dis[n] == n ? n : dis[n] = find ( dis[n] );}inline void Union ( int a, int b ){ dis[find ( a )] = find ( b );}inline bool same ( int a, int b ){ return find ( a ) == find ( b );}inline void Kruskal ( void ){ sort ( edges.begin(), edges.end(), cmp ); for ( auto &i: edges ){ if ( same ( i.u, i.v ) ) continue; Union ( i.u, i.v ); mst[i.u].pb ( pii ( i.v, i.w ) ); mst[i.v].pb ( pii ( i.u, i.w ) ); }}void dfs ( int n, int p ){ // 樹直徑 for ( auto i: mst[n] ){ if ( i.F == p ) continue; dist[i.F] = dist[n] + i.S; dfs ( i.F, n ); }}int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, u, v, w, t, idx, now; LL ma = -1; cin >> n >> m; init(); while ( m-- ){ cin >> u >> v >> w; edges.pb ( node { u, v, w } ); } Kruskal(); dfs ( 0, -1 ); for ( int i = 0 ; i < n ; i++ ) if ( ma < dist[i] ) ma = dist[i], idx = i; dist[idx] = 0; dfs ( idx, -1 ); ma = -1; for ( int i = 0 ; i < n ; i++ ) ma = max ( ma, dist[i] ); cout < ma <]]></content>
      <tags>
        <tag>dfs</tag>
        <tag>TOJ</tag>
        <tag>dsu</tag>
        <tag>MST</tag>
        <tag>樹直徑</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][407] D. 警力配置]]></title>
    <url>%2Fcode%2FTOJ-407%2F</url>
    <content type="text"><![CDATA[又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =別再給我增加工作量啊垃圾我還要把舊站的文章搬過來改成 md 檔啊 = = 題目我先附上連結 題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長 注意：至少有一個 $\to$ 有兩個也沒關係 這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫（但是不小心撈到73分，我問號） 解法很顯然的要先轉成一張圖，這絕對是圖論 = =也就是說題意可以被化簡成這樣：給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到。。。啊不就匈牙利既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下這篇然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法 因為這題真的是裸題（？）所以我就直接附 code 了 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// by. MiohitoKiri5474#includeusing namespace std;#define pb push_back#define maxN 200005vector < int > edges[maxN];int match[maxN], visit[maxN], turn;inline bool dfs ( int n ){ visit[n] = turn; for ( auto i: edges[n] ){ if ( match[i] == -1 || ( visit[match[i]] != turn && dfs ( match[i] ) ) ){ match[i] = n; match[n] = i; return true; } } return false;}int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int t, m, u, v, p, q, ans; cin >> t; while ( t-- ){ ans = 0; memset ( match, -1, sizeof match ); for ( auto &i: edges ) i.clear(); cin >> p >> q >> m; while ( m-- ){ cin >> u >> v; v += p; edges[u].pb ( v ); edges[v].pb ( u ); } p += q; for ( int i = 0 ; i]]></content>
      <tags>
        <tag>graph</tag>
        <tag>TOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF][999E] E. REACHABILITY FROM THE CAPITAL]]></title>
    <url>%2Fcode%2FCF-999E%2F</url>
    <content type="text"><![CDATA[題目 + 解法這是 CodeForces Round 490 div.3 的題目最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人沒有意外下一場應該就會下來了吧先放上題目連結 會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打） 講一下題目大意好了首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ） 有個很直觀的想法如下，首先點會先被分成兩種類型： 這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過 沒有經過的點（從 $S$ 出發到達不了） 所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧） code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// by. MiohitoKiri5474#include#pragma GCC optimize ( "O3" )#pragma loop_opt ( on )using namespace std;#define maxN 5005vector < int > edges[maxN];int pa[maxN];bool used[maxN];void dfs ( int n, int p ){ used[n] = true; pa[n] = p; for ( auto i: edges[n] ){ if ( used[i] ) continue; dfs ( i, p ); }}int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, s, u, v; cin >> n >> m >> s; while ( m-- ){ cin >> u >> v; edges[u].push_back ( v ); } dfs ( s, s ); for ( int i = 1 ; i]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>div.3</tag>
        <tag>graph</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][406] C. 軍隊部署]]></title>
    <url>%2Fcode%2FTOJ-406%2F</url>
    <content type="text"><![CDATA[題目老樣子先放連結TOJZJ這是去年（106年）全國學科能力競賽資訊科全國賽的pC分類上算是水題一枚（按照去年整體難度來說） 題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊 解法所以如果我們先不看種族，我們先看能力就好，可以看成： 第一位：是否對空，是為 $1$，否為 $0$ 第二位：是否範圍，是為 $1$，否為 $0$ 第三位：是否遠距，是為 $1$，否為 $0$ 所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$ 接著是種族，有三種族，所以代號為$1, 2, 3$ 那麼來做dp陣列的規劃吧$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能 然後要求是三種族、三功能都要有，所以那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族 呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想看 code 可能會比較好瞭解，我 code 放下面 code123456789101112131415161718192021222324252627// by. MiohitoKiri5474#includeusing namespace std;long long dp[5][10];int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); long long n, x, y, z, w, ans = 0; cin >> n; for ( int i = 0 ; i < n ; i++ ){ cin >> w >> x >> y >> z; dp[w][x * 4 + y * 2 + z]++; } for ( int i = 0 ; i < 8 ; i++ ) for ( int j = 0 ; j < 8 ; j++ ) for ( int k = 0 ; k < 8 ; k++ ) if ( ( i | j | k ) == 7 ) ans += dp[1][i] * dp[2][j] * dp[3][k]; cout < ans <]]></content>
      <tags>
        <tag>dp</tag>
        <tag>TOJ</tag>
        <tag>ZJ</tag>
        <tag>全國賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CF][920F] F. SUM AND REPLACE]]></title>
    <url>%2Fcode%2FCF-920F%2F</url>
    <content type="text"><![CDATA[前言好久沒有發題解了，今天心血來潮來寫一篇吧今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pFpF，感覺很難？其實還好， 因為這是 Education 題目不管，翻譯下題目好了，畢竟原題是英文的要原題連結的在這 給定一個長度為N的序列，並有兩種輸入要處理： 對區間 $l, r$ 做操作 $D$（等等寫在下面） 查詢區間和 操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 $\{1, 2, 3, 6\}$，共四個） 解法嗯。。。區間操作？區間和？怎麼看都是線段樹，但是問題是：操作因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\sqrt{N}$，證明我等等再打 好，我們先觀察一下： 只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變） 越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果 接著是最後一個問題：該如何處理區間操作對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）不過有種做法叫找收斂點（終止點） 剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\ge 2$ 的數字當作是否繼續進行操作的依據 到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看這篇 不過大概算了一下，這樣需要開到$8\times N$的記憶體，感覺會 MLE所以我先拿區間和開刀，如果當前區間和 $\ge 2\times range（區間大小）$ 再繼續進行操作。。。然後我就 WA 了，請想想如果當前區間內元素為 $\{ 1, 1, 1, 3 \}$ 的時候 有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\ge 2$ 本來不想要開第二顆線段樹，到頭來還不是開了 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// by. MiohitoKiri5474#includeusing namespace std;typedef long long LL;#define maxN 300005LL sum[maxN < > 1, leftSon = n < r; if ( type == 1 ) modify ( l, r, 1, n, 1 ); else cout < query ( l, r,]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>Education Round</tag>
        <tag>segment tree</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][391] E. 模數 CANDY]]></title>
    <url>%2Fcode%2FTOJ-391%2F</url>
    <content type="text"><![CDATA[題目 & 解法我先附上題目連結簡單來說，就是區間取餘數然後這東西可以用線段樹實作 然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法在寫區間開根號的時候，我們用的是區間最大值線段樹，是的，區間最大值 理由很簡單，因為開根號開到最後，一定會朝向$1$收斂所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧 同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數這應該算是一種剪枝（吧 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// by. MiohitoKiri5474#include#pragma GCC optimize ( "O3" )#pragma loop_opt ( on )using namespace std;#define maxN 200005int seg[maxN < > 1, leftSon = n < m; while ( m-- ){ cin >> type; if ( type == 1 ){ cin >> l >> r; update ( 0, n, r, l, 1 ); } else if ( type == 2 ){ cin >> l >> r >> x; modify ( l, r, 0, n, x, 1 ); } else cout < seg[]]></content>
      <tags>
        <tag>segment tree</tag>
        <tag>TOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TIOJ][1795] 咕嚕咕嚕呱啦呱啦]]></title>
    <url>%2Fcode%2FTIOJ-1795%2F</url>
    <content type="text"><![CDATA[這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧 題目題目連結在這 給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$另外，任意一條邊的權重只有可能為 $0 or 1$ 解法只要做出最小生成樹以及最大生成樹就好了，證明如下假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則： ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\le k\e ub$ 的生成樹 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// by. MiohitoKiri5474#includeusing namespace std;typedef long long LL;#define maxN 100005struct bridge{ int u, v, w;};struct disjionSet{ int dis[maxN]; inline void Init ( void ){ for ( int i = 0 ; i < maxN ; i++ ) dis[i] = i; } inline int find ( int n ){ return dis[n] == n ? n : dis[n] = find ( dis[n] ); } inline bool same ( int a, int b ){ return find ( a ) == find ( b ); } inline void Union ( int a, int b ){ dis[find ( a )] = find ( b ); }};vector < bridge > edges;inline bool cmp ( bridge a, bridge b ){ return a.w < b.w;}int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); int n, m, k, u, v, w, ub = 0, lb = 0; disjionSet dis; cin >> n >> m >> k; while ( m-- ){ cin >> u >> v >> w; edges.push_back ( bridge { u, v, w } ); } sort ( edges.begin(), edges.end(), cmp ); dis.Init(); for ( auto i: edges ){ if ( dis.same ( i.u, i.v ) ) continue; dis.Union ( i.u, i.v ); lb += i.w; } reverse ( edges.begin(), edges.end() ); dis.Init(); for ( auto i: edges ){ if ( dis.same ( i.u, i.v ) ) continue; dis.Union ( i.u, i.v ); ub += i.w; } cout < ( lb]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVA][00459]GRAPH CONNECTIVITY]]></title>
    <url>%2Fcode%2Fuva00459%2F</url>
    <content type="text"><![CDATA[題目 & 解法原題目網址 簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。 喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector） 最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\le 26$) 所以就直接用 set 了 後來發現。。。就算重複了也無仿啊 = = code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// by. MiohitoKiri5474#include#pragma GCC optimize ( "O3" )#pragma loop_opt ( on )using namespace std;typedef long long LL;// define tools#define REPP(i,f,s) for ( int i = f ; i < s ; i++ )#define REPALL(i,n) for ( auto &i: n )#define MEM(n,i) memset ( n, i, sizeof n )typedef set < int > si;#define CLR(n) n.clear()#define GL(n) getline ( cin, n )si edge[30];bool go[30];inline void dfs ( int n ){ go[n] = true; REPALL ( i, edge[n] ) if ( !go[i] ) dfs ( i );}int main(){ ios::sync_with_stdio ( false ); cin.tie ( 0 ); cout.tie ( 0 ); string str; int n, u, v, ans, cnt = 0, t; cin >> t; t++; while ( t-- ){ GL ( str ); MEM ( go, 0 ); REPP ( i, 0, 30 ) CLR ( edge[i] ); n = str[0] - 'A'; ans = 0; while ( GL ( str ) ){ if ( EMP ( str ) ) break; u = str[0] - 'A', v = str[1] - 'A'; edge[u].insert ( v ); edge[v].insert ( u ); } n++; REPP ( i, 0, n ) if ( !go[i] ){ ans++; dfs ( i ); } if ( !cnt++ ) continue; if ( cnt++ > 2 ) cout <]]></content>
      <tags>
        <tag>graph</tag>
        <tag>dfs</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TOJ][365]G.大龍貓]]></title>
    <url>%2Fcode%2FTOJ-365%2F</url>
    <content type="text"><![CDATA[題目給定一個數列，為一群龍貓的『高度』定義只要 $a_i + 1 == a_j ( i + 1 == j )$ 就稱為愉悅龍貓群請實作出支援單點修改及區間查詢的 code題目原網址 解法先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便） 接著定義另外一種資料型態，用在線段樹上維護的 $node$$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個 在 up 兩個 $node$ 的時候（假設兩個$node$分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$ 那麼，$stop.ma$ 呢？ $stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大 總結其實這題不難，只是 coding 有點複雜，query & update 都與正常的線段樹差不多，只是 up 需要思考一下（？） code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// by. MiohitoKiri5474#includeusing namespace std;#define maxN 100005struct piece{ int f, s, sz;};inline bool same ( piece a, piece b ){ return a.f == b.f && a.s == b.s;}struct node{ piece fro, bck, ma;} seg[maxN < R.ma.sz ? L.ma : R.ma ); if ( basic[L.bck.s] + 1 == basic[R.fro.f] ){ piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + 1 }; if ( same ( L.fro, L.bck ) ) res.fro = stop; if ( same ( R.fro, R.bck ) ) res.bck = stop; res.ma = ( stop.sz > res.ma.sz ? stop : res.ma ); } return res;}inline void build ( int l, int r, int n ){ if ( l == r ) seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, 1 }; else{ int mid = ( l + r ) >> 1, leftSon = n < > 1, leftSon = n < > type >> l >> r; if ( type == 1 ){ basic[l] = r; update ( 1, n, l, 1 ); } else cout < query ( l, r,]]></content>
      <tags>
        <tag>TOJ</tag>
        <tag>segmant tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TIOJ][1940]Nim]]></title>
    <url>%2Fcode%2FTIOJ-1940%2F</url>
    <content type="text"><![CDATA[題目這題目很哏，真得很哏哏到我都快不想寫了（結果還是用兩節課 AC 了）題目略過，要看原題的在這 解法我看完題目第一個想法就是 DP 。。。然後我就 TLE 了（廢話 因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP但是請看範圍：$1e9$，怎麼看都會 TLE所以只能想一下數學解法了 $k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏 接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項： 0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\frac{n}{2}$ 就好了 接著再分兩個case : $n$ 為奇術時 case 餘一：$\frac{n}{4}$ 的整數部分 $\to \lfloor \frac{n}{4} \rfloor$case 餘三：$f ( 2, \frac{n}{2} ) \to$直接對這個函數做遞迴就好 總結一下，函數大概長這樣 f ( k, n ) = \begin{cases} n, & \text{if $k$ is $1$} \\ \begin{cases} \frac{n}{2}, & \text{if $n$ is even} \\ \lfloor \frac{n}{4} \rfloor, & \text{if $n = 4\times k + 1 ( k \in \mathbb{R} )$ } \\ f ( 2, \frac{n}{2} ), & \text{if $n = 4\times k + 3 ( k \in \mathbb{R} )$ } \end{cases}, & \text{if $k$ is $2$ } \end{cases}因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法 code12345678910111213141516171819202122232425262728293031// by. MiohitoKiri5474#includeusing namespace std;typedef long long LL;#define maxN 10005inline int count ( int n ){ switch ( n ){ case 3: case 1: return 1; case 5: case 2: return 0; default: switch ( n % 4 ){ case 2: case 0: return n / 2; case 1: return n / 4; case 3: return count ( n / 2 ); } } return 0;}int main(){ int k, m; scanf ( "%d%d", &k, &m ); printf ( "%d\n", ( k == 1 ? m : count ( m ) ) );} 後記(2019/03/23 00:29)為了能讓這篇文章的函數好看一些硬生生讓 hexo 支援 mathjax 了然後上面那個精美的函式，我把原始碼放這邊 1234567891011$$f ( k, n ) =\begin{cases}n, & \text{if $k$ is $1$} \\\begin{cases}\frac{n}{2}, & \text{if $n$ is even} \\\lfloor \frac{n}{4} \rfloor, & \text{if $n = 4\times k + 1 ( k \in \mathbb{R} )$ } \\f ( 2, \frac{n}{2} ), & \text{if $n = 4\times k + 3 ( k \in \mathbb{R} )$ }\end{cases}, & \text{if $k$ is $2$ }\end{cases}$$]]></content>
      <tags>
        <tag>TIOJ</tag>
        <tag>math</tag>
      </tags>
  </entry>
</search>
