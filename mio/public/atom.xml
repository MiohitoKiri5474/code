<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coder MiohitoKiri</title>
  
  
  <link href="/code/atom.xml" rel="self"/>
  
  <link href="https://miohitokiri5474.github.io/code/"/>
  <updated>2020-05-03T08:19:08.265Z</updated>
  <id>https://miohitokiri5474.github.io/code/</id>
  
  <author>
    <name>MiohitoKiri5474</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>進階資料結構 for NCKU-ICPC Week 9</title>
    <link href="https://miohitokiri5474.github.io/code/ncku-icpc-2020-week9-dlc/"/>
    <id>https://miohitokiri5474.github.io/code/ncku-icpc-2020-week9-dlc/</id>
    <published>2020-05-02T09:54:39.000Z</published>
    <updated>2020-05-03T08:19:08.265Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="4be9c2ce788481be029c2703d7e7e6e706ce41b31c88da20bd4f5d0307c9a29c">d38367bba460e9a34c5b175892827aea36d7f657745dbf2f16732045ad9c8ad57db66fa7042b372430e4bb5d6ed1ccda40bfbf93f90598534de0dda6d46636d9cabfb2373a434a900e13d650d95a11e698ee63231094b733640902d261dcc103590037f8109b9eb5b2dbf56cb50e40ab32e6506e5f8dbf8485df827534a13f3278442a1a13b9b63e94283393084b8bc791092cf7852443ff193a3ba77c4989c498f2d28dab008396599452dbcc733f51c2f1203cd9bc18b28e1a1d272da21c0e6e3a3d9d1663195dec2b8b34d2b3223c0e921ec85e068df4dbd1bd96a0851b0d8ef0497e3a250ee224134afe52683356c21b4eada0c09247ed0ab79d89a0befdf74647442084673a596a912247b4b760495b81f7df8056d7846383b47072bdf2e126befc4dd222307ea8c8bbe54736a31e9943f68215ef6ef954095ab3200588bde331c7719e426717f5bed2fde71bd5a318dbb67ee12e99b06e60265d4a6f51eea0ce8f32e12bcc9735447fd5a804c433415934e1ad94fafa90f1440ca15db0ed0bb9928cf829b2249f36caae0cae6c5a5562e45c0d6b2cd1b6796bedba66ec454595d74cedcc041a0fce6763dfc60c795aecb65066999fabebcfa4ca7b0fb81029de9755b5d42845caec446489ad7839ee93bc47dca09f7f766c60cd4fe73f27e3461a2939159effb1aac367da8a941a64ebf56d087afdc5aabab3fdc2d29730f305544331c966c08956bbdb62eac8409adf89fad16464723008763fa11a8172f8c0c3b66ff844878d930b64a826d45ffec66c3e469279ed0b6df4663168be291660d6ce380ad9433515996b7445056ff3f1e61afadb83c3bdeb733f0ea17c242dcde499a8fc6f23cddb82f5991b6ef458437907c75fe8625dc31c100a458bb1245572a561d291b7f613019c31e6b4d339bef1bae371c8c6c2880cc24df5dba7f88ead00619db6c9ef98540eaa50a24b9c4630ce7a73ec9dc8274836fe373d5be3623c71273963562c7f19f2ca620dc10f29915522d47cb287b153677e7ee3f0bf598ffff96ccad4df286a115c0ba1da78682278acd4f2f86861d256e8fd8edbf91fc5f37115fe9831c2be2c743e3675364143e042a98c0288c22a5349d0bc9beff7c90d7d00e28205d099090c121006f1318ffd491e9c2e97a5e3fc4fe81c94cd075e43ee3d7fd9a262c0275954bf36e567f70537ab010ab22ff9f9c8db9a769b715fc3bdb1733013dd970deeb1b3ea6cf45963e254a55d8b1eeb304027a485457fd02b7821be21e0ae622d1caebb6a0925855f2419c07373ec910c7929d7aaf7be9ce92d4026d1aa6ab03aa4f38c6c49ef12c0ceb355962561e303a089b56d7c9146ec33341d5e163ec525e8db5c429f80e4d1b68de7dd4a2921131f97ea195ab857fddc71c04f88060e76718a84d2e7a607108fa7aad23025aa1ac5aad867a2da340b81f369cc56e5c3aff51e50fe04dda1132f76039ec6f16623936eceafda279dbb4c34d30be2d996c9f032c561d1171ad5621086e8c493741f79a60579383b6256f6aa0a247bf08add3465e07d0103f397488520c0c0244c0fded27e06f3c01f33f58c442ee0f807347e1bc9c80ed8134c7a45639d05e8f843d02aa88b1e1c768e5eca015dff0b71782df2063244cad7372828358d31b24624ed1202f398d848cdcd19298d61191e112dcdcf428cc8eae77a1e33fa357d4c74860b908ff98e0ccfb122e202afb40e6e42cb7b2545ea1a905ecefdd85846216dbb8c99f508fa0d195b9b438de6e47a36ffe4bf958bb1ca981ef923f6b2e7ebe159d7193e0f03c71382aea9707118b2aae767373931faab316233a57fe82cbe824c78cfa79cb7704e14e2600fd3dc05c92be1010859e85358aa1abb04558b2273478bafc86a4e0b8797e0aee6e4c7709f3296ed6c57fe101df5121742afe51d0c1d432f8fa683730c50547aceb7945a261400f2a9a5b50d3821ab62d739d74d51d8f6d4a0e70afa2e0c4d09e73d5ea28e9af7fff3a697d7f0da05469b19f5683d73a9ecf78d7ce9cba03da2b4fe8859aa603ef8f87e9f988ec645eee5ebc6c6d056b76471130e62c4d104020de3e354facbf3145e866f3a3ff099e64c334fe819ec5aa3b54ce89457d21d0be6e21522298770641922d1bf7cd396a8aa5ec7fb941103004bd0daa58b4fa47b8ec696f4eae8d8fa67add50957d35853aaab8583ee9cce92e11e6b09a075c92c852d682e56f477e9aee4c81416ef08e9a5412808c46c15c18269ed2a7bf22a9e4d8ad033c4fa9ca910ce61782ab476aec2929f6de8e2acdc9ecd2537788e525193797d128ed297ceab147e615cdd9a17dbd66cc7d499bd02de3e389e83ed9521f4b2470bd62feea1669d1380da4622c9004d118e5ec94e35c054f3135ee42f6a8202d440e328e51ec2f28847e74c2cc74a88524ee2f63a09354fdd34035d71bcade1071eaabe51230832843d9d82b942db5dbfb36b80707d5b2fba3ff86d92d73d9e862e1df5f4f271fff6a414b8a737f8f70598b73be6aae6589a8bd46698adfda64bf4c4f8a9327a8f2ce188051d05ce329975d1fa707c01128603cea595852ad3d25739f3c4f6babb112a79866e9bcbee1d8b61164d5b1053729d107e1219ee06fb6fe1677e5d2ab8914771a9787bd846c2a4cb28d82efa59112eb8a85cb1c4e7624a0d5842041288b17075cefd8883a248f2964dfce088ff2946377ec36133a63cf8ba9626cc990e239d04aee48b3ff1d647baf4514326a120928b94ec580c7f79ba6499b5ee04539ab36e43b7c30fd1171aa7e9074c0f0c774e6194d9c9522c16ce8496551976ac30fb3490b3319156cf6b4d4527c88f059517b8146f4db28831bdaec55de005420428cd57854150f63c2b36e7da88a3d0308d81645bcdaedae2921295178e50c4a9db814aebe52c7424e26cd77883359d416d827ff55de3f2a4c1e9adc6fd0f9acada3d9ea67938e17ad8513e05aa805ba09a949e0e1c7173da95b0d5f1afbddc57d2dedb674f483272d6ec4a5e3e0ce368fb3ccf229d40cba76ebf469a0b18008e9533f0f40f66c3fbe8f6a12ceaf07531b29f42401bc809fd1ddade82fab3c3a8f1ce3a1af865a3cf5f58bbfccbcecb3f4885dc0cfb0531781ae21b7896384dc452899e1e965a3670cd39dbd9ed74802bfabebc6e4c08dacc63feb7dd6cd0857094a1d3fab4d906dfbb8e55e1468b5a3a8c5c7c8dccd709e12610f612798c5a9df1f39ed4234db4760ce84b61510630d158a2d7c6bbdbcec8d6c10fb505978040dac49058bb107bcb3f6eac3c5b18112ce993dbe32c5e6e34da1efb5564e2c4821693a7479c351be404221ef0223a7672b64f6ab8530576f626293a4e048baddf9913948d8b0e2389e05e021a673f2f985afc1b816d0f7b7c170eff33f088a0114469fdabfe4165bfef6eac238e409479b81665711fa34b7f30f94478dd2a550220e59a43cb009ca5abb80682742569dc8a49e790c450119c8cef6e9ef5f32ff8e69e0f72079a4fa62c0a0703313f68cfc282cdb824df60625db801979b8230535bbfabdbed885302e26426ca416340b0869d62adfa9a378175cacce7715eb549449717f8b89a7658688808ccb725d7df385ed7d0365d489c4163fd1c4423ed8d9f6386521cbc048c46efb494efc2b9e9b78ead4cc9661d892412f244d1d8750093a481968e4eff835f91f91d1952e52a53cbf19d9fbbe80bddeb556e3b3e55e43595a2a7de1f9a98ab1bc844758b8984300caa68e6f9b189b7c50ae29888b3d3be38cc87cac47ed2ff0db5bb3ad4b8fd8c5788a082a1b1f87851050fb4f2270930d886849fa89bbe91c21e72c1f79bbbc4f8a7b962e8052e1d2f5bf8fb51a7f07ea2c5a868347e6c6743b48fe3753b3a129f2ec7ec6f444b23056ecfeaa13ffd5967919b89a4829fb16b6a0c5951c9df390835fb5dcebc498d02cf21f6895fe00067ebf333fcdde7a12cdf06f4b4fdc2dae1daf8921326bf4bf68707dda6b068cabdf6b5539f42c129669873abb54cc09bcef2c94bd972a6f4caad53392527abd01130e450ab148174724a04c58eeb65061ac3831711ff7c012d155ce7facae63e6bfbd158633cc18acd5bd95cf50725d8609ba4034d4fca839d73c14ae08823836537f5b6bb9d453c7e17a219e0b27ab5013d173fe523588df42f4c3d53cb5faf553562128d601d177697e16109fc50715296a0bb6bbfd05410802df2790ecd385aebba0cff8b172e0442ec2acbaa876301c34fc3955746172a1d476bdc75689e4ad7f160bf187acb92e2370795691fe3fe04e5077d0a174c8a26209e37437b28ef7f177c826d2e30e136390fa9b5e7a40df62fb4cde09efb509d94c2b6e1cff7e8cc03256d506ec564e228433d64de535b8df3c410872023f7ce2ed3efc5db5dd91cf9c6dda88e249c75aba9a6bbdbd5a9778b9274e82cfebae4b9113cd4cf0cd43963d39e9ed6bee4c56deb3950558f6183a4151e1869bb7ad80358082f63e82b6f552d11474741dfb065721e998f758f815b459fd67e74ad63f733a5bc968a7d30eb74818261cd7a97093af2d799517f0b6bd11f354a9545def70f66737a51adf480c7052ad798b05873e6d63242f9db8b2297ab55b97c5002848517989148b6fe265f30826fc583f8ac94cdd59605e8e24deb2768441987ca154614d8ca3e62f87f615bb23b59c86b641451e168fddcc5cc776c99e9520577331877416d26f259c5eaee057f13e6141778e3dc4e618636a886569fda496f690cdec117865ceb68f73d219d4a108d88942dbcd8489a8d8b01564a54b073d519ab6cfd1ab4c0ab8070fb00f4b9788ef08a12dfdb0f7bae00ad1dd7ac465cfc1aa74d8e3416f3f9f445cb4f17c2ba8c8ac0ea8e855a0cd5f029ec6f858d64b1b5b3975b10a437eaa23d6b4a0f8e803e6f7753cedb422a972f128ed28f85208441f1236451e166c2ae0138c33ab5a1abeacbd805f20c13145c07fe8c7b6dbba2234b6a11a0ed4a3c96f273cca3210f2ecd5067c3ae691c233642e2ad875cdeaf84c0583a1d5857d51da8ea50e35b1608e0810101e0436c6526f52162a899f6a6979c2f51b873594a0b8ee6668f828aa79f730ce75f5428746f91adbe469d8b6ad2a35212a01376a0d1315f2cd9521f2788f350e0531550db431d9d806511b28bebda9f434a236fba934e4c6146bedfca0ef4863d0893e569d26df3c11371a9d7388f89e13a2d4f3f0ea51baa4da9c3b90724bfb5ac91af9bd3058cf8642154991262edb6c1f24165c12bd95a6ffc6f6b6992b591193e04682c9b6ab43d4a7dc56ce0caa8192119b1114ba8b344913a1cf3b326bfb7bbf167ab9d36c5059a17bb1e7852ce8519757c62f3789a5f4c75429861d74fb6eaeac268b521e525d099c03cb64c3976ad06a968d00bdd418f8d35f9b2fe56bfcdb6d44952343f43f93808a3d7f9d081c50abd55871c0d29a13b9e2f36c8191dd8f440bc89747ffbdc9ac6af1431782f89bd41305e316926890a3a6bc66a7de2ed67143e0be000344f3e73c2d5888e5ec3ddc2bfc26a30ffcb42ca2a1b6a417718afb726cf85ed52ce5bdb52ef3e4141c9c69fe1817787ad5c5b10a77c30e0c96b03db687f9efc660f8b049ee907f861f347f1149f1d26fe792f6a35ef571f0928bb2ba81cab2226976e13009da8c751719370d0584a2ed25423779f43150eee45ea1f0b19c6bc9e2c670c5401d70ded0e8ab9df3573438da7bd7f11840bc8f1ba5dabf63b1be4ea47203208648e8a48aa35bb17a0d167d66d9a44e7223e64cd8d00a5ec9bbffe0482860189ba6fd4525f241627e9f590c238bbf949331d100bda5d961cfd4cb782e3834b802f894f5e9bd3671b9edeef8e1f9c4d6b613b160476f015934dbfc3a8e09d0cdc5264088d6251df4d20288af7068006127a55be70fa6ad9a64d17a389f9d8bf0d4b7a7bcc23a4454f9c923463290ae6a72b8b90503697ec2734737aa18045e2a626b6e34ddf74b221f1b7bac9b7146a1214446f2a8be57ff443ebbaa2a4e9943d33a84b35b8048bea73378dc450e1d13376030190c6b4132439e0af0b80242fe47b8935d5a76916a0f6dec1efc3c01f324741ab9023a1007607eb5fa500c86a258dc7fc6c1e9492fdde81113f167e3a4de16fe92a1a54b0f1ae4925017b99573cc47158bb4da11e8ac7b063933a66bc5dead1186240f3eebbe2e6ea62f953f90e68e5392aa4b3fdc5a1e8f1d38c955685c3b66337ff58ce7bd6bf35f00c8855294e11e38039932bcc8d8b61628860d215a9d52ad939e07976efbb468c1be73cc6bf0072d4e2c9338fdf5c16f2d0d7075ffb09b381cb2515859e1567a26e4a1db354003fa778dc8402c4b807a643e1404e5271bfb065dcc0e1815b1599810bab8065e1192fdd0861e3d9bcf2e9a25ed4bf4a354fd697227059cfc7849be2b7c14591ac75f4aac9978af2088b0465a1a7b5d8fe76e0ee5517d285961389cbf35d23345ee4078f013c633d65589944b60ba93faa53eef17d4dda531d73e09f1fcfa13c8596919df7b0cfb3baaf3c7ff52448559cfca9a123411fad86f2afcc7e3537bb4e86a5c7f023e2bbbec7a48915acee62905455a3fe17f32cf8f06cab8cd1d07fb5e9268dcb84369d13fdeb0f8f126e0829aea1a471c4b59a94e4ac8c60d1d84b0ed8d543d1aaace4956ef07219606a276aa63182923593894ec8139b6011dbebbad824bb7d2dd8e3b1cf45c48ca8a6254743386577c6e6a27e98a573a32a963a5de3da6e236d93baa29fb03f7a14ef60b1257014e5419078217e22e1b1120f842ae312ac63b69597fa2c0c1176d268d2acd2cea9974f490b7cb2cc6991868a9f59333e990f2b6e3948982b6bdaf1ce8675eaaf296e68a5dd07226e374c1c8c44e775e500d130e8e6011182f37ad8c963cbe262588dd10ed2ef822e971416e2f6528fb0980db140a37b0c4aaf85f2659025aece265928c40f7e70f41455a440708fee917fa0204235220adba3add3886a0710f1538a9b1908d430946844fa48bfdb3f5b6b238e6d108604fe8fce3b2145c05ea2db7c5ac05e5e3f15ae279e98023b54e4a32d754f99d0ab67f2c113542f34f47439bde1e46a5c83301f4adcdd88383c7181374980f417cef79e99ec02cfcbeeecf9d597623692e7c35b699d0539e750299ec0d3c174c45caec875163dce30cba554b778dbbcbcc567e0b58480f39630b7a1a6f0b47fd3959bc49fe70591514b40921f408b9d0343f87e0d3504903c7e30918e26a92ca4f59733a108bc32b3f4de109c18dafe97e8ac9e309f866bbd0f3f2b63aed4fc2e589032a86a2410dc17969c3df952c1fce61e6f8d24795e732ba59f6d41164d701c48c71fa4318535f2cd54e9d72fed5c9241e1774d710758c1e5a196196a16127e04fc28399142f1393e51b26fb1458c684b4e0527488eef5449fbc86b2f6773cdb87fae57b5970070389dc3f4a32be85a926f48930ef965847469ee49d9ef09ffa01e0fbc37a7af0fbcafa9f224bebd8425ab09ec4ef0dc5232e564f931108b6691002f8510446e7fbbe5117b0edac71c26c3ff3e5e8bfaabcbbd9a7991cd72ccb5beef7bc275778e21ced46e4822b4972fc1986d70300509603fec8a866c3ec43eef01fca9570c72afe04f593eb6c3840ba30a7b48f00dad1ca3d9ef3c57fe3896a2fd0dc6c9bf5d5c60b5f9d65f3a7c71377bcbeab2c175234b2a78c0b12e7e1f1d3df746f60ffe8ffa9728fe463a36046468da994ce46a7f6140dfb4633d79cf99477c0308824ca870a3af29a50d0f5ba95f7cff3f73dab3b072c6155e0346ec89d5efc51ba69b35915eb4a769f74284ceace065278469deef01a7676bd30a4a86334d1228c47605ca855094180a1b8bc9c93da00e6ddf3a77408ed9da87dd65f4b647557bd0c9f814573bdae04cd004a45be914058c2497c5868d295ec01b4ac6fa24ecb4dac6aaa619d4cc6ad410e6f241a1c337785dedabc534cedf3f48cbb627f868af8346cb891a39ecbabb1e1827c2ceb82c4eaad0cfd855516487bd8cfb766172b28bb8a4d0d714f9127c4b68b6f17f1edeab1481006563bbc2606c2903e737f3e33a98c7b343ae4cf876055a0cdbd2c166a200443b28492941606e412d34c5989ae6aa7ae8557912a708d4bb2d0029858219e0168129e4235235f45a4d4bd13450b5cee55494b50e89f1c4af3f6bc00c09cd710f12f232229e7d6dac6cc3ed47a2e0d26d36d19f376c78bf70983e05f0228567bd3377bc5e0775d40d2d3497b0c2972cc8d970f39d1f550b62a4be700dc5b303557436bb41b2b81b1327bad4b50caf748f5bb51804f5396978bbbaa11e0cf4d339bc3cfaa2504364d5ac202695d2edc3b2fedf47b385c740e1c93c8cb1420f68063b8558f6f8167fd9cd61f5955cf06ef93b15fd2264d7b7415f23d58b78f96594a417826861f584236e07670fa50c47d216ccb55efa91ee1bd8858e7ae7afc5325e51640b2d26938ac0c490c8b00bd7376dd762f32958dec24daa1364fd016f48467f1b3b3693d199bf60f6f1fd41c9c33caaf44c8e5cc43ef37f383ee028ea8f4396eff66e1d1efef854a3aa92a3457f01e722a01086bf4c50d833c46acff2f091d03f13f268f7ce276cfe1beaea2e9ee857b9ad1308966312e1abf14ac30df0a3a9a88c1173de848b7b87d9c1d58868444ae03c816831a0825a2a12e03da270d2cfdc01041bcb0ebded08e1ebe4cbecddf84ab85be2fcd92f9c7dc0cddf51921ea21a457651d749ed932248533c02bc82144684d9d3bef055e6f883ac02a9eb927c44483b04df118a5dcf282457f3a0e04230da9bcf645a5372d2f387c643c9c132985793abda539287f1e76550c83a8fc8e3cc03e40a9213ba2d88d67de188374cd1a17769e3ed3a0d516904c32111dba7930ab6a13069a952cfc463c3f8c83499e7dfad391964f4200dd41a13105abceea4e112ba3a82d7074e124925c8d291a49fc41e2f940eafa7445d04a381e42ea98c509241cfb2565b8ca562ca66c4110cf4052505976a5033335f0f29bb577fada9fb55e4d3b810a9e4669d0632ed17ca30fea900aa5a6ee1f5db2944d18fd30eb4308c8eac7ae65d1682ccfc5875b8d2ca7c9a53e4420f194f6e2e738536ced9d6687d2a88a64cf8f23fbd22e49db12abade8fcce06df03079d1f8ad6def13f08caa2a4e8d549a9d78769c4a82b632892c0a99cd5a729ef13606ea8e5f11e001d0ec0af2826c5c67296da1ea6243585286bebd1a6e6cfa5439ede4e9b1ca2998dbc2cdb56359d5877f2516316b9cb4b76ea27b5804b70486ae3b8336216f512370113856b11836e1b26002e8df4050aa9d3a57445e4e6ede16f4dd689956644f20d635e50078ecba70a142ad88fb70cb321dd689fe4e70c0249947c65068ab2977af94fdaa77f052911e840c2d5ef5c3f7c105c2b0d3f92d61a759f57392e24b9ed5fcc9f93ee17c4b6c0c474750d337652b9a7aa7b9306c59634e368536b99fcdaed08833d2cbadf245cf7edd82279d83e7af0e33b5749bf5b6e51882934b06266ea9b0d654d99c300f4d15b4a46df9d0fc606ef89b03f06496bcf548f149e2add450218c50ff76314bae3d68443e2270f71f26214f391d254e03e07eb92858666c700a5c96eb0680e03767f7fae24594c46ed5bbac355077238b193018845f05166e1a2c737c5ad7f68fcc65aa854a8741ccbfe3375a16754c74137d5bac6ca7be94df46f78453256e42fbc610a5d8e3f1e8557fb3b66523d05c9ee0216598e490fdc5f1778c425636a5fc8ffcff4d60aa746d166270e0bd05e14fec78c2f7a287a8c888969006d8e3e8dda612560901815fba17d04ad88ca7c3d45de2522ac7eb8635714b79a78df5e872ded21ff5ac3be042273c179999d56b3e36020d18d95f9d1cee5543e95dcd2bdb500ee06e1dfdfbf0f71a6cda5aadabb29ed2985940f6ae7bc2a6e08802f49c5f6cf5cabbd206395a29dd2100c9f4ec4556802b138898dd8be1422f6bac883457ff316e5102b84e658ddf3ea9685ed5ea98e4436ad97e4841fdb8c557ced9711c4e188ae684ef7097c49403e929a6f3cbd289156cb6bfe777ffd3985c5d6bb53a7f1bc1c1fae14156d513f8fb9008b08e8215c3303c73faf9ef2e3a6395a4f3a624d311b63b24262e892ea8b1cb347dc8e613796dd5c5f59fe30d25074064a92bad911cc497ca1092b2881b6182142c3f66894c5143fefd89255d74a896e15a5a823893908af123a2ea386255270702ebe1279d4fea0a8893bc1c883875d707c08879438a4c4900799b91352d815e8bebf34e6c743201dd44c37fb9321f20e07698235ef418a3ba29ce97b57e5c3ed2ec66017dd763f1312adc59df2ffc9da5ed2593754522de6f5211ce2927e1a44defccc9267244ec2c332fb44fd7e3a720a0686a2f48703ebe72fab9c74d281e57891bf7b8e24349ad6660da00872eae9a0f8eda59baa0aa2e969218819e3dec5bf30efea0bfc55535fd56c59b03a701ad2209ad69a53ad3ecd5283949cbc9496c85736a3c0e87cf5c7e30717afa9e210c6879787b9b7e7b81be61947187983beb2b3e619f3ea3af16dd52e8d81bc20878e887cfaedc50d684d49671e1da2e5868855384c64081de6e91a2e976c6719da17a09f34d5f25c6aed8fbb9a20f80f8d8fa3415bccf1cd2189798ae343d1bee2e98fe4a4ce66db6d76d1d96b62bb1bf6e5ace0d6839e3b4f03117f3f1ac9e559126187682b4c743998514f69c97508f20513f4a74cfabc4addcefbf88cdd2045df94675b9e1f9eed399cb66d603367c11b97f41065697a5f65eafed93fbc2784f06f48d33d8031efdd0cf25524947e0b1e405a89d617ca833d1012127c693a988ad4dbcd39cbf70a27d9700fd0fbde7f55bf394ec9d39e8316f5aa415807cd2096b830718a60acd4bae6dd3d4ce69767515a7f3d21e97f561c59ca02065adc0162525bca62ac752bd5907f123ec0b0ab036a74e2ecbac8777815798c0007a88d4fa6427aaf642d385de5dba5fdec8d097f05754f049572e4db846033a6de349f0fdb1df0a6f5bb3d78e3f9840100d8298396f947e4367219cebe616fc26652e2d25d8bb88bc394606e99695a9a7244877e24b654c180f19ccc89645c6bdc95c72f73ba07a138289dee339f8050bcb2d0d6e783f4815f1204432e8738d56da1a952ae664c95726a973f479f38282e033b8f9f45690e6ed2cef274d405d1e596e70c94fb8c10b444c1e76da807e1f1678b4d7cf3ddc22fe20148603abf973df03a81dc98480934d71898709ccc30ddc76504663dac9d18910a908e77004720afc5b7f80c2ea547ed79599bfcd26aa1dfe7a6774f727a0e279793db89b593f3d5532a28462f7b2b590bab985bd29bb7d7ee3fd8d72efcc247ac28b9f96e5a33bf79a79b50b5f56aadc260f5aafb0539562669d31d01e0a319515ab012838b9d0f3d95dc2802117e2ff2a80cced2fcd567557407b03cacf9d0a5a0707db675051ea48dadff37977a7db9f4aab1e85c7366d8fa861849b25d080f6fa6cbca56427ff43f764aef7429d87cc62e14150221831e62e203d1b4d242f4cef7f3cc2dcead8e35ab33a7d19452b905d7921553411fccc67bf6031c16c989dc085e1117276d93af12f58517836cbaf9f1ced41766be3e21f83886a79fd94236522f5f271c4c49d1ff1efcd039d4c0f29d7781372206fad17e309b2cc18f93e533e9a6077564e22b8b83a693e759e55ffa150b9ff16d7a236b9ecdd25215b2a2f75e84a3bd16a44341e1d12f33d75d948b26ac0ca427b9356fdf8170d9d1020ef7022b240a7a89312ac4308c0fed829d6f9a298601d088846665c8831da17ec2fac348cc69d938a54deb012beb2a15ec2e18b8e12529f1635c858c4fed8c9981fe19364f840c9537d21374c66b6434fd1df358c5b18bb7fd2bd02ba9d6452495e856eb0c792cc655ea955070b0ccaeb4f11c40e8aaae6ce19bc5fd1c5f0a95682ed12282d0aa6caa82da8198536bef88011f87e23bb0493d56067910927c87551bb42acc26d4638781767ca6b708199cb62b2eb24ae477eccc330f872b2c313d9ad115e1d8226ced55a8f912eb97bfaa76cf3ac5ec406ee927a344fe8a91edace90bff17c47d3a6da9780a291b155434b00477f55c94451299a7b81913f6a9e2f5de1a65399a83e7f77f6391fcc03b6a45ee86d194e50d186b0c76e194299ac513fd89cee5a67771ce7261fe104901c71c0ea99f0b200e0f26077986bbe23cc7579ab0b39811aadd6b3517d02a69c5d69d7c63f9557228b67904f261c9f9f23ea2039bf0db700803d4dae3c6950e5b2401e608692390ff27f0534ffdb255c1f80bab1e0fd1b6613e986b28601069c03de424c7aac1115b753f1af7cba5b33f2b18f7dddcc42ce020be7674d02cb8e75986e93eb0576af4385e6f45a8f33a4ea56b7a80f21127f187ba7c3f5be98af41ef46ed984938d72c0271b2a6bd6410fb710ed6b2d9444fdd526ccc029cc03d32eb0ba04fdb98aa3d9125702adb31bb208d500b376a0cac94c8dd219bf3082f6bf4b788ebec5e316594a01327951ecfda50272f44cc4750389a6ace5396791ecf49228a80f7cf0e5c2fa73cee9086d569e024d5cd656e17873664078f9593a0803d1f0ee90da86020d573cd59fd7a97068c878d32e3e11634b58621f78eaa48c06cd281e7879134b6ca042925d2d2f1da33d770a6f70b50d4f4e0818d2bb0f451d250f5627f4d572ce10b82802b4b5e9c34e003f710c6e3be72fb61649c0ede159a7873596302f66948efa225f2c04bce05575a6fab05137d58b0ae7e934af3ae8f231625a6c8f68b0db978cf5f7711db5dde2a3e03314a791738898dcc4074f0db337ffe465b93b6c9126a01d818bc89d89957da6c7b14f7b2adc0ea035228242a1d390737f1e385a7ef3809bd5a992860326f69853f57d689af2e0d2a3ebe40e6d1e43a9be89658004f97ea3912575636c6fc4df5cc61e2ef9e7bc47f433fc0891f5bc9f902799962254094690c95949ed8a1da01b11a78e3a24f695f9693b687f58cd059e80fde9560cec3ae08954b7b09cb5c819a848e3ad1eb61cfd143dc352e138279e8bd17c9c977ef8439f51a08ca8e7df0a92ff71f90fc77552305bcb74a6c67cb9a0b9e7d557fa3000b43b871fcf0f1260aab2c1865e6fdb80efdd5248977c61dae8b08f734bf23e9965c9e997ddc009d654af67ccab7913521835717ffb6483c1990c73810d77d69611544dae417feb649adf98c1182aef8b05630758a2e9829391a4d1c5e77d0d04fb47fc10777d7dcca2975d5dfc3bdf1cd50d901f55684568947bdbc1a6a0bab7ece42c44ff222fbcca5ccef2dde2ae06adcdc4ce5193e9915931e5fd8cc0bebb910471f009720ad24a4c62437583f9663d3e62ee351d035bab3245b56410346d3003074aa46efadba4764af4e83b0e717832be44322a04fb96968f3f9875e515ad47a1bb62ada70815ef54a795c9c24a4d945d9208b2b88c48f8eb5db868eabdb01677d1606155de2bc624abb879586d87e842522129f885de73132a5480a30b68f77c6964666562bf16492ca148363707169d09a2a707ec7bdb16f9411656015d3ba4c3b653eee2dd73cf7453e3fb9751d465bc45b206f988d11fc189cdf02b81b285e27ae9d7ca1acb8c8e4da0f97d40a2e2c61612f0581bc9140e253b7af7aa14560fe92b76c599678f0faf42db6eb9a3e18b5c3eddff60b02698a946dfdc2da068c7eefc3dd67e7b68be2e318b3aedacb320d987febce7550e647777a0274914b8969078c24a3bc0fe2bd50ffba36c5e665c7bc80ad55b320c11ed4e8ebd40fcc7fa306345c8101a5b14bc4eba0b90c6f0faefe7f6d49de03788815257b52ed6a76d083cbc1ae9e5df174c4974a79af1a6ad1ed5d0f2855050259982c6d78e91998d120e20d11099a2a0d4bc1e5af853b2ffb2956fe6d45cefc25e5a484d8d8a3383ed00d22bdbab9ad5ef20f58e6f30cd16d9aa106fbcae44239c35946ccb463d46dd60fae7407a3fb207ff6eb65d097e8099ab975d0072db57d7092b90c7e83e50629575c51dbea4925255007423b06746eced3cbaf5f3797947e836a3724f5322ff49335cc339dedbff3ddbcc051f908946aece402effab39fefbd8a8b9adb431bfe3396fffbb89beb1ee12baff02bccd70776a3b0e224894ef604c81f60f26c985ee7e02e1088bf3f58c053343e9f0cb9d91ebd8ffe9d836dc8e3305416ab43f7c81ea49ae57036cb982677c267accdccf3871d85ab8110a6f0ec3f87b3931d7cde1a92b6dc17bc6529b2f27a595d9d8f04b7dc511b7fd0f6f78ab4ae50feca39dbd2c7569530cddd1670f3da159500e9725a7e08da559a2eba129cf2636d91475b87401db82eed2c53ff7b3cb0cad4689d63c9c8458d4d810d5e0bda9696cc39252c71455a1f0fc8f61548ddd9ce0c2bcebdda1b641e9b9401aa1a1df162beaa8d1844f6f3e7baa6151b582ebcf358726ae6990c713e4ab49fb946c9c596e35efa8136bd31156b4f925a7ea0ad3549143961a8f4721e517d50fce45a0b37481332738071e3b06af8e674b0221c0cdddb04aa2f738e13b6a50e68cac8580671ce9a99a739558dd67b1c01bfb1f5828260989baa65ccac5da690ed55c23d30a1fe48f61be92737718df3b5cb0fd36056d0bff971eea70c6f87c74e655abb1d21b9e743f2ec75d9e7aeb4136b231e652edcc6d6cc13aa9806d38f42eb2e25fb479b82e60d44b5dfcebc749bbf725fa699ec330c935bb770b4293888c5b01e9bf3fcdb9ebffaecc5951c15416cb02d6705ab2aebef2fda5b06ec6a582b3bdd5f4287f8263578c853c2c289d5c204c0613033e887ae50705f68d137840f5d91bd15a029c6ab25d36eadab643d4424c6289da6c390624249203ed84a639f9ab4d89d291bc938f6b3d8f2803b2999e35f319adafbef3bde90f72e31eb0919f4e9915747550d8be72917cc6c5d9b920997e6e2327fd2781e468e6003d3923c92b7e3574f86a1296478f50f1f8feffc4be73c808f88c7202bb6fddf516cdfbebcdd8c03fc73ddc73836379a6178840874c22c290e5bc32c2195aa24b3873c65ea582277b85b55bac79df6bd297d166b29fc5afabd028bdcfef25fb528d91053ae870c12c8924d7376be46ff2cd4c7155bf17ee3988a23dd39e263b576fd33bd89bee70fabedda6fd276e0ea351fe08474a0ea8f5715b48b0b8ce5a0e7e419f0c75532855df42970b676ca471f22e3c01ae21497562a9c861339190fd86cc98a79e582785a21f6c3cb81fbd5dfdac8c3a62a258632c7aed4cf72fd26cd10b2e3607fef5b5ff821892194b6cea3fc5473f3e4acc6cebe4c4d8475fd0dd9c920ef28e257f80c08bf310230c9eb1341d5faf3038b7c13751939d55202bc736392772357c169267d3feaf0776e121aa53eaed02ba64f6c45f300ca16880b2b618acf1391079097abb3945cb594b9758f3aa6d437a2cb67f36f95f9d9e5a5b5574d30db3edaa0b137832358bd43172065655d996d022f598277253c62ee51a201c785a5b14e6e3cb97915d8c9ad59f97a0511456dbfc0cb83a63c8815268299295823d9a1232b5cf85fd76679abcbe3c9c0dbabde8bbb5e8a206ad4d061a77732149ce9747b96cbc27256fc8b6fbfae827c7c3e02ea0e8ec05f52ca145560e4658f0af9ddfd2a39313b7bb2bbb492029f7eeb11d6a662ebb996a484cfabe2a2ded39eaab4300ffb05b966ac36e853c208dcea98ae1a5f1a42c0d11379d0d7732e90c53bcb7c0d20c95258a336b0934f7ffff5947a9c3e22499e792344175aa963ba030df5e5a4af15cab4cc6896c8e0ea3a1b9d5be2cc22220018332f6a1ab790da14cc7fb299ea94aa4c881d89c574481ad1e63822ff424a39c9cfb4a52937aaca257d4e0b5759e56c0ae2ab98178f2ddb5c4903b044d4aa9bf6e5632c28c9c3d9ce94170959ebe0ea5340b4a4e10c1dec8e7492bcf33a15e40270eb9bd428fd29fc150df3b6e37153587a93080fe6fff688c584e36708d660ce88e1437b6a34f556ac88992be8dc0c0dea35b7fbcc51f0acfb2da8c7ee5a1c17916c20a2e17aa75e1864da5fedbc13930865599a798786dbe977cbb8a7abdeb43090d09b961e2000753e01eca44c87656fc8a83a74440dfa4bf7cc6c29a554296c5f2e64328366884893905930243749df56d4f9b6ac806a99adc0c234265c3056a86489d1f301e7eb7f61f3c4958def04f516fa1d96d93fa54c03b08f12a58abfc6aa5e15ff5c0c5f449910e9202f21bdc29ab21f9b4ad0e3f01af66a278687ede82397c994e6afa58afdc4baddfd97e9476d27956ef1b54423f6469bcf401816c28fa56ff0db0ff351768b40bc7bda8767225a1b0c1ab2dc0556a89b2b3a8fa310ac4288097dde2494ff85e29709c1f67ef6f2cf80d157d506c67020fb7de3415746e6dd0ee5645ce0f46ffcaa8bdb9b8713ae6b5613eed91e2ec46e22815d24817b09863a5327e2484f9c99516b6c5c9d35e10e5d48b936f322909d6b82b18f918cfcff191e275799d857be278691fd2d754b7e9d02c8c52ee03e36eea856bcd47932605c5816a8cf49570a0de9c83a74d839486ab648ac86b9c1d1ad536f93897979df694d78d5a85cc80f147fb0ca117c87bb5d492fe1509e6754fe9821021837996babed45f6ba177809f3f9ecb95a77167362084e48af62237af9c8e4533ce8eb162263f09597e3e714f9bcb74a1caf7be8d742e3c91238c1df632507701e076164bfd85bc7de77df0b95b20f394fe6efcf9ccc4a432ed6b4aa96abcc23ef5a832db8dc49ae7ee13f42cefcd6007ab2af9e25a9388657a512e5518621fca247dd63732db1b6332c41781713a5f8fa50540f7ef0d816955471cfbefa4eaa6a133ae48834abaf248f5b3500caae69f3544bda61591b94afe8632168cdaf74084c1d6eca1a1e898f953bb386c1729746586bed16c29735bd2511146a63acbd90b65926cced08a1e80e9c0c2f03a3513ebf45f88ed04a51d0039b714f77cc3358d9d37269616dcbda0ac393437e7521164ebfee9e985e5eb34629fd039150f8bf55733e93873db71855f24751fe5a4614389f091a48be30f7bfcbafb702243ed5c4af9ed4929a4b11d58a6b162b6f5c14e7a60a5d50c8a03b404509e53285106c589402b7afe02a26b8a395862b2d7ab4655af335a0f065d94dfa75f20b506d571ebdff5c606ad3a5a77189d0b7a656bc210ee6043d5e6ced9cf1e8cf9297439cf1fe4dfecf4e35a091ca2dafe71a8cf3cfc4e37064916a805904e8ff0840c876a1dbcce44d8e59ff92d6594c90a95b6b6398d1e878a46245241c35b7f7a44bcd9fcaf464f3c0c28c60a444bf74336f4deef0d56a61eed28ff556ae9e3d73cd1f53f58cce354e7bd048b0a3b5197dabfceafcb18ced97b09cb0a324732a547110cfb0b9ab1263a56ec0f757ac2a0f5b0292e8becb107e3ee0abe447f9429fc70a14ffd62c0546042c5244eb7924413b3a47985b28ceb84a45292469a56fd5cce626b060d9ba744abbff1e580ac9fcb3e056218a69765e662dedf22306732efa9409fc0de8dbaac7a0b8446ba142538c7dc43a8994e5faf9ec1c44715e48981427624822fd3f9272b269d1fe1a3f4afd4da2b3a5bb2687b0e9816185e7f0781f41cbf56d8958100e6e9bdb3a29377c9ac4572185e6d62a82208e579daf2f1e20d39a704be3dbe94dac2d1e6686f4acf5860bae1a29ef5d08c51dd9f47d46b4f7194c59aecb1605a3f1b6571e7ae150928606801ddfe867d65df0c443bc7535cc4a90b40ae3657e3159c009114cb53f2f98b3519631b51ba4ec91d7e377c7ec2ca3ea722c828ed98894c8ae40b5401b78feb015eb316e3bb8035034e2a1896a9f89feb5cdf75015f24336c7a9f812b07a645cd16bbc14d0bbf90dda895c8e0a94f6e31bde15db9dae06bd72b8cf258fe3cfa38cea93acc1e89df2d567afaa5be369ce1ae534669e5f3c805e3e89ff5be93fdb41eff5e5269eb3d2417bcaa9043ceb0369cdf10ec8d735b145c403eb218aa228bc0620bf3cabe71e065226f5f1e7a6e607f1121d004dd7cb3ecdcd79c186224bc991a48cc5103deaef158c541c90c1993e4be639b7d4233f994bc977db8fdd57271f63f236813bf681bd7ccd013b475fb9cbc0223e6870d2494768d6e135edf13c27e69234c9d1f695e15482e557dd96d718418105b3076dcaac94263dd96fa7492bc066a05776531201e24547dfb117704d708090417bd591dc37f0cc1c164efd1c0281888779a96245ce94ba09c07e2a75e5cd2eef08ecf15b088df55754a6e52dd03094fb707ce55b987fa211080cac98ffb3e9e9fdc5a528f11c61030893ab0597b8cd76d2f95ee3fb8ef178f48cacbcc03164119814384726639ffa358e30fb705ebc689281e617b598bf0f9f503164d51abf34bd2d2e84aa7c6c838b9bd77ae23cf03c04a01c218d132b3b7bb42f49127d5aa8c8bfc7e0856bf3d00494e7b531834b743ee5222e1eb04237baf3f3b2a6444e5128549dcc9bb2228c529769fb474466491ec1950cc9f8a6e11779550f5fd4d33357cfb3aeda92c5520a30519aa461067380e192246100570472573437bfa5aeb11db1b16bd87b5865798952ccc2828d0b1704a77fc4c21f4f9886dc0e79d13e347180d9d5145dc3eed8343f09bd79e68033ec6170ca391d3e8ee5b221052657bd7216fdd8463b27079b341c2dbeffcf7396210b91057b33ba4faa9da1d3e573fb098fb6b26c57dcd3163d58322c3dd9390fe9c1d14bf7331d669854010cccaa9b123a1f9058d4e75c3cb5d807a2407bdf4f368e24c98ab284dd1481f18e56b5fef550b191d80966295ce1ac80de190dd1e7bedac80f6759731eb2e54e1d128221dd1f0a98f30b9e59f457a40adb26e803a3de21c0c6cc01ff5d2b072b91e741fabcef7e1df03493a616f51b65615d3e898eee14e87e2d12740ac3e4621f52f16f42eda38d8fe0bc577baf49fc9ceaaf14a238e2e4e17cc3608a97081270d3127d62ce7f9ca60aca8eefa3164aa0be8ff1e87ec61553c6be9cd523bd10c5d0e52bbf7560cbfed9585356dfdc63f2d51f6ccb1b43580d2746d00d2b244084144a765ba51262c152b12051bc1be784bbb4fd216b531cd4d55f323b64ba2d5b88f736cd69d7ff406ce3e229b99eeda3df336751ee39e9e2707e1d77f63e80a8bdd9d01be3e43c33838040c142782d6598ebb614a184d4d0027cc974b7af0d608a6934c60ad1a714ef0224def91ab96b3ba40bad80517b94efadb07fbdbbb2552706c6e4b1448acb5a91977092c1c7fb02613cd02be1b371e87838b4da0d05ef6e4f295bb1a4a71326130500606368c12ef65150d8d4205aa3c0a21d6f8637e3ddc2cbd570a7786d36570b6396e2817ea6054d5d72106ec3f55ed14ebe6fc22858a6cd26ded468005cc0844b13ac7f3306796af6c13de1e0af26d1bb404364e9657b573ca7b84d9e5e0ebcf1faf2ae638aed52b25b55738edb5e8631342188f6ab68ca0d7156f84dba908c5fada5b307ac587877bc76d12389d8a4d31c575fbff6d16bb9975dadb48f20038cb4b13c5423a602ba7978f19b11dbb712c90368127a4d00b36c50881747c33137034a9e112f6a1fa1f8144c7cffe330b3af61f8c6c9eb53dde02bf43624d871637a8020faa70f5ed627b232c926fde0ff96f88ab1171bf6b822781bc5e02eb296286f997692d5970dc9d6c4f37eccb8b36b0f1775cd7f14ecd2459d6b8ba989d1d78e7e5b7bef67d37357d536b441bde23c61d41c0ebf5cc21e057010ec70d4f2118e179cdad1289c2d800ac9933aa59a120a858372cf8c8488380d100c36ef10ccbfd98e56e0a17602877445b1052daec85b8743c0a4e91b2b746f53d37856c9d116b9d6abdec754e2c90dc3e12eec66322b0f106e6c5e85bfece401ad56c0a360fd51d660e172d9dbb8f882ea307b0dbde67c506e839988847b8944ef5c32fade247645ba84a2a1eb60b521325cbb5ea52e0d73abad07a2ad60fade4ab50e6cac5a7898e30bc9bf953c9741d294e821772a561164271caeb598325b2da1c5ebd5c11d822182ed431d40c433ef1f08c38f4981c9566556f16f1f9b8633d39a2780cfb3ae5b50a3f02ebadd31ac3a2fe8e7c796b3c595c01cb2a31764a753830f7b1ebebee3b482e6d4da4f84028079ae15ba8b1142138d7d79e8575e7abcc7afe35b39a6e3498ca2fd5114d2c15c8f02ef896f1a0911fefaf99b448ae590e726d8fc34d63e5ce2b961c27bd2e8615cb7f98b8da0273bd98a4b1282fa3e8b0b9a52ec1d479040ccd13ed0d8c1ce6638d33fe24e74cea7299f40f8f7b499f7ba01a9fcf2e1bcc636a28a263183ce48dd96a1fc22173ea686abc1f852dcd3057b8dae6421d0b66f9d89098466aff42deb45f4862f55a35d4704d8a62cc502d109592e23115004a33ccfe2d7837017669daf8386f1494409865427270c451947dd7dc3292033387f372662db3e15243cc91a7f0d27cc042906ac742e0e9eba393cbfdea2bf206b3339fd91b7890ca220f3f23fafc39f65345d54d966234295fb0e3d2e5a2be94db7164a45154aa5211bd80fa7c8564ae93367083d65d4fcdd50eb5afd972faa5fd4f815edcbd70b4d466e862061ea8d9534793dc6f66dad4b0f75f03170e26824d0b5a377e1a44a3481ff5a2e91f1223780b56fd631832bbbaaeb9d00dac94af06cd349e4c256a9a2915bfc6ee3381a7cf153fb5fcccb93ba30d0b86e950d43882ede44d3592246bc937f613dfda5b10c4c8c18cb0f25c43e5e713eb8e82a1266cf894db231eb82b7b040913f42ab458678c3478ce9a8c7cc8adb4a6688d620a9db5872ee0ccbdf2b1d9180c861d81192816ecf2163fcb27852e4597bade5c44a940dc7ad5e240520c77f801cdeac1807e70da6419416738263940e3c50dbb899a42f3f04fc95941c8ca204b7e261990eb9afae6cf0e8355b989ffaf569133259ace5a164e6ddc8a0bc9348c9a56e917b0f57e966b74f7965a5af855977c248c9c82c586e4e4730e0539278af18f459d20422dd4c3f33eb09630ad995edb0cfd88a8f106b6072650ffe8ab59f177ea7d7c5ee9bf09b89fc895d954f12e8cbe0474bc56cc71f95abbac5d83ec2a93547de3067af38d0546c6bcbdc08b7150c1ac6bb2a9d6928f7f1b30dbaf71036426f2943e92bd01becd6f0f7ca31d447e8aa14500de1b8beb683a0eff1033e0c479721dc25352371c7bd58a9b4859bd28febd9015640eabad78720b01f5986ea16bef92cbe4988f40b18b353af26e7c4c32f494b071be131a285488d5a802f3d51ec7866d61d4b07e224875abfc89eead8bb7a94b6682b9b47d3172c80d3ec6368a2a0d8e04077f118219c48a37f2ccb92fdf62a32617f67e82b201eb55531914a49137232d9895dd887b8a440d8d70096fb9bdd23aa2be6d921c110ef21c2a47b9479369e18eeb48ec534851cd3d69e5fe7085bfff4790c90be8ad050dee85c9c77921c350d5f7841c123fb2f2b8cc3911afac48ea41adcc5623645da950263447ec64917d803fd777bb8d245b6c5b3226ce000e504d0650f9b2bb846c59921367700c787011b74ac83c9cab0a70553d963579d5323cf78fcd69f940665d17c72979ae66091fd6d2ed7843266fdc3d513f53fe830d6c978eabb60c5d9dc61e67dba266b3642808d51892b8d41f14d039ef89397c0ebe6088a0548301e11687ba25b10c5a945a7fccf637233cd2e4d9b13e4a35a5e54bff597027bfb9b99dc7e299c75de711106feb5ea864e3cae97fbbdd249ebe38702f5fe52396a3d18ff36e4af192e7d2ccc5d559bc160e056771e1ace33f87d33b7d841fb9243dbfdb532f62c5f3fc165a73960aa94a2fe608df1f5ed02e2ae2b1883f14a8fc5c4a157d51ba330b3c01de5d9335dad1e8826979169f7c6e7a41c0790a44e262ce1a5c16eee451f9cff2b3a5eeb9c97416e9339f499a9fc5224b6e84140003502d7cf0bcd5ba7f7f06495d9263af5e3b6e020d1341b851f3c537c9ca67b8d746f0a912dde3a7e9224c3ead990381948b4146dcfffb098d506a753f4a0171fd26d580ebda77c5082de0027809b66b9e7aae04011452c856864a6c4103278b193b61ff835d1047c904f57aa24260460fc7edc68c693940f00057bc6180a28f4656648464e0a708d719377ede12eed657c7730350dc6ceca240baae507743f1cb690b079610de1c32c71aa6bfb50905f2289b28fec808b3ac02018769cdf39bbbee6689c1007239ba007a18db04a8d2097fe48fbde8ca33fef4a7748775b1460ee1cdc59421af525ce80304d63821ccd0704e308d35ed64e3967f4a2f5ec1298d0c17025a5db84b4533898a6b8d980b37d578a4f0da85661928e4dcd6fdfd0d739e565565a1f7bd725bb83af0751eb2056b7348cec13199a10da0804cee7e114b32fc152b06731c0d41da2ab275347f0c3a1b0e8f63c009f6fca2af60aae5ad8974572cf91dd37d938dae2f88710d76c54bedeb7675a8456413af4c1b59df69422e3462670437135d46e8892256e53db30c9c94a8a93e02774d5d1801e73e0a6843e5e7a550c0c6f8feff780d8280765a1dc763c9c26e01ecf5ff25ed35e621677a0ccc9ec90fe0da23e68590bac83b640f04b002868efdbd4268341a15dc2d9f2bd372281dd91c1698225a95c59768e0bcc214a49e20b768f54669f4ecf37610ad7142f850426630aa1252310870abdee29fff370774fabd688c5f1f50ba5fee8eadd23e81855d6187e1587f936503c15630d6cfe874b025664a0a74906810eab05ea39f331751ab5c383c6d5d69324661684eafa4f2a219c83ad0d75a29a9092a00693403bb82f3d82e29d5542f3ca8deb55fa5d1277ec7f81633287999897454b49a9a1133674b9d4f45a93f901ccd1a8739ed58efe345eafc1814d42e683d3a366d2cd3ec0fa5227cf22c169f5597d2357226396617698dd1b3d6e2422f4a1eb2ea1fefd1eff64fcb89e969a9b22a7f08acd8e6ba4b78830a0dcb796dddadd6745d85966167d716464f42f08ab06a140361949aa073f1988cf0aa59dadb6066bd8fbc90724d2ce2442108b6b7cdc4ccade6c18da1dc7c5cc7e0f75a48db9c24350e8a9a892d461d21250a51d9368bce1222c52e3aee591fe4bebe9082e613cbd8fb8fa56bc392f42d6e1bfbcc42760bb6c2a2ab4119069e75abf85c828b6893b2f6bbec08968c90f6352c08cc92c41d7aab86dfb5b443733be302eb1759d3e192f1af7f9e5979c2415a23904047d91fff71425a8ba318cd5b00755da6a91ea8128188796473e78780f576bafbd514f64e240b296a35ae603cad8f5a14af564ab8800d770084cbfd3b5014eb4e15504098fc771f63d3e4cfcbd3404c17d9e3adf8dfccf8153c08e2f4d72f20e24d5a11fcf1e1fb7f30d61f613d4efc51ad5f854831c7606bc973dd8dc23089176452e6ea910f62f2e2f343e73e5116dfc15f42ae14145fd4bb96fe9a04ec3209bd897b39c78e18a3c2540f6a82cffaa54ac8f4c74c449a3d84517bf78ffb63fdff519a0afdbd05be481b8fc0920ca95c30f23d70a4368e02972948741b36b3a8960e5ab111a7b875aebb130bfc1f1a5208aa5c554c58e80a7d525a4b45dd32c0b40f4f645f0a822c0be0a7f4084c6f8f91b18d0053f39b441080158504d3a1b50784cf9db58f62846ba972f9d574da954abe037212dd3bbb4e62a62c5a38b29e68b0ecf234214c95ad5e7505dcc815acffa9964b922e16111edb79e6e4ac151bdb7e1c47ff9c46c14d573c18c2b13abe8c05e7ddc5d7fd1c447b2b35b2f61d4fca39e5d94ff26b0b757b1bdcd7e155ad9a95513665ed47855e1056b1b1f690f077b54cec11cb817f78fb9099dac6f748e34c8d0766dbbc80a36f1afc75526c2554d715e2e74f0c2abc314053e28612974773e1a9f2059bce7ef0afa5563cfe53c3ef5047bd0989bc044c729f7efc2ef17347e6dddf9f132db73ed486e85656272d10c6d61f05a47b4f402ec6755b49bf57ad5e3c563fa492403b2cc7cb2f89d96d1336ef8a1ae29fda70cc70df23cb0e8a4afa9d66ca7998fdb39d2448102106938251f01f612c9c25129fa01bdf6a192296105f21d299eb878b787949e5c05473ece943022dde8e90280cadc6507edbf182a18b5265995e3c3429c90f956c06ec84fb8d5d003e7721f9c43613db0df206b80402e5fa1bc4819c13269cebcd459729aa586322c011569690dab5c5749028cdd23afcafdd04c40aad779bbf11630cdcc15dae4bfeb0a2ac286be9b0eaf25249ba9efa65ed5903b386bc892af08184e60e10ab16806fa4ad0bae56596c3930258d64ddfe6466d5e5d008b338cd54144ef2e367fe55a7592f636d4be1dd303a1651fab35918bdb4302ff58f0b4c3f7ae9949da5df5bd8cc359faf887e08b7d61899d7f6e141a6f8b8c7e7a968b146839110b1030cf78406ccc8851092b57708231ffced7e12c3531519df69453e452008c6ff2c31e0c5a01e9038e6a79ead9d86162ef79a09d14262ff8bd9ab99058094194f7b90f4765e76bcef26eedacb1711a02210f1e6c18d4137dcd3a2d66c3195a9d615b18028870848c63fdde6f672795b50ad35c4e2da14a9d18ad7a09b60254cd9a02cf15614aab3edf571d36bb14773b7371d812307dcfc01b5bfdab8b7c3c6f88ee2e6d52be34b6ac298d425fad22b285e1b874947c9c8b8064d13984e6fb0d385003ed618d914beaa99e29f0bc55fe87c22719c30c34ee4ed2d2cbb2176f5ff8bc56af4047cd4ab182ff1e0478901e580d30827e71cb7871b50cfd6da573d95d79d81a310d17c84e516b5cd8e0f4dad4ed2a475e35fab201f94dfa7fe6e87537659645374ec8a487d39be33cf413cfb5ebd611b9e0f2e5f3875025115d1f44056af727918b2df79dbc14a7ebaf827ff50f934e1b8717f4099b045dc0e3a2860c6a7947246f34ba8e8a88568bf944b594075b38ea7a67041260ba48eb5e7baaf971fe46f31214b692065f14c93a44b68c8db052fad3e97914451b249d471caf15a447bce76244011f379785f1704c8bd1cb47b39c8af5d7e55ae8ad1ea43757ae66e864e70acd8ec9ff673b84b96cc50196ac3fa83e4f0c74b87b3aeb12069b20e1d809daa366e92e62b607cae2c5d383ee5f602c07e5af908ecc9d8f7e08d5ac70b01535989414facfce62b3c6d8393922c063fc9e568ac2fea3f2d4ef91bb9e779cb7116d285e5a376cca8f0210679705d5faf87c46f70a7cfc5623dd0e11a8291001a93b0cde55232b42adec3e06d283a1b48555c29941e0aa99811a9488cc9db4c9cd43d47febb4f77c2ffcc65a339b01d9a53867be8d9832c6990ffc31ef8d2a4f50bd673831bedf98ab8617957148efe7c7bf0c6d69a13dae8007ca9ea123922fb0a098c66880d693496f5fc3978ad106dd68b14902a395bbc46e37203d05595f3e6e3bf28a3d3e9576f07414870c15b262e8ad46b652e4c4655cdf832a8d03278a69ebc72384c7012a65c8c9a05245a5be1b0731fa36b2989d47d855f92653ee02a0b4778cc3491cfc889dd33e1caced4b85e2c6435d4c00bd5230feecc10da16a6cfcb662ea75064d3d3e69afcdf64380320d22ae589bb2a7c7139c796feaa11edeabe1eebf2a8a43c07f40c23964f2f5bde2e33ac7bca8bc934c796c20c04d0d223ad95be89da8f17c271bd12e5590fa558ba93ff2ea5af1e8b7ff814630b5b42dcfe2f08ed015c117bd75031949c13decf68473b4f76c4a7793575d1dbf1bde47a753675d03786e93ad1c2447ae7827b8828456f46d9b1fc1336d807634189cbee7a4eedbc0913b30db3f5439e93b1c8f34cda703fe3325e71e8822be99cf27bccb53fc38975e0f529f34138e7b1f5630c9183ea2ec387b8f3246c569c0bb2f3e25c6c53cd7cc19a15b61673855079a2ec4a160ae3467908102d61161ee39995ec18cb1a5968f174655cb108bafe049e1a1fea0c58908f6000176228c84f6d58d74fb1c1baf56567b36f2afcfb63330db447c986851f774daa0d17169388af1a8ec757e26f59c9595c3d7ee230707affb2a5c2f7a4e44d9d0ae975936e9ee9fcf76e95231abc5cd3b2a0a51598ea97d8b4def567cfdebb8e2f103eb8a63c5a043ce11581e7118f8ffbcf8903e54b62b12c6f11411c031b379514f0bf5560cf756bfbf463eff1c1671603ecafb61b76b6291baf1f0d5283cf2f03a7b93ec628dfb79e71919927c6f7520d5f198c2c3bc9891ed43d1e3847c8855b04c7b48613bf431c0b34e708f84de6ef87a51b219f45fc4c8bf3b488edab3aeade330307e534904abbe3a2c410b331f6e9414413a9d6f1530016d4c496d9074f5b5c7a8687075fc5ddaeff45eaab9a8def5625e500f20ff65f8378dd2b23044cfab2c5a3f2d98f3ab9efdfe273f75d08d79d672e79f90a50225469abcefb5887945a7bb589f6ec9585dcf00466b5418acfdca33690e4396993aef3ea317daf7d5e1d4dbe2f7e8fd5f5e3289ef820e9d5cd957623382ca4474a3a20f51434dfec4749bbc38322bd38b8c6e667ea7c7818f684796773aacfca3516179490ca4c21ed4bab77b86a4e6158376831bc253fbae80179fd2c98c01182b9eff0daef2fcb96b5a6a0efe21a9b4ed3f09ea4e9264ba3edc658bbf9506cf9aa3827da0979d475df7e604f94bb83a9085a74a7cd5c1a3dcba0d694094da6e5f1f5f859095c8f2e8844b71293b92af6589e95016ac1b823d04a63c7bf60e3a1ee6375f01e0a3b2f8e27dd9228a47ad4eb593446b759edb8876ba18bb4c3159eb872e8af546a6dd0d7aeea3de75f007f4e7bc8d9826a3e01a37e1569f1bed97fb5daf0b455e6175baa3d945990e769d9b678141c5b6ff1a63b28f213034708da6cda5f20954fd81582815e35c489d8dd6145c186218c722f69fa48721a9de3feef3dbc7aa68ef417513e766d06451be2f1126fce2379175829befa605e99304587e2c259b85151a7b25a5cf29e88314a45f57c7bcf1753d59698241db9a97a8118e2234642126a0204367d663301777e7ad9e0564107c1be028a9721c4e9b6e1ec2ad29cdafa18ba0dac8a60ca0207b733a74a68b0ca9b8001e22131c42c17b43ff36c3bd8c22a5a701c96105ad72b06abf9b8eefc75c86d1e70726a1e117ca5faa8dd68f3a08468025fc06377ed8d8bdee1ed687370d24dd6e7de7a9603c398176043f00b6ff0ddcd535d6f31c50bf77a0b34564c8b06edce05553179c02cb88103d2b1bf5b59ee87733b25bfac51df8bb9fffec59a968e2e93f13760cad505b28cff8762f2d95ed9618fd57f3ceb46278d018ca84ca3ffd00f063080f42ba4906ca79dc4c4273a8258f76f9f94db5eca5dab264614d15106ae152795080858a80d44b498619ea13da87538764d14659282ee0ddeccc62639fc3e24f249cc1f31aa9f0574ad212f5c82413c828c87d50ba905f9ad55bec34a0460a4e7c8e1ad2da467d431b58a4e1bcee04521a9c07008996a62dfe9159da38e2bb86da2ea13eefe1cdf5fa4add3e52a931933615b13f35711081721fd06b51ce9889621efc1c9fe80da2e6652da685aed8ad3c9e0e8b816876232fc987c3940885b4863b5c42ccf37c23c1f72cf9d1e9036eb214ef555034b7edc6c476e85ab22925c4ce619819c833350cfa3a1dc658f991113aa43c54ef420f1119ad6afb709de7c4d028f80f5b5caa21b61d3e6c845ed48213fb69052ea1b6a6011d5abe085c2a99c156176e49ef3092883c5590f1484f2565b9ca1e5c4b5ad8f7254aa094710950a2837c2357322431fa9f5f5f2b1f5d8212addd4505a363b313e73068d0aa5a9aeba168db5d0277e670de4ce5070f70812dc418079c201ca0bdd14a0d17f3b992f54ec88f1c597b491bb501eaf36b6074aef45f04e4947a91c7f2b6f0b77b86736adeea4a0f1140ef554e6bd30b1a70dc690afdc377ae7de7ac262fa21a2681fdd743867758899fce122a858fd35b15a167a630f0b468ed6b3458bd8da2fa97bee0f9ff5b4dd3806288344720e45bd68f4a07ff4ef2ac86805fe76343ad1bf886039e27aa60403651a5829268a65135af4e2684fa3f4e035c863b98c189b54566cbf5fd37df116e0b6781213bfc445c762969f230dd64e6625c25ab2bdcb915a7665f41aeface04af750539898105fa09f8fed6128a3c1dc3272637d1ea4938181e8f0b5879f6118ae29b8eb2b06613d9264fba4f68f7d1f4f06447255cc0c619292d910dd478c8bcb1a1e0e45b1198efc53d8820e0054187aa47be16dd666ed38b5e043416b002e8a8797c677161ea6429a8acc48e57e7872c968578290c0d9937dfc37c04942e3f00831736984fe38963120f6d9e4fcee07eb7c9de5acc5bd715b3677107bd2dfb20db49dcbceefdc459a3515dbc187a716fd044c01944ceb1821282f7573168a09b4b619f8de7c370d5f0198070093256c56e4ae71422e4d77101fb1ccdd4b827ef213247d4b4aef7de3e334d534680e56579645ec80326653ec33a7857c0a12ffcdd76d53b6723709f74f929f79ee5d81c31202fd8af70e0363cf0aa8077df7726919bb0f698cb247ef687a70a0e7b4bac470b80b37bbb1413f6f277390b56c6bf94587f2aba779290c93df5f21b96aa34f8380f5ee5d38620a235f8f48131a5c0c4a3079c0227ea386c85dfb449fadafdff40a8cb044be81502f59caaf51a77657ff22a890a0d330ef3b5cbb135f42de9967069a7d0b1aff35ccbc06ab2f4035a438087092e0914ee58d612e38cb5d464556cf92efad6660f0b4a4bb082d3d2da76b9f7aa4914d9d6afe8f7677382b3f442c1cf1c43acbefdfa3506cb990f9b9078e536b26941e2114aab59d44cccc431dca8b9c008ae639f902dfe0c887bb87f750600804621842ee703aef790c38f8858aecd608ac926c6cdbfd809fa6e7c9cbe4ab522ca278599ac61e94b9a37d6e49c4c7f16618b6cda490cb6af98c5524fdb8d307cd550f1dc53aae9715a8e7c6434c798c221706b1fef1b34aa0d5eba4514888c9ea84ba0eff202e426249e46022dd6bbfe4608a876f9dc182ad50f9e68deac4a6254195628eb136a2b011fe02c6caf92d02dcde5c482d1d4786bd39a7e548f9182cd2fd8ab9eae0db3f6e9a53e0e77684c205ad6c18783e18dd29fb503c66d2210ed0c961f5e643959bdd3609fed7c6eb9d0255bba773aceb1734528206e656e90c5235479105ba8a9f02375549eab710dbe5d987da05bbeb8643ae64b3623d3af843bed14f9797984e1c771bb9d81e9c49890727eb5f4d4991dceb4bf129e72d6ed23da730adea2f7431a9c1eeac52b900c85513f9bf1284cb898bd3f5abaddb2e918da50e1c4a8dc29be4d10a9b26af00e4f12743f92e8354c41ff9b12eaeb6d6e0f3c0ad10a3686e244ce3b0a3cac3ea1407510046177163ac2f9d4330ce3f5770b332f4ed7337378de27ad78ca0730e80b8d1d32f88ba7ce5dd2baf1b27b449eb592d6bd364621cc14a06811cb84c845243c5d500ffbc0c853b051f8b59bb1187b634be78f266f58d9e1765f29216192a5450b17a34b8b8c41124976ef9245d82f30dba5ea4ba3fdc1636d2d9428c4b451f3ce08c1b5871ecfcc3e7115452c00afb9a45c8063d95f5a197d7a742cf284d103e0cfaa06a8c054abea7f1983b989c58b5aff9dacc4db79fbdc9a57b02c16af166e6d051494cbe293c643317933507d2d7e2377b4a445bfab2b2e82ddef72bf3e0e5950d909330c5e36919891c577c7a10ba75d5676cb0f0b14066fd935037f88c053c8c8550e73072a418dbf335a097c688cf49074bc6951114126d65733c6f8830f5622a34dfe6e4b503b227b35271de4f950c47038cb7e96204a046576c9950ef5f096991009d592c26f7476069e5e292293a3b2873431466013064050230d3db5f0cca0c253be401dd7c941678503f4d06f4de680a9695e00ec6053c16936e2e397387f346ea484c3f3137e413b35a4c353d27f5f729c39de20894a7f2ca693bd6a630b1baaeef9ac78e9356ed9cb0ffe32164313a2f9d5ecc12d54e60f53f3558a31ff47ae003a8c0f10e73fb4dbfc6a3c4f01141391d5865b66028a98bdf91dd996ea22afa0cbf56ced31034e13673e6c6dcaffd37deb990ad20c3a2be8f8c7ff41e768cccd1416a9b31a32c834fa3765b3606f4022f8d656457fd44b0e33653e0416a0ac9254aa10b21006914cfdd3f28ef5729f935862fd95977c9da88aa02b8d021dd7e4f90bc29018c74e1286221729505f6be88e35cf2bf446b7895ebaf27744fd678bdf06d9b8e2890b0f631b22141bdf7d49271f40e57defc2dba05f8bf564ff2ab3375dd7c7d54e0bb6a23b9efcb49c61d4d2544734c6109874e74cd6bda3a35253b6350659acec1e101ddc9010d54b7080136086ca9414e90d9f119c16cca3338a6bb5d7ae43f7bb4acf3fed81ef86f1fb472884f9a4d0966a94f9efccb165ea2b644eab82b114d22872d1129887e5d908950c3077c5c44731231f94b94a0cd8da9bf014044134a2c0d157fb432e56d0495e87a483e04a12d12eec4e2a0406b875ca578597451eae91dfed10ff06ac26bfb287b9696b54a3895b0d453963b278352c042899a5a3bda31160dfeba295f44270c44865e4d941b9e7a77eab4d8c215f12d9ba7611b1d55357f1eef7d636e189c2338f7cdc3e8a05e6c6320a9f60a383f8ee3910c90ec4da7d59e53fc41ef71027a0128cf0335dbc415e00eb2e0c037ae49a6fa37d068f568cdb41b0f436d83910f631c5e31f1cd8dc83dc41eb7abba7f6d758822f89be40151e634261a1b7aa6d20ad2e93f0d9f5f147dff06c95f0ab7e64249114fee28ea1929c29ae930eca12b49aff20492a5fe3141b418bbbaed2cb94e93ba0ce92868f7c2f128358c3d84557b0fb056b3fe85f35f8c07e039bb2c3b6fe1b012317cf6e0f13db1e77c19beb7ec63f4ff4584aaaca0644a05c589a0856ca2880b967ba473a675eb438b311195a08515e63af14bdb5e7caac2a03b923fd15fa9d341dd2f03a81acce0d5109672280b04e4c5e821cbacc8336576210b843dc51d20b6d87e848df4b8a78cc7755a8c3815da9f3bb39b89768901cdaa1ede36b14d79bce661a617edfb975e35aaf5075ae25b5d9f92a45d1e4ee0b4d04b36f09299bfec61d22a67af198e8efdf2cff1b43679d291157fd8b1ff16715213a957f1bca64a5d0808d91f21d5f2ae260d8328f61529d9340f818188231b5fd12d977fbaeefb510381d459e002e82cac5daa5507c9699f7136c179254899dd2ca6d913a72359ac85e879a72f44cb65d59da52af7b0aff1d65437aaf283a5ed46960785d5d19755d1e0d8a82f86d645adb618480c5c7708aacb06c77ed4eb198a5393b1ae6c624ce41f3d31a155e15e8dfa8394fd2053227cd0dbeb13996193606db1a5bd4564ce1890b74cea14018097234a06d4ab921fc4e72faea57eb5bafc67a9ba7702a684f3b9cce9100d892ce8d4ffd37fcbe745e9120c7863f30a475982408e03472f966b5cf9f2f9a3645f6ccbe62ad943664caefb928870295bd752789d1517ad49e18dc210d35364801bb674289ca7d9bf29127dd85cfd98c34de3c3979fa2cd94979c876d9b42690f6bd4e9423894dfc800f3f1f6d95736836168e07b7298d15c9434b7a4108fd2e906dc8a0e8776080a97455ca717546b3d49fbdf36a76d11d766006d6b12f6e9852528cbb823cec2fda1df75ab00d8b059671e911e5db65973ff490f57222fd5dd79679eef6e0c86122df14496390d180be323a8cdeb4850da2f96a6cd951791f777046d719c1e08d4af54f55ab2ec8574a47afb0d798c11e23b01306216edcc1f258e9b3145a6b887ca36f1c39251acfbe93874da26ecdaba01171037b889ff1804f500f56aba801185e32e0917bc10c3d52a6a482f770a7419a0487486fff1b8a27d23fa97fe54f288a9f16380dd9ae778a7ef0efa8497d52da6ddacf4145360dcc09095108113b0e003b3722fa3345df798975e6b8e03e0838bc290546f312e5815bf6493f82db11b479a6cb6ff0aaf70233696cea90b24b89f3d7bbab514e58e2685d16dd8e657223cbc835ff2d9657ed7ce999f246e68bc3b64d7e74a262e2f070a18b786913be38959d7c633b18556f53fd212b809235efc0305d50f1c084a9a29df37d2c092d27be8d7300c7b66794c7de9f056a1a123ff33b813516bcf6f853a0bad6054a56c51b01770b5fe8f3dff57b6503081d3eb61d3d7c2f972881b8cb20c20d551e25f7693d4fd30fc65b1ae12726737c48a635091963b59124da8c263282fc6d6b314be4d4b6a840929afc2ab526965cb4e9ec0d734e0af5831be3e7037e5418d5c8d573aafca5cef81d7fc2ec83e8271660665ad10834a92ad774eb88a6fca664e765a29435ffdee830b47eaa400c69e4d4ec624382eac62a489b9f991350b7c2718523c08749b5c274b773a4806c8da4a7f56ef3c9a312e01871b9780bec69a67d3e93280512d27f896b46cda13121914c88afcfd00c5e9bb3be7d228509c36da7ae7e8be0b3a80f9f616e124b96d8a19c3a58fb4b03be00dfd5189b38d1d685e0e45a045791e7c73e2046920efeb022420fda347467b5156b2e5ce539742fea9edcde6c335570f2ca6313fdbd8262b956612468398a2fab49bee48a6234bcbb608ae7448be03e03d2ebd0eb795f9129fa19c4c0bfd8f9d01929a7560b3c99fa897503bddca646c5db892b394442dc804046cd097d527a529dbdc9219699199b8603bcba160c7092e3a01d958a958f828aff659741fb4b012a604fcd8303e478739becbc921797b1d5a92dbe9f331f377fc693fef15b80e7555abf28f5014d6a8af7ed1129790ff7c693a63350fb11278cfa72cb84bcc3485999f1a313b58b2ae8c1123ad751b894e07d25a7c0507fd2e25c209849d2ed7c64191a5b794803bf7b9c71f79873cf67264e4556e73d7f044ee9900031f73077bd3f6a2f7629dadd4a156020107b972b9a46ae681b653dead05377ed073f9fa905f33035b0e680cf4a9d3797c1eac0fb9e5f6a70e6730dfcd3926b2e1c9b11af88d7f29b4ae3fd2f3d9918a162d196188ed59c882d8d5ea71b7c51ace44b28e4ad120ab5e207a2a562db96857d6ec8761d7267f35466ca84004d331b147eca8070e5613137f3d744581369aa3b1d3fa26a5b95db71700eb2f37449ef0c58584c4adf666905d742712422da7146225c702dbf4f9e8ed75d18072e9e07f1044fd21ac910557a4a40a1dfa5e553e2196f668d3926cbebc2c72040082e9e2d2fdb330a5ba80188e143abdb091cbe7d9b8164f3789cadb83afc9ee154760a468567c839be281305613c7810826972acb400b247635b73d01e6a2bbb9ba4f6929782679d7151e0690d57aa7f19a9cea6981963408d8c42a91367924d616411622f8051770204f12bd1e0ed26b8c3c6d64485fe19dbb8c9065307bfd2a39b912b3a975da4bfefdef441fbac5eaf3d316f5f9cd014629ec976d2da137164dfde321b3691b860824bfcade8f25584e32faf3ffd6bb25750e6070e90986fdba9cdc09d5b339eb05908fade7cb5601bb376ae153bc7e7703a1500884b4f10827c5c5c575ff81293a1de6fe7a1ba0d5a39be3ae70d30d86f2fa114e769e7a4628436bf01a47e645b52d2285c3c0f2bf89302d60cdfa2c72c97c7253893ecf9bf8c20ca4be53c3722f6aaa4b0cf93832bb7b088051334015b1832b1123741c126ac6d60387156fc832df30f7190dd538946ea18789496446d4c2e5cd1b7252719b3f1cf1800046e562e34b86ec5d5f87539c05d428f655056914e198d8c1c660f8e9deb809386a67ce4f39fac39fd46731225075c4f53f3b22c8485f128be1470f02653c9ea160faf48ba942ebee21cbd1f0f1ac7f4a5c630b1b2d2cd9e8bb6f8a3ffba513f81816d26c44c852d6a002a67a2e91a7d6b6d5fee8cdbb14faa8189e8367a6d0cc9ff64fc0527025016eb5a0cbed9393b1ecefe969b1b3cc38b7d02e6c5720aad6c53a59ba61016c31b297326b181e3edcd56f672db4fe7dabb3608cb418257a0376eabe74f9ad38b93084ffa659a3145d120a7217eba9f82dd38fafd24cc52329d8adc82b0f28f0fb4c59396782e58061d5b0367513a4f34339c97f3cc98d875cae327b0d8792a36feb34ec1e893df624a7a6281255aa71e3ffbd766c9f964e8726266aaaae4e748489074cc0982e1e5310a495b3458b26988c7289193713757338e79c65b2835ceaf8881acc0c0c9967e8679767caf9f0a263c541110f67ad4e7fb6fb3cd1de353ad2bdca71a0ccaf588c69774b4ed08d02e4556e0f468a837db2da457dc07bf741865bb614b37302642b142933c76fdfc4b40802c963d629ed39e0f953da61b2375b347230180536b415a71ea2428cd51626e86393702cf06f24b404df52155ecaab67ab249db327dba54bc33826f0742d7606eda9da5e2b4513a63539e4bcedb3ddf1845993d768b521353293036b86dd7a4eb9d3b405974bab571b1487c2b0a6cd6734adb22018055a75556eb34a0bd865b53d577423e4ff6e3dad319ff4e03a7bf9c47fbe8e578ca397374a83714b565c43f373ab0486299f7c97963e6dbe05a92fb173cc37d7763a310f85fc3563db819c5c34a1514d2eaeee46f1e5c9bbfeb673972fcc6c6e9b80dcb3451b2b3908ef446e8f4da86e2c8d23bf640c0371df9e66f55bb8d418cba9a0aa0e66c81abf12f2c7e692f4aa1cc282ba7f0f5598e8bce60d6831b950557a63d779fc3b11d503bb5e3875891630ab8a57d1a7d1c487013f3446198d183f9f7a5623f71035ade07ceb690224c1ecfde634068f046065d57a5e0866e2d3a27d2d1434011a7cdd1a31012076e8a11213f772800fdf63ac02376e92f89066e20fe60d2738e3a63f9a6b6bbf6f3dc8a6cf813e12ff1e72727f121790b5b762b476332fbc4fc9ba8e73a2528569cf3efaf3d449cb0d39835d927aa4ab8a192047ea15cc8c00fa4072ebd94290965020471c831023f4636a4b1b625ccf0ae0f84bfe756527ba0540a117325704ecc150d3040c87d4ccbacdaa402e5358e9c2d4e01ac4c8b2cb2c11e1df7bc0c832d0f419a978066de9e1ea25b34351b3898a157fb1aa26c7fa8fd1944faf29bf4737976d0c98b4991c6ec842ba2ee2e99c5405cfa4a788c1d6fdc2d9ed01489537a2b89815ab24b88b7440edd1fe836b8ab0ee6c68bc8589e24f4cd9631949868dbe77b5a8ae080380884ab820992a3887fac62e32120702a2d5d67ba21c88b7f61821e073916f4e826cf9e079c597d8b9eb67e9ff58763493254dec5ef24f2389c67c26ad3b5f76938c6b356b48c8d206e5306e670dd545c7a53240c44bab4ee9f8b5b9a837f1418efa06a6e85827848871d6c24b3b7454cbde7b8a120378131e72ced75664757460f5fa032a7c5c42cb7d8be241ab5f4207517cebd5f22f94e72256ace3d3ea515aca82db227782821d2d850bee3ee84c5b31cf469b22721f1d8b22034a3421f2ae2c1efe783c3f205a19b14f3fa0f6f324b773203911c77d50bcade765f8a9ec25c854cac63507aa100cdf100b6c2eed27ced0fe54f5f63db1e2f8d4e22b1365d20b5a12a12c362ab51fa6a5586dd6379ae33e37cd3a0590682eae3817cd86a8ad643be5b691eabaeb49b0a292e69a8e6af7d5ac398170af4a3c7a93d20a9f7b3c40685d201373494deb960a8a3e14ea3c279c7d43b5fb05091d76f798bed630210e8c737f1cc94663d8f8f0949bef026b84ef0a60f4c10e7441945f47485fbe87d5deb010b1ad505247ca674bd718f5880778157ee9b2bb115f8bb4e43fc0cdcc175e9a7c67f749d94ac22535531e5015645b3d6125c5f94e61ffa86f6684fbea07f9aff47ce4d1b6be928ed9bb85f9d016ece2faf3a96e3efbb4333ea96a9f14810afea6f45e433422c8aec05c095e4034c8e4551427bc7604c629969b234510d083b8c600f30bbd42151ae7b9d3d8ca9ea64cd22fc5acb42eaa17f97df12be938e2d5fbd9c3f7913d20a1ab25ac7a573c1dda6e0681d0c0dc800c70ac6e00c145524d6d3dba8c6a0fcf86f2e557e021f09156fc6e1e03942888bf256b4a4e8ba78b70c920fbe479001db62cd18ef1c66266360027f4aef7b8a264f61765a36b0eef1081083366e592a675216cce626612b3d87d8d83e2648f3e1f304eb75cded08a03dd43447296b9d67f25ab433e7cb0fc8e8bd6cf28201c83594e1fe59283019f78b8c4054bc8ccd6d23a36b169a5443c8046f7f1388d63da14f929cb5ada719a1ba3b287ed3fb6250b26f5a4cc9e551dc9620fdde454df3efbd353817bea575d1379fbbc3d568e44748a47a379155ed24913a0add4fb425137c9fc5cae15c372628c3f8b259008aae3c2a3ff109482d67778c1f52c7cbd4ca6dbdd2de142f08c65fb8f9b97e93d0a757d147f88b43b0c042d2c438b2f8ce79ede9ccfe3b9b36a7bd0852cf6454f45455c509ba3ae99f280f6da15f9b9f858662cf9207b720b69909273a82ebe5d7baa3b5c149b87bb2935c137c2907482e8e323f2814d6ec1507b7c3c5bc18b065fb76ded4ee0fe57e57ad7491e38e2d627655a294964bd52aeb0aae99250f441cd752f3aa7bb5a91debb4a8ef8be8541bc050ad24c145019820943ca64aaf4ebf7e1a5f60c244a1364a686b6072e56699a544ffd21b3c6cb5a39ef98b9a24ccc7bdbb23fb4ba7c087aaa1f6ed478322711622a29ca6fc6a95f2cd928a1e4b1e0b977de11240fca25bd6578ad5c4e57c125cf878c9478fc460c8d6e16b94c54274bbcd62d09ba817cecad871fb17d94ac1fbb06bfc88084912db8d0ccee2a8e5f2b4360aed4d3430cadd8dfce1b4a4ff242a537e9e0e9700782ee7d8ac699df6bbc32ddeab70ef418ffb608428310445c0ca3dc9c77a58890004e60e8acc31380de3d57b77139bab2f5949c1d4e28af7198c5fd9bef805075764d223398c5faec8f2dcdd8dd5f6edb7230012274f939c653b20c419d75ed4fb9b90750fa60c307d766545e7d9814291302608495cda88a6b25066f40d279eefb109ecf386e281c61d1a5009b28df86649fb0875b97c6784bd772e4c5c52df5a01be01a2175a1927a319cda8b19e66efd49b57509ec007f1387e0373437dc729f21997a5ed33b87bf80d8a3a5e1303e99b25769258d88cd381c2a4f42b0ee75d3522693e54985c789bc51ff71e244753bb3939e23c00528dcb781665a383fc669d84af82025bc749e4f75c66d44118c16108a9eda41dc0f904cabbae007ad7186d675ed6dee78588b987e98a8e638ae18bee76f19a042e693ae8185734554b33b7caad5e89773e2862ea3b2704f93a3c38684ca0bbbbd9189cd04ab9717370c45e7ea34087ac12d25f15736cab3f3c3871f869b7e37d2cf10dab00173280380713c473645a0cb1143ea06949d81a8502a6ee830a1c2bd72b6d451d7e3c4ad75c2c3013cf9e07edbf73d665fe591016252a8838f1977dcaa7cb7d7dad9698e17f9b07705f2c0f697bc5e9bc6cdff929957ce0d7c93149fdfae4429e172f5e5082ff181117bd0b73fa2f530f1cb2c0f2ce4461f718668d88e19087737d64a0a4a6f1e12d3b56e5cef0c7d4fa6483a82e2e175b8674944b155ffa2414e2e28fc8f3fedf74571553163935ac44ddcd41ca83ead66b06ef13485cb6867b23326db6b716ba771df3015a42eff95bbbf6fc62766475025f44c694a6ba45dfa077bd5faa3c569e5db849919419d82d36798628d7d9adfdec024cb5a55a623a724cb7fc7b64c1c689557035b1ce750990faee97a1ed078c68a423df3b0e30b04e062c286a9b5a86d6a4110254459ed518384821c67408d927bc5287623982c65c3ca7f51a382c1bd312528ff2e54a525d5a3071a031c4dd5dc84449eb6a489552348f83faa91e81e60067678c50173d349de9d4f36de4182bfeba7f7690ea499758a1c481b2c7b95a128391d6c48442829c16f1c0fbf5f45ba4f4453e25996d7b15db9ff0f2ccc729e61ef84bdc0225bb807cd061e41c769851578f1fb3dfb2b52220d924d14876f010cfc5abde3c49f4dce1c457570080228664ebc63c40b968faa2e60eb991be803f5d055a474749f19c083d550f826a24639e3a40d4612e4097e13aa30bad1506b1ecbdf8a46c8a23ab5722442779ed8fd6ccd434c1796cc8bd37ed639ea963bcc0634467c77b8ef8f1f89c4a817114281182773d927d4da7b33e134ffc59a9ac4ec01cc063adf7380251b764d49f43184b7de9bcd550feeb43c775c0761dafbf160fe6dd83b36964764ec317810aedeab33d1db41351ab986bba84d27fe7d862adfcd101801f82697bee36682d7afe4ebaac3b3ee06224289949317bbf525ffa0c189ec37aff76c92abc8a2af490fe6a81d524358315ce9abed75484968eaeb3eb486a4ee177494ea53a74619ec0ca8ee93c27619a4485795ec2632d511b5040bae50a2f1fabd5491e60c5f706beab72ee0d69c8f494d95944e5a43f792dd80b96f440ddad1106d292cd0193702044e3c1c7c8084d5c64cb1988ea2bbb99d18f1db0a323da2392d605500e98de9d288929a60b2de86fd5a024c1002cd9a26fdf66eabf0df8ea851eb935eaf11ef1f79bddc70c30a206810bf51f9f3457b0dcb774b836e8ef48be255c7ee8641435415011637fe8029d7a393285e33acf87411f6664e1c28303241198495729ac9aef39867189d951e0e8cd8de7da455c5d8d5e83951a3b385e0c53c7d2c632a9da88c0c423e55d42bb0c0a8ca3a830572319e5f1334f14fd3212d1e5d69a952eb9101a1c3c3c1d5bd362f03bc7682163a19c5bc155b21897fbb54a744f5499ef82414aad4bf1f0b632ef7090ea64606ea2c73407dbc10895af2f6d21baddb75ce1e11117c0c84ed1e41c5edb6e12420f0d38b5471cced9e8c55fbffa1f4c549f4121b36c98f00830b4b08d7ae4cef7eea0b43eb7e1090738edde4694c8410f50df4e94d3a6dcdb6ee2e0c999413eb3d4d3585dbfc446a2b83961d0b7da7cea9b639c100325c63421f2b0b244ecce0d71727aba3c8ce042353cac800fffad8898bc571f8f314f353658a893ea933498851fd22409299daa8c2610c55e00a7b7a5b296c49ac331b92db6f25bd6fd79d400420e24dfcac4e84b0c6f6c3370930987b11d1df1033d1a04f2ff675fdc706d9b0ae6825d78ac8a689d615188baa3fd95255c6509e16c1d4c7caa5c18b8d97ff4e44da32d8040f0fa7d7fa56d359faad05173dfb11337fdad24556012453a4c0f93a5fb09bcf1176cfb852dcd8c0b965b06da612f2e7b096dd5b8869a74ab0968b6e3dd07e69070b296e4ad4bf6695cc3a76ab543d0b7cc671dd2782d31e815143976a81b76241e26453be0e4bef4cd6160642754ba623648c821b448bf7a425c84f654ed1007996c0501060598e81a5ac216d264de82a8e1a377f53abd9ae9170e2840cd40c7f65136483f4dbcb1a84df6daed5860f20072f11865d450cfd5ac77525673f49bd72c869a8d47cb4ded2b9baf0e2886a1fd6e73a5998e6be8cb6abe78e03ac78eaf525f5f24e02eb622cc3d049ae957caf3ebcde47e23c429c011983eb07324fbbe3425a89cf61a53d817e52fb27503dbb3cce4aadd0734a176eca81a0397010c1d7a960c1b936f665ccf89d1dbaa0255cbb31dd43a431d5027760e55d5d590cbadb645d87cb67ea6d234accf531ee196f6d4f64535adaa553da03a8e939d15312f23c7d366874a9d104658e956fefd9d31fc85f9b6ad8538ffaf7357fcecd5394e63d48ac3610c69413ced4ba318b9bc2ddd5904abecdf5dfa37d9802ee00a80524fc208b53ad2f82cd7dc410f8eb9e0a57d8c0d1ba93a9ef46b4ac4e1151d4ec7192e5e958fa8317ba35fe1bffd358da15c852580af24a014c6667f554e6a04033563eb14d94cece726c4896894efcad7900e674ab237e3f52dbba66bf5b302cefe65f7f8a376ec490aba0350f4dd4c6d1f0856e5824c26f37eeb399078284aee7d175e6674dce34c002dcb0ae1f2f018c22e2f5f78f3b03b1454dc45e92d9ebc901c7548f706679a7a9d751dbee560689b9c4b83d029a2b2b05ac8694e533dbd0838cc4d103a9a59e687193ddcd5f6f048e6e18a379dcf99b9a6dc2d33db2f2200d76d63850a1d03dbba906545155e19e3453ccabad43eecfe6b727d194f104734fde4df258a9c4280041b9df7935bf11464040d160d2a8183d5aa42cda54aeeb36b63008685600d472a055fd6acea1615da68ce65409f883ed82976155cb2f00cb4f79bfb2e50494d94bc59e8b96ee06bd4f07bd9ed7d1c2428f42c78c35f13def114bfb04f5b77e509bd2b7923aed3ce39b7fec2e5935fce9b95c02b92eff278e96f32a8f88721eafb84dd6fc2972229dbc16d13fb804deef0a6c4d7a8404740e955b36193c7b50968ab1a646f20d32dbebf98138b0444d7616b083d4441d2799361ca286e1d88139728ae40dd0ad80f2a87aaf85aeb3b0d2583882f33c188df6f5cfe92cda8aa3de36d9f08fefc5d59ff3750b6e0ce9009a0b3abb4b2651a813dd9effebb2102a026abfc6d12eff14e5c764bc3cf0cd85910fe2dbccccd8087c3266c186584ab16f3bca4433f3538132c90445ba351deb8359897a72f5d2e7c4184dc0adb4837fff18bbac5d5729dccda90a79016f3a3c0da6f84eee25bad12b9bb973f3e21aadc434e996d6006b3eece8ff22efa8f9bfe982ff7df191932224271412fe6e55f88aa3ce753fdcaa65418b88a38a65755038273db5bb30e5b1129bc74b0d29421aac164c9a85105fb8985b461afc68fe27af47e0bb096019bb21285d6ae3563cdb3be9e1cfc27ddb8668c73180482077423349b677556b07c026baf2a0dc2d35049be2ebc87b5ba3cdd6ac64d0ab8a6641c613b6f903e4fad89bbaca9b98226d75af89468121a8a640f703fc90b540620dc435e7e6ec9c7ca62b816cf5d920c9bf35b8976cb910a294b7eab488bfc780a986970f72a206121ce023f4040841fe33c455ef8f08c31de22a90366dd5899001ac718c3c80edeecf17e534f700b74c51e6b191d231b80b557b1f4882e159741545f3198ef30c782288f86d55ecaf4e0b6f20920e932e1308f6f9d3a964daae86c3d585a31f995d4725e20b8fc6a1eec12f2c96def534a3b9ceff9f56361d155610105d5a9545a399d289a722ba7122950b91206d7d4c5120b9eb3d2b81e1e60888fc6cf06b40589d4c883deeb3809981152a40da6189ec8b1ed81b321d7d6d855be7f31c9558a0083e95abd2701f8699a9ab825ecd1e7464529747f3070e023141e8ee83face7f3d86c3aff5d801329df2954ade6d3c798e0160d18d6e7205f7154fea9839193dbf80f6fe43f639cb4b46f665a48a693825b2e788b0fde5fe602076b05437a30cc4e3f08aeda448415e2297b2bb86d1f4964f86014c19a1552cc8b73ca2ec343f8c49c7cef41c0f5f901a40becb027327f36c360d7fec30e5ba69d4938f050c215cca0b43a7d1f9cdcee5d19e7aef637524991a02a24fe44953c7b4fffaa6ecad8fdf06cbd896d5ae36bdc4bd6b60325ed77c71b5df174836d0f5a6ebb7b3c6527b08f0b6feea9f1ab3c41fd3f77a4513621620476ae28d0c8f4b192154634875a0647f719c516c742b8b09f1fcc76b95a22c6b809cbe72e6bd28c2d0e2651e0cc6c1341d0b6b60b3774b716dfafc865530fc9ee4b36e947b28ff711a990992d6a00ee2a5d4bd6512c531335fe7d355e4c35b3b5907933330f14fb6efe12f681e15019dac1a37dfbac4551a76473d57432a1d91217e1246637c1792c89fdcfbe6e6b5098098faebfc5f33595268edcd82009f7a05930b869245afb49d0592889088d5ab43f7927c3c5f45ab5091ffb717056d233f1eee40ec7b2eb14a63a8a86aacc44d7f554b4d2b20cb0b26ce1346a83f23b59f2f7a9207c304a0c2af87dfc42d2101bbd0d3131564f8c12ca38f7883f4e6d5b86f2c9b7d46fe45aad05ca895fa86d2d9cf48c9600536ffc13ce62bba26e0a5fc4b6a8c54de6fa43d25e8eb1789d4005a5f753166662d83094b21f76a667898541d7b7171bbe1740bb74d7c402cff2da7d52a474047a9022bb7bcdeeafab3880bd39cc8dccc8c863f39a76f650d8cc48d80493e743f8d841581b2e2d3b7234fbd53364a787971571de465201b8664a91267c2b0c3e746c8e97ba2ad0bd072df1840efc1f1c9fe8a8b273c92a0b96cfa57817268979d4b036efe47942824d650e766471263a6046922cb4d9fb73ead8e2d8571c2b8b1c0213e76a788a07574a1c97bd50e3e9afe7d4b3bfb8f4dd4fc95944115296b3c64242a5c38c7538c776b040e777605ce50575d5520088d906693b839e1eca432525a54936b9777ab9fb1ddaa0cc60e57385cb7ff51a7a2767cd14a0d8c9e0aef6fa36dc64d3e90e430565aff9815aa6ce5090b25dc8095db2613014a672d4aa95b07a6ee8212274483c59b6a3ccb90dab38033c0094bca72c083d9b40adaae71dd7f0d3570ce41ddf673518dcdf8db7f6c7e34d574f9e5b2cf39e047e546592a99dfecb102cf34bc033f59fb629093c68f281c3eb0baa30eab7e01e23893373ce53995da896fe3cf1b7c4295265d79173a09cc8ec2c9428d9e9dbe9e2ad36524fc471c5effe1568d7e4b004d2e5e057edc2f655ea8ef05534a32c2f847566ead3a956ccb0aef0e6141f510d35fe0d9f4e8da4b88a238a0b8be3dd4a555082dd30631546cf5a475d165503cbeacbb4827e3973b1fa0750a50c502899f62cdfe0e9e1d66c21144037cacbef44fbf35514e45fedfa7bc921a3ce6c8d80d0b67d51715cacaca243fdc0696eab1323c293618df76898dbd65df2d0a2ba9331e6e372804ba3aa97ea6a1e6f16d86efd9430239403b31981ba2787967f43fa93198a3c9744184621d8122b3fc9db96323c3b4eff1d00bb453628ae8ced08ce8d775f6b512afc057b94084396b3418260bf87e874ff549b12e2654e602f58d91e2a4da20120396726cae98cfd6bebc0dba510ba08177999778468ad509cb65054e625654a79bb45359388e3f736e2a9a7ab632793e8c54579a0113bc67b2dd5f3d4f72cc16703b62fa5ff0a53e29be525f7605e5a2c4fb35c44245b9e536d3394a29d74fdb60360bcae5343db8ed36092103518c99a46a6836a60a57ac20537c4e51a62df264a572f4c47a5c6152b1a08f9a25ff7aec5b9fc9f49a25db7deb70db0fb0f0776590350ce4ba614a2f671758bb9098551521db330b710838ce68d47211e45bcb00dc8d41b91abaac7c10fc8b91e78c0c952d4ebd96b102d93940cd0174d0fe77785f2058569bcb518bd8dad54c99d745b95225d0a5057275324c32007979b0707b0a44b8075fbaacfb04895e85a2233855f3760ad091933618873c979eb6782180beb48673ced9e8e944f96f40672a4e4374fe56a1b1923d6f4d77966ecbef030f72634e4b28aa9ac48f74c47eefd4de55cc1a8c59bf17a21befd77bc034a6be97f1db27fdffd93c7a751fa9ca4a107ee59fd91ebcdef58a22b492e075e16d3a709b52e13c3aa06bc114a43fa7bd001a9c410ec57d65f7205bcc68e63e83be97094c3b96441f9bc2c77f936a14e66bc584add7169c5b317086e40b260adc051956a5987888f12b9dd50d99f9004862b4a4eca16fc2004eec61a90f87a44fa84f6c72f3c1f6adbc5e303f1f64bbd0105ff69f5e045df7f2a09aa24340e041ea805289d33a5caa5abd00327586f20bc0460bdad6d8a368879206f70234ea7a7cf43ff9955928ebc0d2abe556672107a989b468383e97b8af7ad2bbb8e6d4e979fde95e5019a610bd95227fd8d90bfce5a09a7eea6303beb2ed848e53a14ece833777e1f4c6bce5887ae4acf4ca01a942076079a6961d9fca7e1a7f060925d5c4cc3917bfd4bc7171084988378e862d6dd5486c25672135e20a2e887fad5e9a55c60edc6da59d2c1ca6b82c9d6058c0603f550b1885dd4bcb5ed6c264d6d7aad08f9846204661b2cf5eba9701d694dd1ce7c95bfb69f2b5ee3a781a10ffbb402ef1d1af35e8d0ef00529a5cd377080da6836258cacb6bdb9dfd612f6334555bbf45d166317d2be355b14b01c9e150b8c7f221cac6ab06dcebaeae611501d55d0703a8f08b88ba4c142107f269d8aa1ddfaaee74a7fc8ec014a7d397a8c122c8df94744f5f8f8d3244726a2bb8ca3ea21bf5825e6195f2f278c66d1b4db383a386427</script></div><script src="/code/lib/blog-encrypt.js"></script><link href="/code/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="Data Structure" scheme="https://miohitokiri5474.github.io/code/tags/Data-Structure/"/>
    
      <category term="Segment Tree" scheme="https://miohitokiri5474.github.io/code/tags/Segment-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Golang心情隨筆 #1</title>
    <link href="https://miohitokiri5474.github.io/code/gd-1/"/>
    <id>https://miohitokiri5474.github.io/code/gd-1/</id>
    <published>2019-11-08T07:28:17.000Z</published>
    <updated>2020-02-23T09:11:12.550Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>我也有點忘記我最初為什麼會接觸 Golang 了<br>應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現<br>像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？<br><a id="more"></a><br>而且學到的理由也是莫名其妙，我本來請我媽幫我訂書，我丟了幾本書單給她<br>其中好像就有一本Golang的語法書<br>雖然後來我跟他說那一本先不用，但是我媽還是幫我訂了<br>所以我就開始翻了起來<br>起初我最不能接受的一點是在用如 Scanf, Printf 等等的函數前面還要先打 package 名稱<br>像是我可以在 C 裡面 #include<stdio.h> 後，然後就直接用標頭檔裡面的函數<br>不過在 Golang 裡面做的事情像是這樣： stdio.Scanf ( “%d”, &n ) 之類的<br>（嚴格來說應該是 fmt.Scanf ( “%d”, &n )）<br>但是後來慢慢就習慣了，反正要說最麻煩的語言絕對是Java沒錯ww<br>明明就只是要 print 個 Hello, World! 要寫 class ww</stdio.h></p><p>.</p><p>最近比較有空，所以想說來複習一下 Golang 怎麼寫（？<br>論一個語言怎麼學最快，當然是學會基礎後拿它來做任何事情，像是打演算法競賽<br>或者是拿它來寫程設作業<br>什麼？只能用 C 寫喔<br>沒關係啊，我用 C 產一份 Golang 檔案出來不就好了（Ｘ</p><p>不過後來這個想法就不了了之了，因為沒有權限裝 Golang 的編譯器</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我也有點忘記我最初為什麼會接觸 Golang 了&lt;br&gt;應該是被「內建平行運算」這個功能燒到了吧，就有點好奇平行運算要怎麼實現&lt;br&gt;像是以前寫的語言如 C++，或是摸過一陣子的 Swift 3, Perl, Python 等等都是線性處理的（？&lt;br&gt;
    
    </summary>
    
    
      <category term="Golang" scheme="https://miohitokiri5474.github.io/code/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>C語言中 char 字串轉換成數字</title>
    <link href="https://miohitokiri5474.github.io/code/C-atoi/"/>
    <id>https://miohitokiri5474.github.io/code/C-atoi/</id>
    <published>2019-09-17T16:46:41.000Z</published>
    <updated>2019-10-26T08:47:35.282Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字<br><a id="more"></a></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>使用內建函數atoi</li><li>自己寫</li></ol><p>內建函數的用法可以去cpprefrence查到，所以這邊就不解說了<br>只有講自己寫的做法</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果要在一個數字的尾端加上一位數，該如何操作？<br>有一種方法：先把原數字 * 10，然後再把那一位數加上去<br>所以就可以有下面這種code</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">translate</span> <span class="params">( <span class="keyword">char</span> *c, <span class="keyword">int</span> len )</span></span>{</span><br><span class="line"><span class="keyword">int</span> i, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i < len ; i++ ){</span><br><span class="line">res *= <span class="number">10</span>;</span><br><span class="line">res += ( c[i] - <span class="string">'0'</span> );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然後解說一下code中第五行<br>char之間的相減就是ASCii code的值的差<br>所以可以用這種方法把原本的數字還原出來</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天來簡單介紹一下要如何在C語言中把 char 字串轉換成數字&lt;br&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://miohitokiri5474.github.io/code/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>[APCS] 2019年六月場實作題詳解</title>
    <link href="https://miohitokiri5474.github.io/code/APCS-19-06/"/>
    <id>https://miohitokiri5474.github.io/code/APCS-19-06/</id>
    <published>2019-06-24T09:44:23.000Z</published>
    <updated>2019-10-26T10:41:37.933Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因為想要拼5 + 5，於是又報名了這次的APCS<br>至於成績如何那就晚點再說吧，算是個小伏筆（？</p><a id="more"></a><p>即便考場在家附近，我還是提早出門了<br>還以為考場一樣在成大的資工系大樓，還在想說為什麼今天進不去，不是有APCS嗎<br>趕快google一下才發現跑錯棚了，應該是在校區的另一邊<br>所以我又趕快跑過去，差一點點遲到<br>好險有提早出門（汗</p><img src="/code/APCS-19-06/img.jpg" title="因為不想要縮圖是我的成績單，所以我就放這張圖了"><h2 id="problem-1"><a href="#problem-1" class="headerlink" title="problem 1"></a>problem 1</h2><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>給定兩場籃球賽雙方每一節的比分（每場籃球賽各四節<br>求出主場最終的輸贏</p><ol><li>兩場全贏：勝</li><li>兩場全敗：敗</li><li>一勝一敗：平手</li></ol><p>保證輸數皆為正整數且每場比賽不會有雙方比分相同的問題</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>直接實作一下就好了</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, ans = <span class="number">0</span>, swp;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < <span class="number">4</span> ; i++ ){</span><br><span class="line">        <span class="built_in">cin</span> >> swp;</span><br><span class="line">        a += swp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < <span class="number">4</span> ; i++ ){</span><br><span class="line">        <span class="built_in">cin</span> >> swp;</span><br><span class="line">        b += swp;</span><br><span class="line">    }</span><br><span class="line">    ans += ( a > b ? <span class="number">1</span> : <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    a = b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i < <span class="number">4</span> ; i++ ){</span><br><span class="line">        <span class="built_in">cin</span> >> swp;</span><br><span class="line">        a += swp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i < <span class="number">4</span> ; i++ ){</span><br><span class="line">        <span class="built_in">cin</span> >> swp;</span><br><span class="line">        b += swp;</span><br><span class="line">    }</span><br><span class="line">    ans += ( a > b ? <span class="number">1</span> : <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !ans )</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Draw"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( ans > <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Win"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Lose"</span>;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-2"><a href="#problem-2" class="headerlink" title="problem 2"></a>problem 2</h2><h3 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a>題目</h3><p>給定一張圖，起點為整張圖權重最小的點<br>並規定如果可以從點$A$移動到下一個點點$B$，若且唯若點$B$為點$A$的可連接點中，權重最小的點<br>然後路徑上點不能重複<br>求出路徑的總權重</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>dfs裸題，UVa有類似的題目（題號我忘記了<br>反正就是模擬一次就對了（也沒有其他解法啊(ry</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">105</span>; <span class="comment">// 大小我忘記了</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">// INF大於值域，又可直接memset，方便又實用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[maxN][maxN];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> y, LL sum )</span></span>{</span><br><span class="line">    <span class="comment">// 先找出最低點</span></span><br><span class="line">    <span class="keyword">int</span> mi = min ( min ( mp[x + <span class="number">1</span>][y], mp[x - <span class="number">1</span>][y] ), min ( mp[x][y + <span class="number">1</span>], mp[x][y - <span class="number">1</span>] ) );</span><br><span class="line">    sum += mp[x][y];</span><br><span class="line">    mp[x][y] = INF;</span><br><span class="line">    <span class="keyword">if</span> ( mi == INF )</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span> ( mp[x + <span class="number">1</span>][y] == mi )</span><br><span class="line">        <span class="keyword">return</span> dfs ( x + <span class="number">1</span>, y, sum );</span><br><span class="line">    <span class="keyword">if</span> ( mp[x - <span class="number">1</span>][y] == mi )</span><br><span class="line">        <span class="keyword">return</span> dfs ( x - <span class="number">1</span>, y, sum );</span><br><span class="line">    <span class="keyword">if</span> ( mp[x][y + <span class="number">1</span>] == mi )</span><br><span class="line">        <span class="keyword">return</span> dfs ( x, y + <span class="number">1</span>, sum );</span><br><span class="line">    <span class="keyword">if</span> ( mp[x][y - <span class="number">1</span>] == mi )</span><br><span class="line">        <span class="keyword">return</span> dfs ( x, y - <span class="number">1</span>, sum );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, x, y, mi = INF;</span><br><span class="line">    <span class="built_in">memset</span> ( mp, INF, <span class="keyword">sizeof</span> mp );</span><br><span class="line">    <span class="built_in">cin</span> >> n >> m;</span><br><span class="line">    <span class="comment">// 1 index，可以直接免去判斷邊界的麻煩</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i <= n ; i++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span> ; j <= m ; j++ ){</span><br><span class="line">            <span class="built_in">cin</span> >> mp[i][j];</span><br><span class="line">            <span class="keyword">if</span> ( mi > mp[i][j] )</span><br><span class="line">                mi = mp[i][j], x = i, y = j;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << dfs ( x, y, <span class="number">0</span> ) << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-3"><a href="#problem-3" class="headerlink" title="problem 3"></a>problem 3</h2><h3 id="題目-2"><a href="#題目-2" class="headerlink" title="題目"></a>題目</h3><p>給定$N$個字串，且這$N$個字串只會由前$M$個字元組成，字元由$A$開始<br>請求出每一對可以組成互補字串的數量<br>且字串是一個集合，也就是說，即便元素有重複還是只算一個，也不計較排列<br>所以$AAB$與$AB$與$BA$都是相同的字串</p><h4 id="定義一下互補字串"><a href="#定義一下互補字串" class="headerlink" title="定義一下互補字串"></a>定義一下互補字串</h4><p>假設字串$A$中的元素沒有出現在字串$B$中<br>同時，字串$B$的元素也沒有出現在字串$A$中<br>則稱$A \text& B$為互補字串</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><h4 id="解法一：硬幹"><a href="#解法一：硬幹" class="headerlink" title="解法一：硬幹"></a>解法一：硬幹</h4><h5 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h5><p>之所以會稱為是硬幹，是因為在找查互補字串的時候是硬著做的</p><h5 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> < <span class="built_in">string</span>, <span class="keyword">int</span> > lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str, basic;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> n >> m;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < m ; i++, c++ )</span><br><span class="line">        basic += c;</span><br><span class="line">    <span class="keyword">while</span> ( n-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> str;</span><br><span class="line">        <span class="comment">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class="line">        sort ( str.begin(), str.end() );</span><br><span class="line">        <span class="comment">// 這邊則是要把重複的字元壓掉</span></span><br><span class="line">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class="line">        lib[str]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> j: lib ){</span><br><span class="line">        str = basic;</span><br><span class="line">        <span class="comment">// 把出現過的直接刪掉</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: j.F )</span><br><span class="line">            str.erase ( lower_bound ( str.begin(), str.end(), i ) );</span><br><span class="line">        ans += j.S * lib[str];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因為會重複計算到兩次    </span></span><br><span class="line">    ans /= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="方法二：Xor"><a href="#方法二：Xor" class="headerlink" title="方法二：Xor"></a>方法二：Xor</h4><h5 id="說明-1"><a href="#說明-1" class="headerlink" title="說明"></a>說明</h5><p>因為原本的方法太智障了（？<br>如果不是因為資料量小可以這樣做，資料量一大直接吃土</p><p>出來之後聽到有人是這樣做的，有點類似Hash的做法<br>把字串轉成二進位，如果這個字元有出現過就是$1$，反之，就是$0$<br>然後為了方便運算會把這個二進位reverse</p><p>也就是說，$ACD$會轉成$(1101)_2$，而$ABD$會轉成$(1011)_2$，$BD$會轉成$(1010)_2$<br>然後再把二進位轉成十進位<br>這樣就可以很輕鬆的用一個$int$來作儲存了，而且可以直接用$Xor$來取互補字串</p><h5 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> < <span class="keyword">int</span>, <span class="keyword">int</span> > lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">translate</span> <span class="params">( <span class="built_in">string</span> str )</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: str )</span><br><span class="line">        res |= ( <span class="number">1</span> << ( i - <span class="string">'A'</span> ) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>, ori = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> >> n >> m;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < m ; i++ )</span><br><span class="line">        ori |= ( <span class="number">1</span> << i );</span><br><span class="line">    <span class="keyword">while</span> ( n-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> str;</span><br><span class="line">        <span class="comment">// 這邊為了要把順序都統一，所以先做一下排序</span></span><br><span class="line">        sort ( str.begin(), str.end() );</span><br><span class="line">        <span class="comment">// 這邊則是要把重複的字元壓掉</span></span><br><span class="line">        str.erase ( unique ( str.begin(), str.end() ), str.end() );</span><br><span class="line">        lib[translate ( str )]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> j: lib )</span><br><span class="line">        ans += ( j.S * lib[ori ^ j.F] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因為會重複計算到兩次    </span></span><br><span class="line">    ans >>= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意，這份code並沒有經過詳細測試，可能有誤</strong></p><h2 id="problem-4"><a href="#problem-4" class="headerlink" title="problem 4"></a>problem 4</h2><h3 id="題目-3"><a href="#題目-3" class="headerlink" title="題目"></a>題目</h3><p>給定一個長度為$N$的序列，求給定數字$M$長度，且其中所有數字都不重複的連續子序列數量</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>Slide Window裸題，不過關於實作又有兩種做法</p><h4 id="方法一：固定Window大小"><a href="#方法一：固定Window大小" class="headerlink" title="方法一：固定Window大小"></a>方法一：固定Window大小</h4><p>把window大小固定為$M$，並且開一個set紀錄這個window的數字<br>要把數字從前端pop掉時，記得檢查這個數字在後頭是否出現過<br>然後不想要用map，所以離散化一下，這樣就可以用陣列儲存了</p><h4 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> n >> m;</span><br><span class="line">    <span class="built_in">vector</span> < <span class="keyword">int</span> > data ( n ), lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: data )</span><br><span class="line">        <span class="built_in">cin</span> >> i;</span><br><span class="line">    <span class="comment">// 離散化</span></span><br><span class="line">    lib = data;</span><br><span class="line">    sort ( lib.begin(), lib.end() );</span><br><span class="line">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: data )</span><br><span class="line">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> < <span class="keyword">int</span> > q;</span><br><span class="line">    <span class="built_in">set</span> < <span class="keyword">int</span> > s;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ ){</span><br><span class="line">        q.push ( data[i] );</span><br><span class="line">        s.insert ( data[i] );</span><br><span class="line">        cnt[data[i]]++;</span><br><span class="line">        <span class="keyword">if</span> ( q.size() >= m ){</span><br><span class="line">            cnt[q.front()]--;</span><br><span class="line">            <span class="keyword">if</span> ( !cnt[q.front()] )</span><br><span class="line">                s.erase ( q.front() );</span><br><span class="line">            q.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ( s.size() == m )</span><br><span class="line">            ans++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="方法二：不固定的window大小"><a href="#方法二：不固定的window大小" class="headerlink" title="方法二：不固定的window大小"></a>方法二：不固定的window大小</h4><p>此方法由吳邦一教授提出（<a href="https://brian.su/r/APCS-2019-06-P4" target="_blank" rel="noopener">原文連結</a>）<br>由左往右把數字push進window，如果遇到已經在window裡面的數字，則一路pop到該數字離開window為止</p><h4 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> n >> m;</span><br><span class="line">    <span class="built_in">vector</span> < <span class="keyword">int</span> > data ( n ), lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: data )</span><br><span class="line">        <span class="built_in">cin</span> >> i;</span><br><span class="line">    <span class="comment">// 離散化</span></span><br><span class="line">    lib = data;</span><br><span class="line">    sort ( lib.begin(), lib.end() );</span><br><span class="line">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: data )</span><br><span class="line">        i = lower_bound ( lib.begin(), lib.end(), i ) - lib.begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 這邊的話就不用set了    </span></span><br><span class="line">    <span class="built_in">queue</span> < <span class="keyword">int</span> > q;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ ){</span><br><span class="line">        <span class="comment">// 不斷pop直到這個數字前面沒有出現過</span></span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() && cnt[data[i]] ){</span><br><span class="line">            cnt[q.front()]--;</span><br><span class="line">            q.pop();</span><br><span class="line">        }</span><br><span class="line">        q.push ( data[i] );</span><br><span class="line">        cnt[data[i]]++;</span><br><span class="line">        <span class="keyword">if</span> ( q.size() == m )</span><br><span class="line">            ans++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>其實我把所有題目寫完之後，大概才過41分鐘<br>然後為了要確定code都沒有爛，還特地多花一個小時半左右吧，在寫對拍，想要抓抓看bug<br>接著我就發現我在裡面多花快一個半小時，然後一個字元都沒有改到<br>也就是說，我在裡面燒機燒了一個半小時然後產量是零<br>抓到，澪人桐是燒機大師<br>早就知道出來玩手機算了 = =</p><p>.</p><p>看到這邊多多少少都會對我的成績有點興趣吧（？<br>（不然如果他成績跟垃圾一樣，到底浪費時間看這篇文章幹嘛<br>話不多說我直接上圖好了</p><p><img src="score.png" alt></p><p>差一題觀念5+5<br>搞什麼 = =</p><p>以前我有過觀念五，但是那次實作沒有考好，這次換觀念沒有五，我該注意什麼<br>（欸，差不多是一年前的六月場欸OAO</p><p>雖然按照官方的說法這樣也算是5+5啦，不過沒有單場5+5真的有點可惜<br>那麼今天就到這邊了，謝謝各位今天的閱讀<br>如果需要更多的說明（無論是否是這次的題目，或是該如何準備APCS）的話，都歡迎寫email給我<br>我的email可以在我的<a href="https://miohitokiri5474.github.io/code/about/">個人頁面</a>找到<br>p.s. 我今天寫好長的文章喔，到這邊已經430行了</p><p>本來用Typora編輯，那個md編輯軟體好像會自動幫我加上一大堆的空行，大概就是打完一行就會有一行空行<br>所以原本的文章看起來很很空<br>還需要自己手動調整，有點小麻煩<br>不過他可以即時顯示md的渲染結果，真的讓人難以抉擇</p><h2 id="更新（2019-07-04-10-28）"><a href="#更新（2019-07-04-10-28）" class="headerlink" title="更新（2019/07/04 10:28）"></a>更新（2019/07/04 10:28）</h2><p>之前可以查詢成績好像是bug，官方是說今天早上十點才可以查<br>剛剛查了一下，發現級距出來了，在這邊附上（上次查的沒有級距可以看）</p><img src="/code/APCS-19-06/per.png" title="2019年六月場級距"><h2 id="圖片出處"><a href="#圖片出處" class="headerlink" title="圖片出處"></a>圖片出處</h2><ol><li>紅色鳥居：神奈川縣蘆之湖<a href="https://www.instagram.com/kaji_nori06/" target="_blank" rel="noopener">kaji_nori06</a></li><li>成績單。。。等等，這張就我的成績單啊，沒有什麼出處問題吧</li><li>級距。。。啊就從成績單上截圖截下來的啊 = =</li></ol></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因為想要拼5 + 5，於是又報名了這次的APCS&lt;br&gt;至於成績如何那就晚點再說吧，算是個小伏筆（？&lt;/p&gt;
    
    </summary>
    
    
      <category term="APCS" scheme="https://miohitokiri5474.github.io/code/tags/APCS/"/>
    
      <category term="Full Contest Solution" scheme="https://miohitokiri5474.github.io/code/tags/Full-Contest-Solution/"/>
    
  </entry>
  
  <entry>
    <title>Google Code Jam 2019 Qualification Round</title>
    <link href="https://miohitokiri5474.github.io/code/GCJ-2019-QuR/"/>
    <id>https://miohitokiri5474.github.io/code/GCJ-2019-QuR/</id>
    <published>2019-04-09T07:21:21.000Z</published>
    <updated>2019-10-26T08:47:35.284Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）<br>然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了</p><p>只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了<br><a id="more"></a><br>下一場是在這週六晚上九點～十一點半<br>撞到補習有點慘（九點下課），我想一下要怎麼跟老師交涉一下，讓我提早走</p><p>總之，過 Qualification Round 應該就算比去年好了<br>去年在耍廢直接爆炸。。。</p><p>希望今年可以去 Round 2</p><p>先放上這次的<a href="https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705" target="_blank" rel="noopener">題目連結</a></p><h2 id="problem-A"><a href="#problem-A" class="headerlink" title="problem A"></a>problem A</h2><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>現在有個鍵盤的數字，現在數字 $4$ 的按鍵壞了<br>然而現在有數字要輸入，求分成兩個數字其總和等於原數、且兩數字中皆不可出現 $4$<br><strong>多筆測資</strong></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>顯而易見的，這是大水題，輸入還開到 ${10} ^ {100}$<br>一臉就是在跟你說開 string 存啊<br>所以我們先把數字讀進來，然後檢查每個 digital ，遇到 $4$ 就先把他拆成 $3$ 跟 $1$<br>然後把這兩個數字輸出<br><strong>注意不能有前導零</strong></p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, mi;</span><br><span class="line">    <span class="built_in">string</span> n;</span><br><span class="line">    <span class="built_in">cin</span> >> t;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> tms = <span class="number">1</span> ; tms <= t ; tms++ ){</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Case #"</span> << tms << <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> >> n;</span><br><span class="line">        mi = INF;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n.size() ; i++ ){</span><br><span class="line">            <span class="keyword">if</span> ( n[i] == <span class="string">'4'</span> ){</span><br><span class="line">                mi = min ( mi, i );</span><br><span class="line">                <span class="built_in">cout</span> << <span class="string">'3'</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> << n[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = mi ; i < n.size() ; i++ )</span><br><span class="line">            <span class="built_in">cout</span> << ( n[i] == <span class="string">'4'</span> )</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h3><p>我還沒有注意到這題有保證輸入有 $4$<br>也沒有注意到這題要求輸出都要是正整數<br>運氣真好，歪歪得正</p><h2 id="problem-B"><a href="#problem-B" class="headerlink" title="problem B"></a>problem B</h2><h3 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a>題目</h3><p>給定一張二維圖以及一條從左上到右下的路線<br>求一條不重複的另外一條路線<br>所謂的路線重複是指 $a \to b$ 這個邊同時出現在兩條路線中<br>然後輸入都是SESE這樣，代表從起點開始他往哪些位置走<br>並且保證只會往東（右）以及往南（下）走<br>詳細請看這張圖<br><img src="pB.jpg" alt></p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><h4 id="O-N-2"><a href="#O-N-2" class="headerlink" title="$O ( N ^ 2 )$"></a>$O ( N ^ 2 )$</h4><p>垃圾如我，肯定只會寫 $N ^ 2$ 的解法<br>簡單來說就是 dp<br>我一開始定義 $dp[i][j]$ 代表從 $( 1, 1 )$ 走到 $( i, j )$ 需要經過的路線，用 string 存<br>然後就 MLE 了，所以我又加上滾動（因為每次要轉移只會用到上一行的資料，也就是說再前面的資料通通丟掉沒關係）<br>接著又 TLE 了，因為 string + char 這樣的操作本來就容易 TLE （？）<br>所以我又改成， $dp[i][j]$ 應該從哪轉移過來（紀錄 $S$ 或 $E$ ），最後從終點回朔回起點</p><p>不過這樣做有小地方需要注意一下<br>理論上來說，$dp[i][j]$ 可以從 $dp[i - 1][j]$ & $dp[i][j - 1]$ 轉移過來<br>所以無法處理題目要求的不重複路徑，於是我先把原本的路徑打印在圖上<br>如果 $( i, j )$ 有被原路徑經過，那麼就不要從也有被經過的點轉移過來<br>但是因為我懶得寫特判<del>（明明就是自己懶）</del>所以即便這個點無法從起點到達，還是會有路線（但是回朔回去可能不會到起點）<br>因此又要特判（相較之下好寫很多），如果兩邊都可以拿，拿路徑比較長的那一邊來做轉移<br>啊如果還是都可以拿，那就真的隨便了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">typedef</span> pair < <span class="keyword">short</span>, <span class="keyword">char</span> > psc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> lib[maxN][maxN];</span><br><span class="line">psc str[maxN][maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n, x, y;</span><br><span class="line">    <span class="built_in">string</span> data;</span><br><span class="line">    <span class="built_in">cin</span> >> t;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> tms = <span class="number">1</span> ; tms <= t ; tms++ ){</span><br><span class="line">        <span class="built_in">cin</span> >> n >> data;</span><br><span class="line">        <span class="built_in">memset</span> ( lib, <span class="number">0</span>, <span class="keyword">sizeof</span> lib );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i <= n ; i++ ){</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j <= n ; j++ ){</span><br><span class="line">                str[i][j] = mp ( <span class="number">0</span>, <span class="string">' '</span> );</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data ){</span><br><span class="line">            lib[x][y] = <span class="literal">true</span>;</span><br><span class="line">            i == <span class="string">'S'</span> ? x++ : y++;</span><br><span class="line">        }</span><br><span class="line">        lib[x][y] = <span class="literal">true</span>;</span><br><span class="line">        str[<span class="number">1</span>][<span class="number">1</span>] = mp ( <span class="number">0</span>, <span class="string">' '</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> ; i <= n ; i++ ){</span><br><span class="line">            <span class="keyword">if</span> ( lib[<span class="number">1</span>][i] ){</span><br><span class="line">                <span class="keyword">if</span> ( !lib[<span class="number">1</span>][i - <span class="number">1</span>] ){</span><br><span class="line">                    str[<span class="number">1</span>][i] = str[<span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">                    str[<span class="number">1</span>][i].F++;</span><br><span class="line">                    str[<span class="number">1</span>][i].S = <span class="string">'E'</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                str[<span class="number">1</span>][i] = str[<span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">                str[<span class="number">1</span>][i].F++;</span><br><span class="line">                str[<span class="number">1</span>][i].S = <span class="string">'E'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> ; i <= n ; i++ ){</span><br><span class="line">            <span class="keyword">if</span> ( lib[i][<span class="number">1</span>] ){</span><br><span class="line">                <span class="keyword">if</span> ( !lib[i - <span class="number">1</span>][<span class="number">1</span>] ){</span><br><span class="line">                    str[i][<span class="number">1</span>] = str[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                    str[i][<span class="number">1</span>].F++;</span><br><span class="line">                    str[i][<span class="number">1</span>].S = <span class="string">'S'</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                str[i][<span class="number">1</span>] = str[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                str[i][<span class="number">1</span>].F++;</span><br><span class="line">                str[i][<span class="number">1</span>].S = <span class="string">'S'</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">2</span> ; j <= n ; j++ ){</span><br><span class="line">                <span class="keyword">if</span> ( lib[i][j] ){</span><br><span class="line">                    <span class="keyword">if</span> ( !lib[i][j - <span class="number">1</span>] ){</span><br><span class="line">                        str[i][j] = str[i][j - <span class="number">1</span>];</span><br><span class="line">                        str[i][j].F++;</span><br><span class="line">                        str[i][j].S = <span class="string">'E'</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span>{</span><br><span class="line">                        str[i][j] = str[i - <span class="number">1</span>][j];</span><br><span class="line">                        str[i][j].F++;</span><br><span class="line">                        str[i][j].S = <span class="string">'S'</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">if</span> ( str[i][j - <span class="number">1</span>].F > str[i - <span class="number">1</span>][j].F ){</span><br><span class="line">                        str[i][j] = str[i][j - <span class="number">1</span>];</span><br><span class="line">                        str[i][j].S = <span class="string">'E'</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span>{</span><br><span class="line">                        str[i][j] = str[i - <span class="number">1</span>][j];</span><br><span class="line">                        str[i][j].S = <span class="string">'S'</span>;</span><br><span class="line">                    }</span><br><span class="line">                    str[i][j].F++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        data = <span class="string">""</span>;</span><br><span class="line">        x = y = n;</span><br><span class="line">        <span class="keyword">while</span> ( str[x][y].S != <span class="string">' '</span> ){</span><br><span class="line">            data += str[x][y].S;</span><br><span class="line">            str[x][y].S == <span class="string">'S'</span> ? x-- : y--;</span><br><span class="line">        }</span><br><span class="line">        reverse ( data.begin(), data.end() );</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Case #"</span> << tms << <span class="string">": "</span> << data << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="O-N"><a href="#O-N" class="headerlink" title="$O ( N )$"></a>$O ( N )$</h4><p>沒錯，$O ( N )$<br>我後來才發現我TMD被哏到了<br>只要把 S E 反轉就好啊<br>讀到 S 輸出 E ，反之讀到 E 輸出 S<br>這樣就會變成從左上到右下的對稱<br>所以路線不會重複。。。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> >> t;</span><br><span class="line">    <span class="keyword">while</span> ( t-- && <span class="built_in">cin</span> >> n >> str ){</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: str )</span><br><span class="line">            <span class="built_in">cout</span> << ( i == <span class="string">'S'</span> ? <span class="string">'E'</span> : <span class="string">'S'</span> );</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-C"><a href="#problem-C" class="headerlink" title="problem C"></a>problem C</h2><p>感謝 <a href="https://www.facebook.com/enminghuang1" target="_blank" rel="noopener">En-ming Huang</a> 大大提供<br>要 solution 請去找他</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> input[maxN], l;</span><br><span class="line"><span class="keyword">char</span> out[maxN][<span class="number">2</span>], print[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">( <span class="keyword">int</span> idx, <span class="keyword">char</span> now )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( idx == l ){</span><br><span class="line">        <span class="built_in">cout</span> << print << <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < <span class="number">2</span> ; i++ ){</span><br><span class="line">        <span class="keyword">if</span> ( out[idx][i] != now )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        print[idx] = out[idx][i];</span><br><span class="line">        <span class="keyword">if</span> ( idx == l - <span class="number">1</span> )</span><br><span class="line">            print[idx + <span class="number">1</span>] = out[idx][!i];</span><br><span class="line">        <span class="keyword">return</span> check ( idx + <span class="number">1</span>, out[idx][!i] );</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n, idx;</span><br><span class="line">    <span class="built_in">set</span> < <span class="keyword">int</span> > prime;</span><br><span class="line">    <span class="built_in">map</span> < <span class="keyword">int</span>, <span class="keyword">char</span> > lib;</span><br><span class="line">    <span class="built_in">cin</span> >> t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i <= t; i++){</span><br><span class="line">        <span class="built_in">cin</span> >> n >> l;</span><br><span class="line">        <span class="built_in">memset</span> ( print, <span class="number">0</span>, <span class="keyword">sizeof</span> print );</span><br><span class="line">        prime.clear();</span><br><span class="line">        lib.clear();</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Case #"</span> << i << <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < l ; i++ ){</span><br><span class="line">            <span class="built_in">cin</span> >> input[i];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">2</span> ; j <= n ; j++ ){</span><br><span class="line">                <span class="keyword">if</span> ( input[i] % j == <span class="number">0</span> ){</span><br><span class="line">                    prime.insert ( j );</span><br><span class="line">                    prime.insert ( input[i] / j );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: prime )</span><br><span class="line">            lib[i] = <span class="string">'A'</span> + idx++;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < l ; i++ )</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">2</span> ; j <= n ; j++ )</span><br><span class="line">                <span class="keyword">if</span> ( input[i] % j == <span class="number">0</span> ){</span><br><span class="line">                    out[i][<span class="number">0</span>] = lib[j];</span><br><span class="line">                    out[i][<span class="number">1</span>] = lib[input[i] / j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < <span class="number">2</span> ; i++ )</span><br><span class="line">            <span class="keyword">if</span> ( check ( <span class="number">0</span>, out[<span class="number">0</span>][i] ) )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="後記-1"><a href="#後記-1" class="headerlink" title="後記"></a>後記</h2><p>這場打起來感覺好廢<br>最近比較少寫演算法競賽的題目<br>幾乎都是在讀新東西<br>手感感覺不是很好<br>教練，我想要拿 T-Shirt<br>p.s. GCJ 只要進 Round 3 就可以拿到一件 T-Shirt。。。只是聽說要很久才會拿到？！<br>下一場 1A 感覺不是很好打，因為是第一場，沒意外應該會有不少人去打<br>而且時間上來說是 CodeForces 的 usaul time<br>中國人應該不少（汗<br>1A 1B 1C 要有一場前 1500 名才能進去啊（遠望<br>覺得有點難@@</p><p>最後放個計分板截圖<br><img src="scb.jpg" alt></p><p>寫完這篇文章，在本地端用 hexo 編譯預覽出來後<br>發現圖片邊緣有白框<br>。。。<br>好樣的，我又要來修 css 配置了<br>工作量 up up<br> = =</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我到當天下午五點我才想到有 GCJ 的 Qualification Round （資格賽）&lt;br&gt;然後我六點有補習，差點就要像去年一樣頂著睡意惺忪的眼睛打了&lt;/p&gt;
&lt;p&gt;只要能夠在這個 Round 拿到 $30$ 分就可以打 Round 1 了&lt;br&gt;
    
    </summary>
    
    
      <category term="Full Contest Solution" scheme="https://miohitokiri5474.github.io/code/tags/Full-Contest-Solution/"/>
    
      <category term="GCJ" scheme="https://miohitokiri5474.github.io/code/tags/GCJ/"/>
    
  </entry>
  
  <entry>
    <title>[TIOJ][1909] 勇者出征</title>
    <link href="https://miohitokiri5474.github.io/code/TIOJ-1909/"/>
    <id>https://miohitokiri5474.github.io/code/TIOJ-1909/</id>
    <published>2019-01-04T01:46:38.000Z</published>
    <updated>2019-10-26T08:47:35.287Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p><a href="https://tioj.ck.tp.edu.tw/problems/1909" target="_blank" rel="noopener">原題目連結</a><br>據說是 2015TOI 三模的題目<br>簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：</p><ol><li>從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個</li><li>假設 $D$ 可以連結到 $A$ 的話（$D的高度 \lt A$），那麼$A$也可以到 $D$</li></ol><p>求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號<br>如果有多組解，輸出編號最小的<br><a id="more"></a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>我們先來釐清一下什麼是簡單路徑好了<br>所謂的簡單路徑，就是起點終點不重複，且路徑上經過的點不重複的路徑</p><h3 id="建圖"><a href="#建圖" class="headerlink" title="建圖"></a>建圖</h3><p>看到路徑，我第一個想到的是圖論<br>我們先想一下，要怎麼把圖建出來</p><h4 id="暴力-O-N-2"><a href="#暴力-O-N-2" class="headerlink" title="暴力 $O ( N^2 )$"></a>暴力 $O ( N^2 )$</h4><p>$N^2$ 就爆搜啊，按照題目寫的，往左往右找比他大的然後做比較<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ ){</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">-1</span>, r = n;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span> ; j >= <span class="number">0</span> ; j-- )</span><br><span class="line">        <span class="keyword">if</span> ( data[j] > data[i] ){</span><br><span class="line">            l = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span> ; j < n ; j++ )</span><br><span class="line">        <span class="keyword">if</span> ( data[j] > data[i] ){</span><br><span class="line">            r = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">if</span> ( l == <span class="number">-1</span> && r == n )</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> ( l == <span class="number">-1</span> ){</span><br><span class="line">        UNI ( r, i, edges );</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> ( r == n ){</span><br><span class="line">        UNI ( l, i, edges );</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    UNI ( ( data[l] < data[r] ? l : r ), i, edges );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="線段樹-O-NlogN"><a href="#線段樹-O-NlogN" class="headerlink" title="線段樹 $O ( NlogN )$"></a>線段樹 $O ( NlogN )$</h4><p>然後我就想到線段樹了<br>$index$ 是做離散化後的數字，$value$ 是編號<br>然後就可以開兩顆線段樹，一顆紀錄左手邊的最大值，一邊紀錄右邊最小值<br>一開始右手邊的最小值線段樹，裡面有$N$個點<br>每處理完一個點，就把這個點拔掉丟到左邊去<br>code大概像這樣<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="comment">// 線段樹1是紀錄最小值、右手邊的線段樹</span></span><br><span class="line"><span class="comment">// 而線段數2是紀錄最大值、左手邊的線段樹</span></span><br><span class="line"><span class="keyword">int</span> seg1[maxN << <span class="number">2</span>], seg2[maxN << <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update1</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib是已經做完離散化的數列</span></span><br><span class="line"><span class="built_in">memset</span> ( seg1, INF, <span class="keyword">sizeof</span> seg1 );</span><br><span class="line"><span class="built_in">memset</span> ( seg2, <span class="number">-1</span>, <span class="keyword">sizeof</span> seg2 )</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ )</span><br><span class="line">    update1 ( <span class="number">0</span>, n, i, lib[i], <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ ){</span><br><span class="line">    <span class="keyword">int</span> l = query2 ( lib[i] + <span class="number">1</span>, n, <span class="number">0</span>, n, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">int</span> r = query1 ( lib[i] + <span class="number">1</span>, n, <span class="number">0</span>, n, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( l == <span class="number">-1</span> && r == INF )</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> ( l == <span class="number">-1</span> ){</span><br><span class="line">        UNI ( i, r, edges );</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> ( r == INF ){</span><br><span class="line">        UNI ( i, l, edges );</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">    UNI ( i, ( data[l] < data[r] ? l : r ), edges );</span><br><span class="line"></span><br><span class="line">    update1 ( <span class="number">0</span>, n, INF, lib[i], <span class="number">1</span> );</span><br><span class="line">    update2 ( <span class="number">0</span>, n, i, lib[i], <span class="number">1</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="單調列隊優化-O-N"><a href="#單調列隊優化-O-N" class="headerlink" title="單調列隊優化 $O ( N )$"></a>單調列隊優化 $O ( N )$</h4><p>關於單調列隊優化的介紹可以看這份建中講義第二頁<a href="https://goo.gl/e12UAo" target="_blank" rel="noopener">這邊</a></p><p>根據單調列隊的特性，我們可以保證現在在 deque 中的數字是遞減的</p><p>那麼假設要插入一個數字呢？<br>假設現在這個數字比最後一個還要大，那麼我們就不斷的拔<br>拔到最後一個數字比現在要插入的數字 $A$ 還要大的時候<br>接著把這些拔掉的數字與 $A$ 做連接</p><p>不過為什麼是跟 $A$ 做連結而不是另一邊比較大的數字呢？<br>因為他是說兩邊第一個比她大的數字的 min<br>既然兩邊都比他大，那麼當然選小的啊</p><p>最後這個 deque 會保證遞減<br>那麼就是把這個 deque 最後一個數字 $L$ 與最後一個數字 $L’$ 做連結<br>直到這個 deque 清空為止</p><p>不過因為只需要從後端做操作<br>所以用 stack 就可以了</p><p>詳細的 code 請看這<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair < <span class="keyword">int</span>, <span class="keyword">int</span> > pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// data 是原數列</span></span><br><span class="line"><span class="built_in">stack</span> < pii, <span class="built_in">vector</span> < pii > > st;</span><br><span class="line"><span class="comment">// stack 小技巧，stack 原本是用 deque 實作，可以自行更換為較快速的 vector （只有從後端操作）</span></span><br><span class="line">pii swp;</span><br><span class="line">st.push ( pii ( data[<span class="number">0</span>], <span class="number">0</span> ) );</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i < n ; i++ ){</span><br><span class="line">    <span class="keyword">while</span> ( !st.empty() && data[i] > st.top().F ){</span><br><span class="line">        swp = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        <span class="keyword">if</span> ( EMP ( st ) )</span><br><span class="line">            UNI ( swp.S, i, edges );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class="line">    }</span><br><span class="line">    st.push ( pii ( data[i], i ) );</span><br><span class="line">}</span><br><span class="line">swp = st.top();</span><br><span class="line">st.pop();</span><br><span class="line"><span class="keyword">while</span> ( !st.empty() ){</span><br><span class="line">    UNI ( swp.S, st.top().S, edges );</span><br><span class="line">    swp = st.top();</span><br><span class="line">    st.pop();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="是時候來處理路徑囉"><a href="#是時候來處理路徑囉" class="headerlink" title="是時候來處理路徑囉"></a>是時候來處理路徑囉</h3><p>至於這個題目的另外一個部分：路徑<br>又該怎麼處理呢？<br>我們可以發現，這份資料轉換完之後保證是二元樹<br>為什麼？<br>因為他最多只會被兩個其他的點連結（左邊一個右邊一個）<br>而自己只會連結到一個點<br>那麼這不就是二元樹嗎？<br>那麼，通過點 $u$ 的路徑會有三種：</p><ol><li>$u$ 的祖先到 $u$ 的子孫的路徑</li><li>$u$ 的子孫到 $u$ 的子孫，但是有經過 $u$ 的路徑</li><li>從 $u$ 開始（或結束）的路徑</li></ol><p>我們先定義</p><script type="math/tex; mode=display">dp[u] = u的子孫數目（包含 u ）</script><p>因為是樹，所以不會有起點同終點但是路徑不同的情況發生（沒有環）<br>因此只要計算起點終點的組合數就好了</p><p>那麼 1. 就很好算啦</p><script type="math/tex; mode=display">( 總點數 - dp[n] - 1 )\times ( dp[n] - 1 )</script><p>那麼 2. 呢？<br>上面有提到是二元樹，所以任一點最多只會有三條邊出去（兩個子孫一個祖先）<br>所以，把祖先扣掉的那兩個 $a, b$ 的大小乘起（ $dp[a]\times dp[n]$）就是答案了</p><p>呃，3. 應該就不用講了吧 = =<br>就 總點數減一啊 = =</p><p>然後有一點要注意的，因為一條路徑可以有頭尾互換（起點終點不同不能算是同一條路徑吧）</p><p>綜合一二三，所以只需要dfs一次就好了</p><p>這部分的code我放這<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 1000005</span></span><br><span class="line"><span class="built_in">vector</span> < <span class="keyword">int</span> > edges[maxN];</span><br><span class="line"><span class="keyword">int</span> cnt[maxN], dp[maxN], N;</span><br><span class="line"><span class="comment">// N = 總點數 - 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n,  <span class="keyword">int</span> p )</span></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-1</span>, b = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges[n] ){</span><br><span class="line">        <span class="keyword">if</span> ( i == p )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ( a == <span class="number">-1</span> )</span><br><span class="line">            a = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b = i;</span><br><span class="line">        dfs ( i, n );</span><br><span class="line">        dp[n] += dp[i];</span><br><span class="line">    }</span><br><span class="line">    cnt[n] += ( N - dp[n] ) * dp[n]; <span class="comment">// 祖先到子孫</span></span><br><span class="line">    <span class="keyword">if</span> ( deges[n].size() == <span class="number">3</span> ) <span class="comment">// 如果是有兩個子孫的話</span></span><br><span class="line">        cnt[n] += dp[a] * dp[b];</span><br><span class="line">    dp[n]++; <span class="comment">// 因為包含 n ，但是前面都還要 - 1 很麻煩，所以我放到這邊才 + 1</span></span><br><span class="line">    cnt[n] += N;</span><br><span class="line">    cnt[n] <<= <span class="number">1</span>; <span class="comment">// 記得乘二喔</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>綜合以上，我的code長這樣<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair < <span class="keyword">int</span>, <span class="keyword">int</span> > pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNI(u,v,edge) edge[u].pb ( v ), edge[v].pb ( u )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 1000005</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> < <span class="keyword">int</span> > edges[maxN];</span><br><span class="line">LL dp[maxN], N, cnt[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n,  <span class="keyword">int</span> p )</span></span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-1</span>, b = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges[n] ){</span><br><span class="line">        <span class="keyword">if</span> ( i == p )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ( a == <span class="number">-1</span> )</span><br><span class="line">            a = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b = i;</span><br><span class="line">        dfs ( i, n );</span><br><span class="line">        dp[n] += dp[i];</span><br><span class="line">    }</span><br><span class="line">    cnt[n] += ( N - dp[n] ) * dp[n];</span><br><span class="line">    <span class="keyword">if</span> ( edges[n].size() == <span class="number">3</span> )</span><br><span class="line">        cnt[n] += dp[a] * dp[b];</span><br><span class="line">    dp[n]++;</span><br><span class="line">    cnt[n] += N;</span><br><span class="line">    cnt[n] <<= <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, idx = <span class="number">-1</span>;</span><br><span class="line">    LL ma = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    <span class="built_in">vector</span> < <span class="keyword">int</span> > data ( n );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: data )</span><br><span class="line">        <span class="built_in">cin</span> >> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> < pii, <span class="built_in">vector</span> < pii > > st;</span><br><span class="line">    pii swp;</span><br><span class="line">    st.push ( pii ( data[<span class="number">0</span>], <span class="number">0</span> ) );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i =  <span class="number">1</span> ; i < n ; i++ ){</span><br><span class="line">        <span class="keyword">while</span> ( !st.empty() && data[i] > st.top().F ){</span><br><span class="line">            swp = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span> ( st.empty() )</span><br><span class="line">                UNI ( swp.S, i, edges );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                UNI ( ( st.top().F < data[i] ? st.top().S : i ), swp.S, edges );</span><br><span class="line">        }</span><br><span class="line">        st.push ( pii ( data[i], i ) );</span><br><span class="line">    }</span><br><span class="line">    swp = st.top();</span><br><span class="line">    st.pop();</span><br><span class="line">    <span class="keyword">while</span> ( !st.empty() ){</span><br><span class="line">        UNI ( swp.S, st.top().S, edges );</span><br><span class="line">        swp = st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    N = n - <span class="number">1</span>;</span><br><span class="line">    dfs ( <span class="number">0</span>, <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ ){</span><br><span class="line">        <span class="keyword">if</span> ( cnt[i] > ma )</span><br><span class="line">            ma = cnt[i], idx = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << ma << <span class="string">' '</span> << idx + <span class="number">1</span> << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>其實這題我寫了很久<br>因為之前一段時間都在搞特選<br>而且我怕特選爆掉沒學校念<br>所以我都在讀學測<br>最近特選出來了<br>已經沒有後顧之憂可以好好搞 TOI 了 <3<br>才回來鍊<br>也是因為剛回來鍊<br>所以手感很糟 = =<br>線段樹寫 query 還把查詢區間 & 總區間寫反 = =<br>還有忘了設定 ma = -1<br>然後還想說為什麼 WA Orz<br>這題也沒有看出來是單調列隊<br>還傻傻花一個多小時寫線段樹 + debug<br>結果單調隊列快狠準 = =<br>我到底在幹嘛 = =<br>不過好險還有三個月（吧</p><p>然後這篇文章也太長 = =<br>這一行是第 326 行<br>呃我是說在原始的 md 檔案上<br>喔這邊已經 328 行了<br>好多 = =<br>至少可定下心來好好練習了</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;題目&quot;&gt;&lt;a href=&quot;#題目&quot; class=&quot;headerlink&quot; title=&quot;題目&quot;&gt;&lt;/a&gt;題目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://tioj.ck.tp.edu.tw/problems/1909&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原題目連結&lt;/a&gt;&lt;br&gt;據說是 2015TOI 三模的題目&lt;br&gt;簡單來說，就是給定一數列代表一排石柱，並且任意石柱 $A$ 可以到達的石柱有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;從 $A$ 左邊第一個比 $A$ 高的石柱 $B$，以及從 $A$ 往右找的第一個比$A$高的石柱 $C$，其中高度比較低的石柱，其中如果 $B$ 或 $C$ 其中一個不存在，則連結到存在的那一個&lt;/li&gt;
&lt;li&gt;假設 $D$ 可以連結到 $A$ 的話（$D的高度 \lt A$），那麼$A$也可以到 $D$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;求所有石柱中，被最多條簡單路經過的石柱，其被走過的次數及編號&lt;br&gt;如果有多組解，輸出編號最小的&lt;br&gt;
    
    </summary>
    
    
      <category term="graph" scheme="https://miohitokiri5474.github.io/code/tags/graph/"/>
    
      <category term="TIOJ" scheme="https://miohitokiri5474.github.io/code/tags/TIOJ/"/>
    
  </entry>
  
  <entry>
    <title>[CF]Round 521</title>
    <link href="https://miohitokiri5474.github.io/code/CFR521/"/>
    <id>https://miohitokiri5474.github.io/code/CFR521/</id>
    <published>2018-11-17T04:20:01.000Z</published>
    <updated>2020-05-02T09:56:03.345Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>身為一個垃圾，當然要打的像垃圾一樣<br>先是校內爆掉，現在換 div.3 爆掉<br>。。。pC 沒開 long long 溢位被 hack 成智障的就是我<br>坐等晚上 rating change<br>沒意外應該會噴掉啦<br><a id="more"></a></p><p>先放上所有題目的<a href="http://codeforces.com/contest/1077" target="_blank" rel="noopener">連結</a></p><h2 id="problem-A"><a href="#problem-A" class="headerlink" title="problem A"></a>problem A</h2><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>大意就是，假設在奇數回合往右走 $a$ 步，偶數回合往左走 $b$ 步<br>然後請問第 $K$ 回合現在位置在哪（假設起始位置為 $0$ 且向右為正）</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>阿不就直接暴力就好<br>算一下會往左次往右幾次，算一下就好</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, k, a, b, swp, ans;</span><br><span class="line">    <span class="built_in">cin</span> >> t;</span><br><span class="line">    <span class="keyword">while</span> ( t-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> a >> b >> k;</span><br><span class="line">        swp = a - b;</span><br><span class="line">        ans = swp * ( LL ) ( k / <span class="number">2</span> );</span><br><span class="line">        <span class="keyword">if</span> ( k & <span class="number">1</span> )</span><br><span class="line">            ans += a;</span><br><span class="line">        <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-B"><a href="#problem-B" class="headerlink" title="problem B"></a>problem B</h2><h3 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a>題目</h3><p>給定一排房屋現在是否有開燈<br>通常關燈了就是在睡覺了</p><p>題目定義會被干擾就是有戶人家已經在睡覺了，但是隔壁兩間房子的人都有開著燈<br>那麼那戶人家就會被干擾<br>但是請注意，只有一邊的鄰居開燈並不會被干擾</p><p>現在想要讓所有在睡覺的人都不會被干擾<br>求達成此目標所需要的最小關燈（把原先亮著的燈關掉）數</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>因為只有一邊有開燈並不會被干擾<br>也就是說，針對每一個會被干擾的人，把一邊的燈關掉就好了</p><p>那麽，我先找出有哪幾戶人家會被干擾，然後把其中一邊的燈關掉<br>順便特判一下有沒有關一戶燈，兩邊就都不會被打擾的狀況，避免重複計算</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>, m;</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    <span class="built_in">vector</span> < <span class="keyword">int</span> > data ( n ), lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: data )</span><br><span class="line">        <span class="built_in">cin</span> >> i;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i < n - <span class="number">1</span> ; i++ ){</span><br><span class="line">        <span class="keyword">if</span> ( !data[i] && data[i - <span class="number">1</span>] && data[i + <span class="number">1</span>] )</span><br><span class="line">            lib.push_back ( i );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    m = lib.size();</span><br><span class="line">    <span class="keyword">while</span> ( lib.size() > <span class="number">1</span> ){</span><br><span class="line">        <span class="keyword">if</span> ( lib[<span class="number">1</span>] - lib[<span class="number">0</span>] == <span class="number">2</span> ){</span><br><span class="line">            ans++;</span><br><span class="line">            lib.erase ( lib.begin() );</span><br><span class="line">            lib.erase ( lib.begin() );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            ans++;</span><br><span class="line">            lib.erase ( lib.begin() );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !lib.empty() )</span><br><span class="line">        ans++;</span><br><span class="line">    <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-C"><a href="#problem-C" class="headerlink" title="problem C"></a>problem C</h2><p>就是這題，我沒有開 long long 然後就被 hack 了<br>名次噴掉 1500 多名</p><h3 id="題目-2"><a href="#題目-2" class="headerlink" title="題目"></a>題目</h3><p>給定一條長度為 $N$ 的序列<br>我們假設一個序列是「好的」為以下情況：這個序列的其中一個數字，剛好等於此序列其他元素的和<br>也就是說，$[ 1, 3, 3, 7 ]$ 這個序列是好的，因為 $7 = 1 + 3 + 3$<br>求一共有幾種可能，在移除掉一個元素的情況下，這個序列會是好的<br>請列出數量，以及些解的位置</p><p>因為題目有點難懂，我放上其中一個例子好了<br>那現在看另外一個序列 $[ 8, 3, 5, 2 ]$</p><ol><li>移除掉第一個元素（也就是 $8$ ），這個序列會是好的，因為 $[ 3, 5, 2 ] \to 5 = 3 + 2$</li><li>移除掉第四個元素（也就是 $2$ ），這個序列也會是好的，因為 $[ 8, 3, 5 ] \to 8 = 3 + 5$</li></ol><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><ol><li>計算原先序列的總和</li><li>每舉所有元素 ( $a[i]$ )，把他從 $sum$ 減掉</li><li>把 $sum$ 為奇數則返回步驟2</li><li>尋找 $\frac{sum}{2}$ 是否出現於原序列中</li><li>檢查 $\frac{sum}{2}$ 是否與 $a[i]$ 相等，如果相等，那麼 $a[i]$ 是否出現於原序列中兩次</li><li>如果有出現過兩次，那麼 i 就是其中一個答案</li><li>返回步驟 2</li></ol><p>有一點可能會覺得有點奇怪，為什麼 $sum - a[i]$ 一定要是偶數<br>假設 $sum’ = sum - a[i]，sum’$ 代表除了 $a[i]$ 以外的元素和<br>既然一個序列為好的序列，代表說這個序列會被切成兩部分<br>而這兩部分的和會一樣<br>既然都會被切成兩個一樣的東西了，為什麼 $sum’$ 會是奇數<br>這就矛盾了，所以 $sum’$ 一定為偶數</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> < <span class="keyword">int</span>, <span class="keyword">int</span> > lib;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    <span class="built_in">vector</span> < <span class="keyword">int</span> > data ( n ), ans;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: data ){</span><br><span class="line">        <span class="built_in">cin</span> >> i;</span><br><span class="line">        sum += i;</span><br><span class="line">        lib[i]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ ){</span><br><span class="line">        sum -= data[i];</span><br><span class="line">        <span class="keyword">if</span> ( sum & <span class="number">1</span> ){</span><br><span class="line">            sum += data[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        sum >>= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( ( lib[sum] == <span class="number">1</span> && sum != data[i] ) || lib[sum] > <span class="number">1</span> ){</span><br><span class="line">            ans.push_back ( i + <span class="number">1</span> );</span><br><span class="line">        }</span><br><span class="line">        sum <<= <span class="number">1</span>;</span><br><span class="line">        sum += data[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << ans.size() << <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data )</span><br><span class="line">        <span class="built_in">cout</span> << i << <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-D"><a href="#problem-D" class="headerlink" title="problem D"></a>problem D</h2><h3 id="題目-3"><a href="#題目-3" class="headerlink" title="題目"></a>題目</h3><p>給定一大小為 $N$ 的可重複集合 $S$<br>求找出一大小為 $K$ 的可重複集合 $S’ ( S’\subseteq S )$ 且 $S’$ 在 $S$ 中出現次數最多</p><p><strong>元素可重複，這件事情非常重要</strong></p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>我先做離散化，反正數字跟解法沒有關係<br>接著紀錄每個數字出現幾次<br>我先二分搜最多那個集合最多可以出現幾次<br>然後按照次數輸出，反正只要符合要求的都行</p><h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 200005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[maxN], m, k, ma;</span><br><span class="line"><span class="built_in">vector</span> < <span class="keyword">int</span> > lib;</span><br><span class="line"><span class="built_in">map</span> < <span class="keyword">int</span>, <span class="built_in">vector</span> < <span class="keyword">int</span> > > table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span> <span class="params">( <span class="keyword">int</span> tms )</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = tms ; i < ma ; i++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> j: table[i] )</span><br><span class="line">            res += cnt[j] / tms;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res >= k;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, l = <span class="number">0</span>, r = <span class="number">-1</span>, mid;</span><br><span class="line">    <span class="built_in">cin</span> >> n >> k;</span><br><span class="line">    <span class="built_in">vector</span> < <span class="keyword">int</span> > data ( n );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: data )</span><br><span class="line">        <span class="built_in">cin</span> >> i;</span><br><span class="line">    <span class="keyword">if</span> ( n == k ){</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data )</span><br><span class="line">            <span class="built_in">cout</span> << i << <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    lib = data;</span><br><span class="line">    sort ( lib.begin(), lib.end() );</span><br><span class="line">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class="line">    m = lib.size();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data ){</span><br><span class="line">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.end()]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < m ; i++ ){</span><br><span class="line">        r = max ( r, cnt[i] );</span><br><span class="line">        table[cnt[i]].push_back ( i );</span><br><span class="line">    }</span><br><span class="line">    ma = ++r;</span><br><span class="line">    mid = ( l + r ) >> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( r - l > <span class="number">1</span> ){</span><br><span class="line">        <span class="keyword">if</span> ( check ( mid ) )</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">        mid = ( l + r ) >> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    l = k;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < m ; i++ ){</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j < min ( cnt[i] / mid, l ) ; j++ )</span><br><span class="line">            <span class="built_in">cout</span> << lib[i] << <span class="string">' '</span>;</span><br><span class="line">        l -= min ( cnt[i] / mid, l );</span><br><span class="line">        <span class="keyword">if</span> ( !l )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-E"><a href="#problem-E" class="headerlink" title="problem E"></a>problem E</h2><p>這題我賽中只有想到喇賽解法，賽後才想到正解</p><h3 id="題目-4"><a href="#題目-4" class="headerlink" title="題目"></a>題目</h3><p>給定一些題目，$a_i$ 即代表第 $i$ 題的種類為 $a_i$<br>要求每場比賽的的題目種類都要一樣，用過的種類不能再次使用<br>且每一場需要的題目數量是前一場的兩倍（第一天的題目數量可以任意）<br>求最多可以使用多少題目<br><strong>注意！你應該要最大會題目數量，而非天數</strong></p><h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>每舉第一天的題數，然後暴力往後找<br>用 lower_bound 去尋找是個不錯的選擇</p><h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 200005</span></span><br><span class="line"></span><br><span class="line">LL cnt[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, ma, ans = <span class="number">-1</span>, swp, idx, id;</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    <span class="built_in">vector</span> < <span class="keyword">int</span> > data ( n ), lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: data )</span><br><span class="line">        <span class="built_in">cin</span> >> i;</span><br><span class="line">    lib = data;</span><br><span class="line">    sort ( lib.begin(), lib.end() );</span><br><span class="line">    lib.erase ( unique ( lib.begin(), lib.end() ), lib.end() );</span><br><span class="line">    m = lib.size();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: data )</span><br><span class="line">        cnt[lower_bound ( lib.begin(), lib.end(), i ) - lib.begin()]++;</span><br><span class="line"></span><br><span class="line">    data.clear();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < m ; i++ ){</span><br><span class="line">        data.push_back ( cnt[i] );</span><br><span class="line">    }</span><br><span class="line">    sort ( data.begin(), data.end() );</span><br><span class="line">    ma = data.back() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < ma ; i++ ){</span><br><span class="line">        swp = idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i ; j < ma && idx < m ; j <<= <span class="number">1</span> ){</span><br><span class="line">            id = lower_bound ( data.begin() + idx, data.end(), j ) - data.begin();</span><br><span class="line">            <span class="keyword">if</span> ( id < data.size() )</span><br><span class="line">                swp += j;</span><br><span class="line">            idx = id + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ans = max ( ans, swp );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>老實說我這場有點慘<br>pC 被 Hack，pE 賽中沒寫出來<br>以我的實力來說不應該這樣子的<br>因為沒開 long long 而炸掉，我現在已經在我的 default code 裡加上 #define int long long 了@@</p><p>希望下一場可以好好發揮</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;身為一個垃圾，當然要打的像垃圾一樣&lt;br&gt;先是校內爆掉，現在換 div.3 爆掉&lt;br&gt;。。。pC 沒開 long long 溢位被 hack 成智障的就是我&lt;br&gt;坐等晚上 rating change&lt;br&gt;沒意外應該會噴掉啦&lt;br&gt;
    
    </summary>
    
    
      <category term="Full Contest Solution" scheme="https://miohitokiri5474.github.io/code/tags/Full-Contest-Solution/"/>
    
      <category term="CodeForces" scheme="https://miohitokiri5474.github.io/code/tags/CodeForces/"/>
    
      <category term="div.3" scheme="https://miohitokiri5474.github.io/code/tags/div-3/"/>
    
      <category term="dp" scheme="https://miohitokiri5474.github.io/code/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>[TIOJ][1615] A! + B! problem</title>
    <link href="https://miohitokiri5474.github.io/code/TIOJ-1615/"/>
    <id>https://miohitokiri5474.github.io/code/TIOJ-1615/</id>
    <published>2018-10-28T12:13:43.000Z</published>
    <updated>2019-10-26T08:47:35.287Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久沒有寫 code 發題解了<br>最近因為一些事情沒有時間（也沒有心情）認真寫 code<br>（因為上次 CodeForces 連續掉分我心情有點糟）<br>（啊還有學科校內爆炸也是我心情糟的原因之一）<br>（開始懷疑我到底這一年努力是為了什麼，之類的）<br><a id="more"></a><br>然後今天想說寫個題目、發個題解刷一下存在感，之類的<br>所以跑去 TIOJ 翻題目<br>然後看到這題<br>。。。寫完 AC 了之後發現很裸，裸到有點不知道該說什麼</p><h2 id="題目-amp-解法"><a href="#題目-amp-解法" class="headerlink" title="題目 & 解法"></a>題目 & 解法</h2><p>大意上是說，給定兩數字 $A, B$ ，求 $A! + B!$ 共有多少個質因數<br>原網址我放<a href="https://tioj.ck.tp.edu.tw/problems/1615" target="_blank" rel="noopener">在這</a></p><p>很直觀的會拆成 $A ( ( B - A )! + 1 )$ 來做<br>所以答案就是$le A$ 的質因數個數，然後再檢查 $( B - A )! + 1$ 共有多少個質因數<br>因為要加一，所以我想了很久<br>感覺這種題目就是會卡 $O ( N ^ 2 )$ 解（被這種題目雷到好幾次@@）<br>但是我真的沒有想法<br>所以就寫了個 $O ( N^2 )$ 的解法<br>。。。然後過了，wtf<br>就真的把 $( B - A )! + 1$ 暴力做，然後暴力檢查<br>就這樣。。。<br>我一臉懵逼的坐在電腦前傻了一下<br>才開始動手打這篇文章</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span> < maxN > lib;</span><br><span class="line"><span class="built_in">vector</span> < LL > prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line">    lib[<span class="number">0</span>] = lib[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> ; i < maxN ; i++ ){</span><br><span class="line">        <span class="keyword">if</span> ( !lib[i] ){</span><br><span class="line">            prime.push_back ( i );</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i ; j < maxN ; j += i )</span><br><span class="line">                lib[j] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a, b, len = prime.size();</span><br><span class="line">    LL ans, stp;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">cin</span> >> a >> b ){</span><br><span class="line">        <span class="keyword">if</span> ( a > b )</span><br><span class="line">            swap ( a, b );</span><br><span class="line">        ans = upper_bound ( prime.begin(), prime.end(), a ) - prime.begin();</span><br><span class="line">        stp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = a + <span class="number">1</span> ; i <= b ; i++ ){</span><br><span class="line">            stp *= i;</span><br><span class="line">        }</span><br><span class="line">        stp++;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < ans ; i++ ){</span><br><span class="line">            <span class="keyword">while</span> ( stp % prime[i] == <span class="number">0</span> ){</span><br><span class="line">                stp /= prime[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = ans ; i < len ; i++ ){</span><br><span class="line">            <span class="keyword">if</span> ( !( stp % prime[i] ) ){</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">while</span> ( stp % prime[i] == <span class="number">0</span> )</span><br><span class="line">                    stp /= prime[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( stp > maxN )</span><br><span class="line">            ans++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>最近特殊選才有點忙<br>加上 CodeForces，校內賽的陰影<br>我可能會暫時停筆一下啦XD<br>沒有意外，等到特選告一段落會繼續。。。吧<br>等等印象中好像有 CodeForces，啊不過有點晚<br>會不會打還是未知數<br>下禮拜的 HPCW、MCC 打完，應該又會停一段時間吧<br>在特選放榜前我應該不會繼續認真搞比賽了<br>因為我不知道在放榜後我會何去何從（笑<br>先讀點書好像比較保險</p><p>不過如果特選有好結果我還是會認真搞 TOI 入營考啦<br>已經是最後一年了，能不能進去就聽由天命囉</p><p>然後，謝謝看到這邊的你<br>（我這麼寫怎麼有點感傷啊XD）<br>我已經很久沒有發文了，希望大家還有在看<br>謝謝各位一直以來對我的支持 <3</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;好久沒有寫 code 發題解了&lt;br&gt;最近因為一些事情沒有時間（也沒有心情）認真寫 code&lt;br&gt;（因為上次 CodeForces 連續掉分我心情有點糟）&lt;br&gt;（啊還有學科校內爆炸也是我心情糟的原因之一）&lt;br&gt;（開始懷疑我到底這一年努力是為了什麼，之類的）&lt;br&gt;
    
    </summary>
    
    
      <category term="TIOJ" scheme="https://miohitokiri5474.github.io/code/tags/TIOJ/"/>
    
      <category term="math" scheme="https://miohitokiri5474.github.io/code/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>[ITSA] No.66 詳解</title>
    <link href="https://miohitokiri5474.github.io/code/itsa-66/"/>
    <id>https://miohitokiri5474.github.io/code/itsa-66/</id>
    <published>2018-09-13T00:20:50.000Z</published>
    <updated>2019-10-26T08:47:35.290Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>簡單來說就是我特殊選才的資料不夠<br>所以只好來打這東西，不然備審有夠空QQ<br><a id="more"></a></p><h2 id="problem-1"><a href="#problem-1" class="headerlink" title="problem 1"></a>problem 1</h2><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>這題就是給你一行整數（數量不定，但是保證 < 11個）<br>求該行出現率「超過」一半的整數</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>看到數量不定就會用 getline + stringstream，這很直觀<br>然後因為他只有說「給整數」，並沒有限制數字大小<br>所以我是用 map 做，而不是陣列（出現負數就尷尬了）<br>雖然比較慢但是也比較無腦</p><p>為什麼我會在題目那把「超過」加上引號？<br>。。。因為我在寫 code 的時候耍智障把判斷式寫成 >=<br>然後我就吃 WA 了<br>我還跑去問如果有多組解怎麼辦<br>結果超過一半的數字只會有一個QQ<br>還有把 NO 打成 No<br>就多吃兩個 penalty 了，虧爆<br>抓到，澪人桐不會寫程式</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> < <span class="keyword">int</span>, <span class="keyword">int</span> > lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> in, cnt;</span><br><span class="line">    <span class="keyword">bool</span> ans;</span><br><span class="line">    <span class="keyword">while</span> ( getline ( <span class="built_in">cin</span>, str ) ){</span><br><span class="line">        lib.clear();</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span> <span class="params">( str )</span></span>;</span><br><span class="line">        <span class="keyword">while</span> ( ss >> in ){</span><br><span class="line">            lib[in]++;</span><br><span class="line">            cnt++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: lib ){</span><br><span class="line">            <span class="keyword">if</span> ( i.S > cnt / <span class="number">2</span> ){</span><br><span class="line">                <span class="built_in">cout</span> << i.F << <span class="string">'\n'</span>;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ( !ans )</span><br><span class="line">            <span class="built_in">cout</span> << <span class="string">"NO\n"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-2"><a href="#problem-2" class="headerlink" title="problem 2"></a>problem 2</h2><h3 id="題目-1"><a href="#題目-1" class="headerlink" title="題目"></a>題目</h3><p>給一個簡單的一元一次方程式<br>保證只有兩個數字、一個未知數 $x$、一個等號、一個加減乘除<br>並保證所有運算元與運算子之間只都有空白隔開<br>並且求出 $x$，無條件捨去到小數點第一位</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>要寫字串判斷很麻煩欸 = =<br>pA寫爆了先來寫這題（？<br>手速不知道為什麼爆快<br>快到我自己也嚇到<br>也沒出什麼 bug，很快就 AC 了 <3</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">vector</span> < <span class="keyword">int</span> > lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt, len, x, a, b, ans;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">while</span> ( getline ( <span class="built_in">cin</span>, str ) ){</span><br><span class="line">        len = str.size(), x = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        lib.clear();</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < len ; i++ ){</span><br><span class="line">            <span class="keyword">if</span> ( str[i] == <span class="string">'+'</span> )</span><br><span class="line">                opt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( str[i] == <span class="string">'-'</span> )</span><br><span class="line">                opt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( str[i] == <span class="string">'*'</span> )</span><br><span class="line">                opt = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( str[i] == <span class="string">'/'</span> )</span><br><span class="line">                opt = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span> ( <span class="string">'0'</span> <= str[i] && str[i] <= <span class="string">'9'</span> ){</span><br><span class="line">                    x = x * <span class="number">10</span> + <span class="keyword">int</span> ( str[i] - <span class="string">'0'</span> );</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    <span class="keyword">if</span> ( flag )</span><br><span class="line">                        lib.pb ( x );</span><br><span class="line">                    x = <span class="number">0</span>, flag = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ( flag )</span><br><span class="line">            lib.pb ( x );</span><br><span class="line">        a = lib[<span class="number">0</span>], b = lib[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ( !opt )</span><br><span class="line">            ans = ( b - a ) * <span class="number">10.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( opt == <span class="number">1</span> )</span><br><span class="line">            ans = ( b + a ) * <span class="number">10.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( opt == <span class="number">2</span> )</span><br><span class="line">            ans = ( <span class="keyword">int</span> ) ( ( <span class="keyword">double</span> ) b / a * <span class="number">10.0</span> );</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">if</span> ( str[<span class="number">0</span>] == <span class="string">'x'</span> )</span><br><span class="line">                ans = ( <span class="keyword">int</span> ) ( ( <span class="keyword">double</span> ) b * a * <span class="number">10.0</span> );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans = ( <span class="keyword">int</span> ) ( ( <span class="keyword">double</span> ) a / b * <span class="number">10.0</span> );</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">cout</span> << ans / <span class="number">10</span> << <span class="string">'.'</span> << ans % <span class="number">10</span> << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-3"><a href="#problem-3" class="headerlink" title="problem 3"></a>problem 3</h2><h3 id="題目-2"><a href="#題目-2" class="headerlink" title="題目"></a>題目</h3><p>給定 $N$ 組字串，請將字串以 $’:’ or ‘;’ or ‘,’$ 切割<br>並輸出出所有字串</p><h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>啊就水題水到爆啊，多開個 string 紀錄就好了<br>這題沒有難度（蓋章</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str, swp;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> >> t;</span><br><span class="line">    getline ( <span class="built_in">cin</span>, str );</span><br><span class="line">    <span class="keyword">while</span> ( t-- ){</span><br><span class="line">        getline ( <span class="built_in">cin</span>, str );</span><br><span class="line">        <span class="built_in">cout</span> << <span class="string">"Tokens found:\n"</span>;</span><br><span class="line">        swp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: str ){</span><br><span class="line">            <span class="keyword">if</span> ( i == <span class="string">':'</span> || i == <span class="string">','</span> || i == <span class="string">';'</span> ){</span><br><span class="line">                <span class="built_in">cout</span> << swp << <span class="string">'\n'</span>;</span><br><span class="line">                swp = <span class="string">""</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                swp += i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ( swp != <span class="string">""</span> )</span><br><span class="line">            <span class="built_in">cout</span> << swp << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-4"><a href="#problem-4" class="headerlink" title="problem 4"></a>problem 4</h2><h3 id="題目-3"><a href="#題目-3" class="headerlink" title="題目"></a>題目</h3><p>zj 上面的是羅馬數字轉阿拉伯數字<br>這次 ITSA 出的是要把阿拉伯數字轉羅馬數字<br>更水 = =</p><h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>直接按照位數打表輸出就好<br>。。。雖然這麼說，但是我還是出 bug 了<br>我把4打成”IIII”，正確應該是”IX”<br>垃圾是我QQ</p><h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by.MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> lib0[<span class="number">10</span>] = { <span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span> };</span><br><span class="line"><span class="built_in">string</span> lib1[<span class="number">10</span>] = { <span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span> };</span><br><span class="line"><span class="built_in">string</span> lib2[<span class="number">10</span>] = { <span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span> };</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, in;</span><br><span class="line">    <span class="built_in">cin</span> >> t;</span><br><span class="line">    <span class="keyword">while</span> ( t-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> in;</span><br><span class="line">        <span class="built_in">cout</span> << lib2[in / <span class="number">100</span>] << lib1[in % <span class="number">100</span> / <span class="number">10</span>] << lib0[in % <span class="number">10</span>] << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="problem-5"><a href="#problem-5" class="headerlink" title="problem 5"></a>problem 5</h2><h3 id="題目-4"><a href="#題目-4" class="headerlink" title="題目"></a>題目</h3><p>給定兩個字串，求出這兩個字串所有的 LCS</p><h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>本來只有丟任意解的 LCS<br>然後就吃 WA 了，又多一個 penalty<br>問官方官方一直沒有回應<br>就想說先寫所有解的版本好了<br>等到一回覆馬上 judge</p><p>然後這就是裸的 LCS 啊 = =</p><h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>], ma;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> a, b, str;</span><br><span class="line">    <span class="built_in">set</span> < <span class="built_in">string</span> > lib;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">cin</span> >> a >> b ){</span><br><span class="line">        <span class="keyword">int</span> szA = a.size(), szB = b.size();</span><br><span class="line">        lib.clear();</span><br><span class="line">        <span class="built_in">memset</span> ( dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp );</span><br><span class="line">        ma = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < szA ; i++ ){</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j < szB ; j++ ){</span><br><span class="line">                <span class="keyword">if</span> ( a[i] == b[j] ){</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                    ma = max ( ma, dp[i + <span class="number">1</span>][j + <span class="number">1</span>] );</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ( !ma ){</span><br><span class="line">            <span class="built_in">cout</span> << <span class="string">"No common sequence!\n"</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < szA ; i++ ){</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j < szB ; j++ ){</span><br><span class="line">                <span class="keyword">if</span> ( dp[i + <span class="number">1</span>][j + <span class="number">1</span>] == ma ){</span><br><span class="line">                    str = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">for</span> ( <span class="keyword">int</span> k = i - ma + <span class="number">1</span> ; k <= i ; k++ )</span><br><span class="line">                        str += a[k];</span><br><span class="line">                    lib.insert ( str );</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i: lib )</span><br><span class="line">            <span class="built_in">cout</span> << i << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>在第 37 分鐘的時候就破台了<br>（那時候師大還沒有破台）<br>那時候我跟師大的 penalty 差 67<br>也就是說如果師大 p4 吃超過67的 penalty 我就保證第一了<br>。。。然後師大只吃 66<br>80 抽抽不到術師匠的非洲酋長正常發揮QQ</p><p>下一次沒意外就會去打 PTC 了<br>不過是英文題目<br>我覺得我會扛不起來<br>在此誠徵英文好的選手一名<br>工作：只要幫我翻譯題目就好</p><p>然後這一篇的題解我居然寫了 330 行<br>喔，這行就 331 了 = =<br>雖然看起來很多不過大部分都是 code 就是了</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;簡單來說就是我特殊選才的資料不夠&lt;br&gt;所以只好來打這東西，不然備審有夠空QQ&lt;br&gt;
    
    </summary>
    
    
      <category term="Full Contest Solution" scheme="https://miohitokiri5474.github.io/code/tags/Full-Contest-Solution/"/>
    
      <category term="ITSA" scheme="https://miohitokiri5474.github.io/code/tags/ITSA/"/>
    
  </entry>
  
  <entry>
    <title>Disjoint Set 並查集</title>
    <link href="https://miohitokiri5474.github.io/code/dsu/"/>
    <id>https://miohitokiri5474.github.io/code/dsu/</id>
    <published>2018-09-11T00:16:11.000Z</published>
    <updated>2019-10-26T08:47:35.290Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>上一篇blog因為介紹並查集的地方太多了，文章太長<br>所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了<br>然後會在昨天文章上加入這篇的連結<br><a id="more"></a></p><h2 id="disjoint-set-並查集"><a href="#disjoint-set-並查集" class="headerlink" title="disjoint set 並查集"></a>disjoint set 並查集</h2><p>我們會開一個陣列，記錄自己的老大是誰（最一開始的時候，所有人的老大都是自己）<br>在把兩個並查集合併（假設這兩個並查集老大為 $a, b$ ）的時候，把其中一個老大當作是這個新的並查集的老大，也就是把 $a$ 的老大指定為 $b ( dis[a] = b )$<br>至於查詢呢？我們可以用遞迴實作，不斷的遞迴下去直到有一個點老大是自己，則代表說這個點已經是這個並查集的頂了</p><p>這個時候大概會寫出像這樣的 code</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disjoint set</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 10005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span> <span class="params">( <span class="keyword">void</span> )</span></span>{</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < maxN ; i++ )</span><br><span class="line">        dis[i] = i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">return</span> dis[n] == n ? dis[n] : find ( dis[n] );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">    dis[a] = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">    <span class="keyword">return</span> find ( a ) == find ( b );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="路徑壓縮"><a href="#路徑壓縮" class="headerlink" title="路徑壓縮"></a>路徑壓縮</h3><p>我們先觀察一下上面的 code，會發現在 find 的時候可能會往上回朔好幾層，而且這個點的老大就固定不變了（除非有新的合併）<br>所以我們會做一個優化，叫做路徑壓縮，在回傳同時，順便紀錄這個點的老大是誰<br>下次就可以直接略過中間的點，直接到老大那了</p><p>find 函數會被改成這樣<br>親民寫法：<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( dis[n] == n )</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> dis[n] = find ( n );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>然後就是會有人（例如我），會想要把它寫在一起<br>所以就變成這樣了XD<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>最後這個東西的複雜度會變成均攤 $O ( \log N )$，感覺還不錯</p><h3 id="避免-Stack-Overflow"><a href="#避免-Stack-Overflow" class="headerlink" title="避免 Stack Overflow"></a>避免 Stack Overflow</h3><p>最最最後有個東西也挺重要的<br>因為路徑壓縮還是要按照這個點的遍歷往上爬<br>又是用遞迴實作<br>所以有機會會戳到 Stack overflow<br>然後你就吃 RE 了<br>恭喜多一個 penalty<br>重點是你不知道<strong>這樣會吃到 Stack overflow</strong> 然後就會多吃幾個w</p><p>雖然說現在很多 judge 都避免掉了啦<br>會把 stack 的記憶體大小開的跟那一提的 Memery Limit 一樣大<br>只是難免會戳到那種舊型 judge<br>所以還是乖乖學一下怎麼避免 Stack overflow 吧</p><p>要壓縮遞迴深度，可以有兩種方法</p><h4 id="方法一：random"><a href="#方法一：random" class="headerlink" title="方法一：random"></a>方法一：random</h4><p>在 Union 完後隨便戳一個點 find 一下，剛好會把它上面的那一長串都更新一遍<br>但是這東西太機率了，搞不好還是會戳到，只能怪臉黑啦</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">    dis[a] = b;</span><br><span class="line">    find ( rand() % n );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="方法二：Union-by-rank"><a href="#方法二：Union-by-rank" class="headerlink" title="方法二：Union by rank"></a>方法二：Union by rank</h4><p>把 rank 小的集合接在大的集合上，讓深度平均點，遞迴的時候就比較不會戳到超級深的一條鏈<br>理論上這樣應該不會爆炸，因為深度很平均</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rk[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( rk[a] < rk[b] )</span><br><span class="line">        swap ( a, b );</span><br><span class="line">    dis[b] = a;</span><br><span class="line">    rk[b] = rk[a] + <span class="number">1</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>這樣可以很神奇的把複雜度壓在 $O ( α ( N ) )$ 下<br>那個 $α ( N )$ 是阿克曼函數的反函數，即反阿克曼函數<br>至於那是啥我也不知道，只知道幾乎可以算是常數了</p><p>不過因為通常都會做路徑壓縮，所以 rank 到最後都很小，因此我不常用</p><h4 id="方法三：Union-by-size"><a href="#方法三：Union-by-size" class="headerlink" title="方法三：Union by size"></a>方法三：Union by size</h4><p>這也挺直觀的<br>把大小比較小的並查集接在大的下面<br>比較小，需要做改動的點就比較少，對吧</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sz[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( sz[a] > sz[b] )</span><br><span class="line">        swap ( a, b );</span><br><span class="line">    dis[a] = b;</span><br><span class="line">    sz[b] += sz[a];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="如果開優化還是爛了呢"><a href="#如果開優化還是爛了呢" class="headerlink" title="如果開優化還是爛了呢"></a>如果開優化還是爛了呢</h4><p>通常我固定都會開 Union 前 find，如果還是爛掉的話就再加上 Union by Size<br>再爛掉。。。這應該是叫你去寫啟發式合併吧<br>據說那東西比並查集還要快<br>不過我也沒有實作過，所以我並不清楚</p><h3 id="確認是否屬於同一個並查集"><a href="#確認是否屬於同一個並查集" class="headerlink" title="確認是否屬於同一個並查集"></a>確認是否屬於同一個並查集</h3><p>確認的方法很簡單，只要兩個的頭頭都一樣，肯定在同一個並查集內</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">    <span class="keyword">return</span> find ( a ) == find ( b )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用以上的方法就可以快速地確認兩個點是否屬於同一個並查集了</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>我昨天到底發什麼瘋啊，沒事寫這麼多 dsu 的教學幹嘛 = =<br>現在看了一下，我光 dsu 就寫 171 行了@@<br>覺得累</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇blog因為介紹並查集的地方太多了，文章太長&lt;br&gt;所以我今天把昨天介紹並查集那一段拔出來，另外寫一篇文章好了&lt;br&gt;然後會在昨天文章上加入這篇的連結&lt;br&gt;
    
    </summary>
    
    
      <category term="data structure" scheme="https://miohitokiri5474.github.io/code/tags/data-structure/"/>
    
      <category term="dsu" scheme="https://miohitokiri5474.github.io/code/tags/dsu/"/>
    
      <category term="disjoint set" scheme="https://miohitokiri5474.github.io/code/tags/disjoint-set/"/>
    
  </entry>
  
  <entry>
    <title>[TOJ][420] C. 藏寶圖</title>
    <link href="https://miohitokiri5474.github.io/code/TOJ-420/"/>
    <id>https://miohitokiri5474.github.io/code/TOJ-420/</id>
    <published>2018-09-10T06:17:57.000Z</published>
    <updated>2019-10-26T08:47:35.290Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>今天來講講自己出的題目好了<br>這題是我在今年（2018）六月時排名賽出的題目<br>搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ<br><a id="more"></a></p><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>先附上<a href="https://toj.tfcis.org/oj/pro/420/" target="_blank" rel="noopener">原題目網址</a></p><p>題意略，總之，就是給定一張圖，求這張圖的 MST 的樹直徑<br>MST 怎麼做？我這邊選用 Kruskal<br>（當然也可以用 Prim 做啦，只是個人習慣寫 Kruskal）</p><h2 id="先備知識"><a href="#先備知識" class="headerlink" title="先備知識"></a>先備知識</h2><p>在提 Kruskal 前，我們先講講 MST 到底是什麼吧</p><h3 id="最小生成樹"><a href="#最小生成樹" class="headerlink" title="最小生成樹"></a>最小生成樹</h3><p>MST 的正式全名為「最小生成樹」<br>所謂的生成樹就是把這張圖拔掉一些邊後，這張圖<em>沒有環</em>以及<em>所有點都有聯通</em><br>也就是說：<br>假設目前有張圖 $G$ 的子圖 $T$，且 $T$ 上任意兩點間只有<em>剛好</em>一條路徑，則稱 $T$ 為 $G$ 的其中一顆生成樹</p><p>而當一張圖 $G$ 的子圖 $T1$ 且 $T1$ 為 $G$ 之最小生成樹，則代表找不到另外其他同為生成樹的子圖 $T’$ 其邊權重總和比 $T1$ 還要來得大時，就稱 $T1$ 為圖 $G$ 的最小生成樹</p><h3 id="樹直徑"><a href="#樹直徑" class="headerlink" title="樹直徑"></a>樹直徑</h3><p>那麼樹直徑又是什麼呢？<br>通常樹直徑就是一棵樹上的任意點對的最長距離</p><h2 id="作法"><a href="#作法" class="headerlink" title="作法"></a>作法</h2><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>我先講講Kruskal是什麼好了</p><p>按照MST的定義，有個很直觀的想法</p><ol><li>先按照邊的權重對於所有邊由小到大排序過</li><li>依序取出所有邊，假設這個邊的兩端還不在同一個聯通塊內，則把這個邊加進去 MST 中</li></ol><p>至於要怎麼確認這兩個點是不是屬於同一個聯通塊內呢？總不可能暴力dfs吧<br>這時就要搬另外一個資料結構出來了，叫並查集(disjoint set)<br>詳細內容可以看<a href="https://miohitokiri5474.github.io/code/dsu/">這篇</a></p><h3 id="樹直徑-1"><a href="#樹直徑-1" class="headerlink" title="樹直徑"></a>樹直徑</h3><p>樹直徑作法通常有兩個：</p><ol><li>dfs時紀錄離當前點 $n_i$ 最遠的點 $u_i$ 以及次遠的點 $v_i$，則所有點 $n_i~u_i + n_i~v_i$ 的距離之最大值就是樹直徑</li><li>先對任意一個點 dfs 一次，找出離該點最遠的點再dfs一次，離該點最遠的最大值就是答案</li></ol><p>作法1還挺好瞭解的，只是實作上可能會出包<br>作法2有點費時間，但是很好寫</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>總而言之，我的 code 長這樣<br>是用 Kruskal + dsu 路徑壓縮 + 樹直徑方法二寫的</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 1000005</span></span><br><span class="line"><span class="keyword">typedef</span> pair < <span class="keyword">int</span>, <span class="keyword">int</span> > pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">( node a, node b )</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a.w < b.w;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxN];</span><br><span class="line">LL dist[maxN];</span><br><span class="line"><span class="built_in">vector</span> < node > edges;</span><br><span class="line"><span class="built_in">vector</span> < pii > mst[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span> <span class="params">( <span class="keyword">void</span> )</span></span>{</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < maxN ; i++ )</span><br><span class="line">        dis[i] = i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">    dis[find ( a )] = find ( b );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">    <span class="keyword">return</span> find ( a ) == find ( b );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Kruskal</span> <span class="params">( <span class="keyword">void</span> )</span></span>{</span><br><span class="line">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: edges ){</span><br><span class="line">        <span class="keyword">if</span> ( same ( i.u, i.v ) )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Union ( i.u, i.v );</span><br><span class="line">        mst[i.u].pb ( pii ( i.v, i.w ) );</span><br><span class="line">        mst[i.v].pb ( pii ( i.u, i.w ) );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n, <span class="keyword">int</span> p )</span></span>{ <span class="comment">// 樹直徑</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: mst[n] ){</span><br><span class="line">        <span class="keyword">if</span> ( i.F == p )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dist[i.F] = dist[n] + i.S;</span><br><span class="line">        dfs ( i.F, n );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, u, v, w, t, idx, now;</span><br><span class="line">    LL ma = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> n >> m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> ( m-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> u >> v >> w;</span><br><span class="line">        edges.pb ( node { u, v, w } );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Kruskal();</span><br><span class="line"></span><br><span class="line">    dfs ( <span class="number">0</span>, <span class="number">-1</span> );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ )</span><br><span class="line">        <span class="keyword">if</span> ( ma < dist[i] )</span><br><span class="line">            ma = dist[i], idx = i;</span><br><span class="line"></span><br><span class="line">    dist[idx] = <span class="number">0</span>;</span><br><span class="line">    dfs ( idx, <span class="number">-1</span> );</span><br><span class="line">    ma = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ )</span><br><span class="line">        ma = max ( ma, dist[i] );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << ma << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>我這一篇文我有種我是在寫 disjoint set 教學的錯覺<br>覺得累<br>大半篇幅都是在教 disjoint set<br>看來原始 md 檔要破 300 行了呢（倒地</p><p>然後還有那一堆數學式子，看到頭都在痛<br>我個人還蠻喜歡寫那些東西的<br>看起來很猛（就是中二啦 = =<br>不過常常寫到一半會開始懷疑<br>我沒事寫那麼難動幹嘛<br>沒事虐待自己幹嘛<br>話雖如此不過還是寫完了啦XD</p><h2 id="更新-2019-03-06"><a href="#更新-2019-03-06" class="headerlink" title="更新(2019/03/06)"></a>更新(2019/03/06)</h2><p>雖然說不是最近的事了，不過我想我還是提一下好了<br>因為去年十月跟社團上有一點不高興，我要求學弟把我出的題目下架了<br>所以目前在 TOJ 上寫不到這題喔<br>非常抱歉 > <</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天來講講自己出的題目好了&lt;br&gt;這題是我在今年（2018）六月時排名賽出的題目&lt;br&gt;搞測資搞了一個禮拜，結果賽中只有一個人有認真寫過QQ&lt;br&gt;
    
    </summary>
    
    
      <category term="dfs" scheme="https://miohitokiri5474.github.io/code/tags/dfs/"/>
    
      <category term="TOJ" scheme="https://miohitokiri5474.github.io/code/tags/TOJ/"/>
    
      <category term="MST" scheme="https://miohitokiri5474.github.io/code/tags/MST/"/>
    
      <category term="dsu" scheme="https://miohitokiri5474.github.io/code/tags/dsu/"/>
    
      <category term="樹直徑" scheme="https://miohitokiri5474.github.io/code/tags/%E6%A8%B9%E7%9B%B4%E5%BE%91/"/>
    
      <category term="Kruskal" scheme="https://miohitokiri5474.github.io/code/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>[TOJ][407] D. 警力配置</title>
    <link href="https://miohitokiri5474.github.io/code/TOJ-407/"/>
    <id>https://miohitokiri5474.github.io/code/TOJ-407/</id>
    <published>2018-08-16T13:59:42.000Z</published>
    <updated>2019-10-26T08:47:35.289Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =<br><del>別再給我增加工作量啊垃圾</del><br>我還要把舊站的文章搬過來改成 md 檔啊 = =</p><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>我先附上<a href="http://toj.tfcis.org/oj/pro/407/" target="_blank" rel="noopener">連結</a></p><p>題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」<br>不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組<br><a id="more"></a><br>有了小組就要管理，要管理就要組長，因此局長決定要選出其中一些人當組長<br>組長會有比較好的待遇，但是這些待遇會造成財政負擔，所以希望組長盡可能地少，但是對於任何一個小組至少有一個組長</p><p><strong>注意：至少有一個 $\to$ 有兩個也沒關係</strong></p><p>這超重要啊！我當初以為一組只能有一個所以很順手的寫了個著色，結果這題根本不能用著色寫<br><del>（但是不小心撈到73分，我問號）</del></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>很顯然的要先轉成一張圖，這絕對是圖論 = =<br>也就是說題意可以被化簡成這樣：<br>給定一張圖，求至少需要選幾個節點才能保證所有邊都有被這些點接觸到<br>。。。啊不就匈牙利<br>既然知道是匈牙利就好寫啦，不知道匈牙利的可以翻一下<a href="http://www.csie.ntnu.edu.tw/~u91029/Matching.html" target="_blank" rel="noopener">這篇</a><br>然後因為這篇有不少內容，所以請自己 ctrl + F（Mac用戶請用 cmd + F）搜尋一下匈牙利演算法</p><p>因為這題真的是裸題（？）所以我就直接附 code 了</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 200005</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> < <span class="keyword">int</span> > edges[maxN];</span><br><span class="line"><span class="keyword">int</span> match[maxN], visit[maxN], turn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    visit[n] = turn;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges[n] ){</span><br><span class="line">        <span class="keyword">if</span> ( match[i] == <span class="number">-1</span> || ( visit[match[i]] != turn && dfs ( match[i] ) ) ){</span><br><span class="line">            match[i] = n;</span><br><span class="line">            match[n] = i;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, m, u, v, p, q, ans;</span><br><span class="line">    <span class="built_in">cin</span> >> t;</span><br><span class="line">    <span class="keyword">while</span> ( t-- ){</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span> ( match, <span class="number">-1</span>, <span class="keyword">sizeof</span> match );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> &i: edges )</span><br><span class="line">            i.clear();</span><br><span class="line">        <span class="built_in">cin</span> >> p >> q >> m;</span><br><span class="line">        <span class="keyword">while</span> ( m-- ){</span><br><span class="line">            <span class="built_in">cin</span> >> u >> v;</span><br><span class="line">            v += p;</span><br><span class="line">            edges[u].pb ( v );</span><br><span class="line">            edges[v].pb ( u );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        p += q;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i <= p ; i++ ){</span><br><span class="line">            <span class="keyword">if</span> ( match[i] == <span class="number">-1</span> ){</span><br><span class="line">                turn++;</span><br><span class="line">                <span class="comment">// 省去每次 dfs 都要 memset 一次 visit 陣列的時間</span></span><br><span class="line">                <span class="keyword">if</span> ( dfs ( i ) )</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="comment">// 如果可以找到新的配對就 ans++</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>然後這邊我有用到一個小技巧，可以避免 TLE<br>通常在 dfs 一份有環圖時，都會開一個 bool 陣列記錄這個點是否已經處理過了，避免在這邊一直繞造成 stack overflow<br>不過在需要 dfs 數次的時候就需要把這個陣列 memset，需要浪費 $O ( N )$ 的時間（我不是很確定）<br>如果我們把這個陣列開成 int 陣列<br>並且在dfs時不是確認 $visit[n] == true$ 而是確認 $visit[n] == turn$，每到下一輪就把 $turn++$，以便紀錄這是底幾輪<br>這樣就不用浪費時間去 memset 了</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是某位捧油問我的問題，用 Messenger 傳太慢了，直接打成一篇 blog 好了= =&lt;br&gt;&lt;del&gt;別再給我增加工作量啊垃圾&lt;/del&gt;&lt;br&gt;我還要把舊站的文章搬過來改成 md 檔啊 = =&lt;/p&gt;
&lt;h2 id=&quot;題目&quot;&gt;&lt;a href=&quot;#題目&quot; class=&quot;headerlink&quot; title=&quot;題目&quot;&gt;&lt;/a&gt;題目&lt;/h2&gt;&lt;p&gt;我先附上&lt;a href=&quot;http://toj.tfcis.org/oj/pro/407/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;連結&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;題目敘述大意就是有兩個部門因為要搜查之類的，所以兩兩配對成一個「小組」&lt;br&gt;不過並沒有規定同一人只能屬於一個小組，同一名警察可以同時屬於複數的小組&lt;br&gt;
    
    </summary>
    
    
      <category term="graph" scheme="https://miohitokiri5474.github.io/code/tags/graph/"/>
    
      <category term="TOJ" scheme="https://miohitokiri5474.github.io/code/tags/TOJ/"/>
    
  </entry>
  
  <entry>
    <title>[CF][999E] E. REACHABILITY FROM THE CAPITAL</title>
    <link href="https://miohitokiri5474.github.io/code/CF-999E/"/>
    <id>https://miohitokiri5474.github.io/code/CF-999E/</id>
    <published>2018-08-03T14:47:34.000Z</published>
    <updated>2019-10-26T08:47:35.283Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="題目-解法"><a href="#題目-解法" class="headerlink" title="題目 + 解法"></a>題目 + 解法</h2><p>這是 CodeForces Round 490 div.3 的題目<br>最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人<br>沒有意外下一場應該就會下來了吧<br>先放上題目<a href="http://codeforces.com/problemset/problem/999/E" target="_blank" rel="noopener">連結</a><br><a id="more"></a></p><p>會寫這題的緣故是因為有某位捧油說他不會寫，前天在台北 ytp 的時候稍微提了下<br>今天想說把它寫成一篇題解吧，等等寫完剛好可以去看昨天 Education Round 的 Final Standing（雖然我沒打）</p><p>講一下題目大意好了<br>首先，給定一張圖有 $N$ 個點、$M$ 條單向邊，並給定一點 $S$<br>求現在這張圖還需要加上幾條邊（當然也是單向的），才可以使 $S$ 與此圖上的任意一點$U$有單向路徑（ $S$ 到 $U$ ）</p><p>有個很直觀的想法如下，首先點會先被分成兩種類型：</p><ol><li>這些點都可以從 $S$ 到達——也就是說，從 $S$ 開始 dfs ，這些點都會經過</li><li>沒有經過的點（從 $S$ 出發到達不了）</li></ol><p>所以要讓剩下的點都可以從 $S$ 到達，那就把邊接在類型2的那些點的頭（從這個點回朔到最頂端的點，有點樹鍊剖分的感覺），不就是最少新增邊的數量了？<br>（因為這些點的頂點可能會重複——即便沒有重複。。。這些點總還是要連接上去吧）</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize ( <span class="meta-string">"O3"</span> )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> loop_opt ( on )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 5005</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> < <span class="keyword">int</span> > edges[maxN];</span><br><span class="line"><span class="keyword">int</span> pa[maxN];</span><br><span class="line"><span class="keyword">bool</span> used[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n, <span class="keyword">int</span> p )</span></span>{</span><br><span class="line">    used[n] = <span class="literal">true</span>;</span><br><span class="line">    pa[n] = p;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges[n] ){</span><br><span class="line">        <span class="keyword">if</span> ( used[i] )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs ( i, p );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, s, u, v;</span><br><span class="line">    <span class="built_in">cin</span> >> n >> m >> s;</span><br><span class="line">    <span class="keyword">while</span> ( m-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> u >> v;</span><br><span class="line">        edges[u].push_back ( v );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs ( s, s );</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i <= n ; i++ ){</span><br><span class="line">        <span class="keyword">if</span> ( pa[i] == <span class="number">0</span> ){</span><br><span class="line">            <span class="built_in">memset</span> ( used, <span class="number">0</span>, <span class="keyword">sizeof</span> used );</span><br><span class="line">            dfs ( i, i );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> < <span class="keyword">int</span> > lib;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i <= n ; i++ ){</span><br><span class="line">        <span class="keyword">if</span> ( pa[i] != s )</span><br><span class="line">            lib.insert ( pa[i] );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << lib.size() << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>可能有些人會有這個疑問：為甚麽我要在每次 dfs 前都把 used（記錄是否已經經過）清空，這樣不是會把某些點的 pa（記錄最頂頭的點是哪個）洗掉嗎，如果那些點已經是可以從 $S$ 到達的，這樣不是有可能會多算？</p><p>是這樣的：我會從這個點開始 dfs，代表我還不確定他的最頂（pa）在哪，意思就是說，我必須要在這個點以及 $S$ 之間加上一條邊，這還挺合理的吧（？</p><p>又，只要我在這個點以及 $S$ 之間加上一條邊了，那麼我好像也不用擔心他的子結點了，反正都會走到<br>所以即便 pa 被覆寫了也是沒有關係的</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;題目-解法&quot;&gt;&lt;a href=&quot;#題目-解法&quot; class=&quot;headerlink&quot; title=&quot;題目 + 解法&quot;&gt;&lt;/a&gt;題目 + 解法&lt;/h2&gt;&lt;p&gt;這是 CodeForces Round 490 div.3 的題目&lt;br&gt;最近因為 div.3（水題上分 round）的緣故，不小心搭上 rating 通膨的潮流，上了藍人&lt;br&gt;沒有意外下一場應該就會下來了吧&lt;br&gt;先放上題目&lt;a href=&quot;http://codeforces.com/problemset/problem/999/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;連結&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="CodeForces" scheme="https://miohitokiri5474.github.io/code/tags/CodeForces/"/>
    
      <category term="div.3" scheme="https://miohitokiri5474.github.io/code/tags/div-3/"/>
    
      <category term="graph" scheme="https://miohitokiri5474.github.io/code/tags/graph/"/>
    
      <category term="dfs" scheme="https://miohitokiri5474.github.io/code/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>[TOJ][406] C. 軍隊部署</title>
    <link href="https://miohitokiri5474.github.io/code/TOJ-406/"/>
    <id>https://miohitokiri5474.github.io/code/TOJ-406/</id>
    <published>2018-07-18T11:39:09.000Z</published>
    <updated>2019-10-26T08:47:35.289Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>老樣子先放連結<br><a href="http://toj.tfcis.org/oj/pro/406/" target="_blank" rel="noopener">TOJ</a><br><a href="https://zerojudge.tw/ShowProblem?problemid=c460" target="_blank" rel="noopener">ZJ</a><br>這是去年（106年）全國學科能力競賽資訊科全國賽的pC<br>分類上算是水題一枚（按照去年整體難度來說）</p><p>題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊<br><a id="more"></a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>所以如果我們先不看種族，我們先看能力就好，可以看成：</p><ul><li>第一位：是否對空，是為 $1$，否為 $0$</li><li>第二位：是否範圍，是為 $1$，否為 $0$</li><li>第三位：是否遠距，是為 $1$，否為 $0$</li></ul><p>所以如果有一個兵種，同時對空、遠距，但是不支援範圍攻擊，則會被寫成這樣：$(101)_2$<br>然後，咦？看起來好像二進位呢！那我們把這個數字看成二進位轉成十進位吧<br>會發現題目所有數字都不會大於 $7$，因為數字最大時就是所有功能都有，然後 $4 + 2 + 1 = 7$</p><p>接著是種族，有三種族，所以代號為$1, 2, 3$</p><p>那麼來做dp陣列的規劃吧<br>$dp[i][j]$ 代表：種族為 $i$ 的某兵種，具有代號為 $j$ 的功能</p><p>然後要求是三種族、三功能都要有，所以<strong>那三種兵種的代號做位元運算 or 的時候要為7（$(111)_2$），並同時包含三種族</strong></p><p>呃我這邊可能講的有點不好，但是我當初就是有點直覺得就這樣想<br>看 code 可能會比較好瞭解，我 code 放下面</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, x, y, z, w, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < n ; i++ ){</span><br><span class="line">        <span class="built_in">cin</span> >> w >> x >> y >> z;</span><br><span class="line">        dp[w][x * <span class="number">4</span> + y * <span class="number">2</span> + z]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < <span class="number">8</span> ; i++ )</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j < <span class="number">8</span> ; j++ )</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span> ; k < <span class="number">8</span> ; k++ )</span><br><span class="line">                <span class="keyword">if</span> ( ( i | j | k ) == <span class="number">7</span> )</span><br><span class="line">                    ans += dp[<span class="number">1</span>][i] * dp[<span class="number">2</span>][j] * dp[<span class="number">3</span>][k];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << ans << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;題目&quot;&gt;&lt;a href=&quot;#題目&quot; class=&quot;headerlink&quot; title=&quot;題目&quot;&gt;&lt;/a&gt;題目&lt;/h2&gt;&lt;p&gt;老樣子先放連結&lt;br&gt;&lt;a href=&quot;http://toj.tfcis.org/oj/pro/406/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TOJ&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zerojudge.tw/ShowProblem?problemid=c460&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ZJ&lt;/a&gt;&lt;br&gt;這是去年（106年）全國學科能力競賽資訊科全國賽的pC&lt;br&gt;分類上算是水題一枚（按照去年整體難度來說）&lt;/p&gt;
&lt;p&gt;題目大意略，總之，希望創造出一個軍隊，同時包含對空、範圍、遠距攻擊都有的軍隊&lt;br&gt;
    
    </summary>
    
    
      <category term="dp" scheme="https://miohitokiri5474.github.io/code/tags/dp/"/>
    
      <category term="TOJ" scheme="https://miohitokiri5474.github.io/code/tags/TOJ/"/>
    
      <category term="ZJ" scheme="https://miohitokiri5474.github.io/code/tags/ZJ/"/>
    
      <category term="全國賽" scheme="https://miohitokiri5474.github.io/code/tags/%E5%85%A8%E5%9C%8B%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>[CF][920F] F. SUM AND REPLACE</title>
    <link href="https://miohitokiri5474.github.io/code/CF-920F/"/>
    <id>https://miohitokiri5474.github.io/code/CF-920F/</id>
    <published>2018-04-03T03:25:31.000Z</published>
    <updated>2019-10-26T08:47:35.283Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久沒有發題解了，今天心血來潮來寫一篇吧<br>今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF<br>pF，感覺很難？其實還好， 因為這是 Education<br><a id="more"></a></p><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>不管，翻譯下題目好了，畢竟原題是英文的<br>要原題連結的<a href="http://codeforces.com/problemset/problem/920/F" target="_blank" rel="noopener">在這</a></p><p>給定一個長度為N的序列，並有兩種輸入要處理：</p><ol><li>對區間 $l, r$ 做操作 $D$（等等寫在下面）</li><li>查詢區間和</li></ol><p>操作 $D$ ：把該數字轉換成此數字的因數個數，例如原先的數字是 $6$ ，則操作後會變成 $4$（ $6$ 的因數有 $\{1, 2, 3, 6\}$，共四個）</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>嗯。。。區間操作？區間和？<br>怎麼看都是線段樹，但是問題是：操作<br>因為操作要查詢的是因數個數，我想不到更好的做法，所以就直接暴力，但是我只有跑到 $\sqrt{N}$，證明我等等再打</p><p>好，我們先觀察一下：</p><ol><li>只要數字是 $1$ 或 $2$ 就不用繼續操作下去了，對吧（ $2$ 的因數有 $1, 2$，$1$ 的因數只有 $1$ ，所以這兩個數字怎麼操作之後不會變）</li><li>越小的數字出現機率越大，也就是更容易使用，所以我們再建一個表，把用過的數字存起來，如果這個數字沒有計算過再算，不然就直接回傳結果</li></ol><p>接著是最後一個問題：該如何處理區間操作<br>對於處理這種無法打 Lazy Tag 的問題（因為這題就算打 Lazy Tag 還是要做 $K$（需要進行的操作次數）次，所以打 Lazy Tag 並沒有任何意義）<br>不過有種做法叫<strong>找收斂點（終止點）</strong></p><p>剛剛有提到，當數字為 $1$ 或 $2$ 進行操作並沒有任何意義，所以可以把此區間到底還有沒有 $\ge 2$ 的數字當作是否繼續進行操作的依據</p><p>到這，可能有人想到我之前發的某一題，題目是區間取模，所以紀錄區間最大值，如果有比當前需要操作的$m$還有大的數字才需要繼續進行操作，詳細可以看<a href="https://miohitokiri.github.io/code/TOJ-391/" target="_blank" rel="noopener">這篇</a></p><p>不過大概算了一下，這樣需要開到$8\times N$的記憶體，感覺會 MLE<br>所以我先拿區間和開刀，如果當前區間和 $\ge 2\times range（區間大小）$ 再繼續進行操作<br>。。。然後我就 WA 了，請想想如果當前區間內元素為 $\{ 1, 1, 1, 3 \}$ 的時候</p><p>有夠陰，總和為 $8$ ，乍看之下不需要做操作，但是實際上卻有需要進行修改的數字<br>所以我只能再開一顆線段樹（ bool的），記錄當前區間是否有數字 $\ge 2$</p><p>本來不想要開第二顆線段樹，到頭來還不是開了</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 300005</span></span><br><span class="line"></span><br><span class="line">LL sum[maxN << <span class="number">2</span>], dp[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">bool</span> used[maxN << <span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span> < <span class="keyword">int</span> > prime;</span><br><span class="line"><span class="built_in">bitset</span> < 1005 > lib;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">D</span> <span class="params">( <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( dp[n] != <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    <span class="keyword">double</span> www = <span class="built_in">sqrt</span> ( n );</span><br><span class="line">    <span class="keyword">int</span> ma = www, res = <span class="number">0</span>, maa = ma + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i < maa ; i++ )</span><br><span class="line">        n % i ? res : res++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n] = res * <span class="number">2</span> - ( www == ma ? <span class="number">1</span> : <span class="number">0</span> );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( l == r ){</span><br><span class="line">        <span class="built_in">cin</span> >> sum[n];</span><br><span class="line">        used[n] = ( sum[n] > <span class="number">2</span> );</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">int</span> mid = ( l + r ) >> <span class="number">1</span>, leftSon = n << <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        build ( l, mid, leftSon );</span><br><span class="line">        build ( mid + <span class="number">1</span>, r, rightSon );</span><br><span class="line"></span><br><span class="line">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class="line">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( l <= nowL && nowR <= r )</span><br><span class="line">        <span class="keyword">return</span> sum[n];</span><br><span class="line">    <span class="keyword">int</span> mid = ( nowL + nowR ) >> <span class="number">1</span>, leftSon = n << <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( r <= mid )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class="line">    <span class="keyword">if</span> ( mid < l )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">    <span class="keyword">return</span> query ( l, r, nowL, mid, leftSon ) + query ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( !used[n] )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ( nowL == nowR ){</span><br><span class="line">        sum[n] = D ( sum[n] );</span><br><span class="line">        used[n] = ( sum[n] > <span class="number">2</span> );</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">int</span> mid = ( nowL + nowR ) >> <span class="number">1</span>, leftSon = n << <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( r <= mid )</span><br><span class="line">            modify ( l, r, nowL, mid, leftSon );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( mid < l )</span><br><span class="line">            modify ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            modify ( l, r, nowL, mid, leftSon );</span><br><span class="line">            modify ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        sum[n] = sum[leftSon] + sum[rightSon];</span><br><span class="line">        used[n] = ( used[leftSon] || used[rightSon] );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    lib[<span class="number">0</span>] = lib[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span> ; i < <span class="number">1005</span> ; i++ ){</span><br><span class="line">        <span class="keyword">if</span> ( !lib[i] ){</span><br><span class="line">            prime.push_back ( i );</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i << <span class="number">1</span> ; j < <span class="number">1005</span> ; j += i )</span><br><span class="line">                lib[j] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span> ( dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp );</span><br><span class="line">    <span class="keyword">int</span> n, m, type, l, r, stop;</span><br><span class="line">    <span class="built_in">cin</span> >> n >> m;</span><br><span class="line">    build ( <span class="number">1</span>, n, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( m-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> type >> l >> r;</span><br><span class="line">        <span class="keyword">if</span> ( type == <span class="number">1</span> )</span><br><span class="line">            modify ( l, r, <span class="number">1</span>, n, <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> << query ( l, r, <span class="number">1</span>, n, <span class="number">1</span> ) << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="證明（？"><a href="#證明（？" class="headerlink" title="證明（？"></a>證明（？</h2><p>接下來來證明一下（也不能算是證明啦）為什麼只需要跑過 $\sqrt{N}$ 的數字就好了<br>假設現在要進行操作的數字為$N$，且有另外一個數字 $i$ 為 $N$ 的因數<br>這樣代表說 $\frac{N}{i}$ 也是另外一個$N$的因數對吧，我們在這邊令 $j = \frac{N}{i}  \to i \times j = N$<br>假設 $i\le j$ 帶入上面的式子，$i^2\le N\to i\le\sqrt{N}$<br>故得證</p><p>。。。好啦，我感覺我寫的證明不是對的 > <<br>以上證明僅供參考</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;好久沒有發題解了，今天心血來潮來寫一篇吧&lt;br&gt;今天的內容是 CodeForces Education Round 37 ( Rated for Div.2 )的 pF&lt;br&gt;pF，感覺很難？其實還好， 因為這是 Education&lt;br&gt;
    
    </summary>
    
    
      <category term="CodeForces" scheme="https://miohitokiri5474.github.io/code/tags/CodeForces/"/>
    
      <category term="Education Round" scheme="https://miohitokiri5474.github.io/code/tags/Education-Round/"/>
    
      <category term="segment tree" scheme="https://miohitokiri5474.github.io/code/tags/segment-tree/"/>
    
      <category term="data structure" scheme="https://miohitokiri5474.github.io/code/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>[TOJ][391] E. 模數 CANDY</title>
    <link href="https://miohitokiri5474.github.io/code/TOJ-391/"/>
    <id>https://miohitokiri5474.github.io/code/TOJ-391/</id>
    <published>2018-02-07T01:17:56.000Z</published>
    <updated>2019-10-26T08:47:35.289Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="題目-amp-解法"><a href="#題目-amp-解法" class="headerlink" title="題目 & 解法"></a>題目 & 解法</h2><p>我先附上題目<a href="http://toj.tfcis.org/oj/pro/391/" target="_blank" rel="noopener">連結</a><br>簡單來說，就是區間取餘數<br>然後這東西<strong>可以用線段樹實作</strong><br><a id="more"></a></p><p>然後問題來了，這種東西不能打 Lazy Tag 做（可以想一下為什麼，解答放文末），所以只能用類似於「區間開根號」的做法<br>在寫區間開根號的時候，我們用的是<strong>區間最大值線段樹</strong>，是的，區間最大值</p><p>理由很簡單，因為開根號開到最後，一定會朝向$1$收斂<br>所以只要當前區間的最大值為 $1$ 的時候，就不用繼續向下遞迴最修改了，對吧</p><p>同理，我們也可以用類似於這個的做法，一樣是區間最大值線段樹<strong>在修改時的終止條件是：當前區間最大值 ≤ 我們想要取模的那個數</strong><br>這應該算是一種剪枝（吧</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize ( <span class="meta-string">"O3"</span> )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> loop_opt ( on )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 200005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seg[maxN << <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        seg[n] += value;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">int</span> mid = ( l + r ) >> <span class="number">1</span>, leftSon = n << <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( index <= mid )</span><br><span class="line">            update ( l, mid, index, value, leftSon );</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            update ( mid + <span class="number">1</span>, r, index, value, rightSon );</span><br><span class="line"></span><br><span class="line">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> value, <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( seg[n] < value )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ( nowL == nowR )</span><br><span class="line">        seg[n] %= value;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">int</span> mid = ( nowL + nowR ) >> <span class="number">1</span>, leftSon = n << <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( r <= mid )</span><br><span class="line">            modify ( l, r, nowL, mid, value, leftSon );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( mid < l )</span><br><span class="line">            modify ( l, r, mid + <span class="number">1</span>, nowR, value, rightSon );</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            modify ( l, mid, nowL, mid, value, leftSon );</span><br><span class="line">            modify ( mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, nowR, value, rightSon );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        seg[n] = max ( seg[leftSon], seg[rightSon] );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, type, l, r, x, in;</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i <= n ; i++ ){</span><br><span class="line">        <span class="built_in">cin</span> >> in;</span><br><span class="line">        update ( <span class="number">0</span>, n, i, in, <span class="number">1</span> );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> >> m;</span><br><span class="line">    <span class="keyword">while</span> ( m-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> type;</span><br><span class="line">        <span class="keyword">if</span> ( type == <span class="number">1</span> ){</span><br><span class="line">            <span class="built_in">cin</span> >> l >> r;</span><br><span class="line">            update ( <span class="number">0</span>, n, r, l, <span class="number">1</span> );</span><br><span class="line">        }        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( type == <span class="number">2</span> ){</span><br><span class="line">            <span class="built_in">cin</span> >> l >> r >> x;</span><br><span class="line">            modify ( l, r, <span class="number">0</span>, n, x, <span class="number">1</span> );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> << seg[<span class="number">1</span>] << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><del>所以其實這題也不難嘛</del></p><p>為什麼不能打 Lazy Tag？</p><p>。。。因為 mod 沒有疊加性啊</p><h2 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h2><p>然後我來證明一下為什麼這樣做幾乎等同於單點修改的東西會過<br>因為取 mod 至少會把數字砍掉一半（讀者可以自行想想）<br>所以總複雜度大約為 $O ( log ( max \lbrace a_i \rbrace ) )$ 左右<br>（此部分感謝 jd3 學長提供）</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;題目-amp-解法&quot;&gt;&lt;a href=&quot;#題目-amp-解法&quot; class=&quot;headerlink&quot; title=&quot;題目 &amp;amp; 解法&quot;&gt;&lt;/a&gt;題目 &amp;amp; 解法&lt;/h2&gt;&lt;p&gt;我先附上題目&lt;a href=&quot;http://toj.tfcis.org/oj/pro/391/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;連結&lt;/a&gt;&lt;br&gt;簡單來說，就是區間取餘數&lt;br&gt;然後這東西&lt;strong&gt;可以用線段樹實作&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="segment tree" scheme="https://miohitokiri5474.github.io/code/tags/segment-tree/"/>
    
      <category term="TOJ" scheme="https://miohitokiri5474.github.io/code/tags/TOJ/"/>
    
  </entry>
  
  <entry>
    <title>[TIOJ][1795] 咕嚕咕嚕呱啦呱啦</title>
    <link href="https://miohitokiri5474.github.io/code/TIOJ-1795/"/>
    <id>https://miohitokiri5474.github.io/code/TIOJ-1795/</id>
    <published>2018-01-16T03:53:57.000Z</published>
    <updated>2019-10-26T08:47:35.287Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧</p><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>題目連結<a href="https://tioj.ck.tp.edu.tw/problems/1795" target="_blank" rel="noopener">在這</a></p><p>給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$<br>另外，任意一條邊的權重只有可能為 $0 or 1$<br><a id="more"></a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>只要做出最小生成樹以及最大生成樹就好了，證明如下<br>假定這張簡單圖的最小生成樹權重和為$lb$，最大生成樹權重和為 $ub$ ，則：</p><script type="math/tex; mode=display">ub = lb + ( 剩下的邊中，權重為1，且能替換掉mst中邊權重為0的邊的權重和 )</script><p>又，邊權重只有可能為 $0 or 1$，所以只要$lb/le k\le ub$，肯定存在一組以上的組合，可以建構出權重和為 $K$ 且 $lb\le k\e ub$ 的生成樹</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 100005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bridge</span>{</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">disjionSet</span>{</span></span><br><span class="line">    <span class="keyword">int</span> dis[maxN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span> <span class="params">( <span class="keyword">void</span> )</span></span>{</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i < maxN ; i++ )</span><br><span class="line">            dis[i] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">        <span class="keyword">return</span> dis[n] == n ? n : dis[n] = find ( dis[n] );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">        <span class="keyword">return</span> find ( a ) == find ( b );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span>{</span><br><span class="line">        dis[find ( a )] = find ( b );</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> < bridge > edges;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">( bridge a, bridge b )</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a.w < b.w;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, k, u, v, w, ub = <span class="number">0</span>, lb = <span class="number">0</span>;</span><br><span class="line">    disjionSet dis;</span><br><span class="line">    <span class="built_in">cin</span> >> n >> m >> k;</span><br><span class="line">    <span class="keyword">while</span> ( m-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> u >> v >> w;</span><br><span class="line">        edges.push_back ( bridge { u, v, w } );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sort ( edges.begin(), edges.end(), cmp );</span><br><span class="line">    dis.Init();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges ){</span><br><span class="line">        <span class="keyword">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dis.Union ( i.u, i.v );</span><br><span class="line">        lb += i.w;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    reverse ( edges.begin(), edges.end() );</span><br><span class="line">    dis.Init();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> i: edges ){</span><br><span class="line">        <span class="keyword">if</span> ( dis.same ( i.u, i.v ) )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dis.Union ( i.u, i.v );</span><br><span class="line">        ub += i.w;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> << ( lb <= k && k <= ub ? <span class="string">"TAK"</span> : <span class="string">"NIE"</span> ) << <span class="string">'\n'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這題目的名字感覺很有（ㄓˋ）趣（ㄓㄤˋ），但是其實算是水題。。。吧&lt;/p&gt;
&lt;h2 id=&quot;題目&quot;&gt;&lt;a href=&quot;#題目&quot; class=&quot;headerlink&quot; title=&quot;題目&quot;&gt;&lt;/a&gt;題目&lt;/h2&gt;&lt;p&gt;題目連結&lt;a href=&quot;https://tioj.ck.tp.edu.tw/problems/1795&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在這&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;給定 $N$ 個點 $M$ 條邊，以及所有邊的邊權重，是否有辦法建構出一顆生成樹之權重總和剛好為$K$&lt;br&gt;另外，任意一條邊的權重只有可能為 $0 or 1$&lt;br&gt;
    
    </summary>
    
    
      <category term="TIOJ" scheme="https://miohitokiri5474.github.io/code/tags/TIOJ/"/>
    
      <category term="math" scheme="https://miohitokiri5474.github.io/code/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>[UVA][00459]GRAPH CONNECTIVITY</title>
    <link href="https://miohitokiri5474.github.io/code/uva00459/"/>
    <id>https://miohitokiri5474.github.io/code/uva00459/</id>
    <published>2017-12-27T10:49:17.000Z</published>
    <updated>2019-10-26T08:47:35.291Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="題目-amp-解法"><a href="#題目-amp-解法" class="headerlink" title="題目 & 解法"></a>題目 & 解法</h2><p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=400" target="_blank" rel="noopener">原題目網址</a></p><p>簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。</p><p>喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）<br><a id="more"></a></p><p>最一開始我是用 set 寫，因為邊有可能重複，又懶得檢查當前 vector 內有沒有重複的節點，想說數字也不會太大($N\le 26$) 所以就直接用 set 了</p><p>後來發現。。。就算重複了也無仿啊 = =</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize ( <span class="meta-string">"O3"</span> )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> loop_opt ( on )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define tools</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPP(i,f,s) for ( int i = f ; i < s ; i++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPALL(i,n) for ( auto &i: n )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM(n,i) memset ( n, i, sizeof n )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">set</span> < <span class="keyword">int</span> > si;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(n) n.clear()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GL(n) getline ( cin, n )</span></span><br><span class="line"></span><br><span class="line">si edge[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> go[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">( <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    go[n] = <span class="literal">true</span>;</span><br><span class="line">    REPALL ( i, edge[n] )</span><br><span class="line">        <span class="keyword">if</span> ( !go[i] )</span><br><span class="line">            dfs ( i );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n, u, v, ans, cnt = <span class="number">0</span>, t;</span><br><span class="line">    <span class="built_in">cin</span> >> t;</span><br><span class="line">    t++;</span><br><span class="line">    <span class="keyword">while</span> ( t-- ){</span><br><span class="line">        GL ( str );</span><br><span class="line">        MEM ( go, <span class="number">0</span> );</span><br><span class="line">        REPP ( i, <span class="number">0</span>, <span class="number">30</span> )</span><br><span class="line">            CLR ( edge[i] );</span><br><span class="line"></span><br><span class="line">        n = str[<span class="number">0</span>] - <span class="string">'A'</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( GL ( str ) ){</span><br><span class="line">            <span class="keyword">if</span> ( EMP ( str ) )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            u = str[<span class="number">0</span>] - <span class="string">'A'</span>, v = str[<span class="number">1</span>] - <span class="string">'A'</span>;</span><br><span class="line">            edge[u].insert ( v );</span><br><span class="line">            edge[v].insert ( u );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        n++;</span><br><span class="line">        REPP ( i, <span class="number">0</span>, n )</span><br><span class="line">            <span class="keyword">if</span> ( !go[i] ){</span><br><span class="line">                ans++;</span><br><span class="line">                dfs ( i );</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( !cnt++ )</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ( cnt++ > <span class="number">2</span> )</span><br><span class="line">            <span class="built_in">cout</span> << <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> << ans << <span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;題目-amp-解法&quot;&gt;&lt;a href=&quot;#題目-amp-解法&quot; class=&quot;headerlink&quot; title=&quot;題目 &amp;amp; 解法&quot;&gt;&lt;/a&gt;題目 &amp;amp; 解法&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=400&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原題目網址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;簡言之就是求一片森林內的樹數量，輸入處理有點麻煩，但是在計算上只要用五行的dfs跑過整片森林就夠了。&lt;/p&gt;
&lt;p&gt;喔，還有可能有重邊，避免麻煩可以用 set 寫，但是常數會比較大（比起 vector）&lt;br&gt;
    
    </summary>
    
    
      <category term="graph" scheme="https://miohitokiri5474.github.io/code/tags/graph/"/>
    
      <category term="dfs" scheme="https://miohitokiri5474.github.io/code/tags/dfs/"/>
    
      <category term="UVa" scheme="https://miohitokiri5474.github.io/code/tags/UVa/"/>
    
  </entry>
  
  <entry>
    <title>[TOJ][365]G.大龍貓</title>
    <link href="https://miohitokiri5474.github.io/code/TOJ-365/"/>
    <id>https://miohitokiri5474.github.io/code/TOJ-365/</id>
    <published>2017-12-26T12:50:14.000Z</published>
    <updated>2020-05-03T02:02:57.549Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>給定一個數列，為一群龍貓的『高度』<br>定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群<br>請實作出支援單點修改及區間查詢的 code<br><a href="http://toj.tfcis.org/oj/pro/365/" target="_blank" rel="noopener">題目原網址</a></p><a id="more"></a><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>先定義一個資料型態 $piece$，裡面包含了一個愉悅龍貓群的資料：開始位置、結束位置、長度（長度可有可無，只是計算上方便）</p><p>接著定義另外一種資料型態，用在線段樹上維護的 $node$<br>$node$ 包含三個 $piece$，分別是這區間內，從區間頭開始的愉悅龍貓群、最長愉悅龍貓群、結束於區間尾的愉悅龍貓群，總共三個</p><p>在 up 兩個 $node$ 的時候（假設兩個 $node$ 分別叫 $l, r $、up 後的 $node$ 叫 $stop$ 好了，相對位置 $l$ 在 $r$ 前面），$l.fro$ 一定是 $stop.fro$ ————因為在這兩個區間裡，最前面的愉悅龍貓群一定是 $l.fro$，同理，$stop.bck$ 一定是 $r.bck$</p><p>那麼，$stop.ma$ 呢？</p><p>$stop.ma$ 有兩種可能性，第一種就是 $l.ma$ 或 $r.ma$ 的其中一個（看誰長度大就誰），另外一種就是，如果 $merge ( l.bck, r.fro )$也是一個愉悅龍貓群的時候，可能會比 $l.ma$ 或 $r.ma$ 還要大</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>其實這題不難，只是 coding 有點複雜，query & update 都與正常的線段樹差不多，只是 up 需要思考一下（？）</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 100005</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">piece</span>{</span></span><br><span class="line">    <span class="keyword">int</span> f, s, sz;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">same</span> <span class="params">( piece a, piece b )</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a.f == b.f && a.s == b.s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">    piece fro, bck, ma;</span><br><span class="line">} seg[maxN << <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> basic[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">up</span> <span class="params">( node L, node R )</span></span>{</span><br><span class="line">    node res;</span><br><span class="line">    res.fro = L.fro, res.bck = R.bck, res.ma = ( L.ma.sz > R.ma.sz ? L.ma : R.ma );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( basic[L.bck.s] + <span class="number">1</span> == basic[R.fro.f] ){</span><br><span class="line">        piece stop = piece { L.bck.f, R.fro.s, R.fro.s - L.bck.f + <span class="number">1</span> };</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( same ( L.fro, L.bck ) )</span><br><span class="line">            res.fro = stop;</span><br><span class="line">        <span class="keyword">if</span> ( same ( R.fro, R.bck ) )</span><br><span class="line">            res.bck = stop;</span><br><span class="line"></span><br><span class="line">        res.ma = ( stop.sz > res.ma.sz ? stop : res.ma );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        seg[n].fro = seg[n].bck = seg[n].ma = piece { l, r, <span class="number">1</span> };</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">int</span> mid = ( l + r ) >> <span class="number">1</span>, leftSon = n << <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">        build ( l, mid, leftSon );</span><br><span class="line">        build ( mid + <span class="number">1</span>, r, rightSon );</span><br><span class="line"></span><br><span class="line">        seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> Index, <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( l == r )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = ( l + r ) >> <span class="number">1</span>, leftSon = n << <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( Index <= mid )</span><br><span class="line">        update ( l, mid, Index, leftSon );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        update ( mid + <span class="number">1</span>, r, Index, rightSon );</span><br><span class="line"></span><br><span class="line">    seg[n] = up ( seg[leftSon], seg[rightSon] );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span> <span class="params">( <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nowL, <span class="keyword">int</span> nowR, <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">if</span> ( l <= nowL && nowR <= r )</span><br><span class="line">        <span class="keyword">return</span> seg[n];</span><br><span class="line">    <span class="keyword">int</span> mid = ( nowL + nowR ) >> <span class="number">1</span>, leftSon = n << <span class="number">1</span>, rightSon = leftSon | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( r <= mid )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, nowL, mid, leftSon );</span><br><span class="line">    <span class="keyword">if</span> ( mid < l )</span><br><span class="line">        <span class="keyword">return</span> query ( l, r, mid + <span class="number">1</span>, nowR, rightSon );</span><br><span class="line">    <span class="keyword">return</span> up ( query ( l, r, nowL, mid, leftSon ), query ( l, r, mid + <span class="number">1</span>, nowR, rightSon ) );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::sync_with_stdio ( <span class="literal">false</span> );</span><br><span class="line">    <span class="built_in">cin</span>.tie ( <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">cout</span>.tie ( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q, l, r, type;</span><br><span class="line">    <span class="built_in">cin</span> >> n;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i <= n ; i++ )</span><br><span class="line">        <span class="built_in">cin</span> >> basic[i];</span><br><span class="line">    build ( <span class="number">1</span>, n, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> >> q;</span><br><span class="line">    <span class="keyword">while</span> ( q-- ){</span><br><span class="line">        <span class="built_in">cin</span> >> type >> l >> r;</span><br><span class="line">        <span class="keyword">if</span> ( type == <span class="number">1</span> ){</span><br><span class="line">            basic[l] = r;</span><br><span class="line">            update ( <span class="number">1</span>, n, l, <span class="number">1</span> );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> << query ( l, r, <span class="number">1</span>, n, <span class="number">1</span> ).ma.sz << <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;題目&quot;&gt;&lt;a href=&quot;#題目&quot; class=&quot;headerlink&quot; title=&quot;題目&quot;&gt;&lt;/a&gt;題目&lt;/h2&gt;&lt;p&gt;給定一個數列，為一群龍貓的『高度』&lt;br&gt;定義只要 $a_i + 1 = a_{i + 1}$ 就稱為愉悅龍貓群&lt;br&gt;請實作出支援單點修改及區間查詢的 code&lt;br&gt;&lt;a href=&quot;http://toj.tfcis.org/oj/pro/365/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;題目原網址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="segment tree" scheme="https://miohitokiri5474.github.io/code/tags/segment-tree/"/>
    
      <category term="TOJ" scheme="https://miohitokiri5474.github.io/code/tags/TOJ/"/>
    
  </entry>
  
  <entry>
    <title>[TIOJ][1940]Nim</title>
    <link href="https://miohitokiri5474.github.io/code/TIOJ-1940/"/>
    <id>https://miohitokiri5474.github.io/code/TIOJ-1940/</id>
    <published>2017-12-26T12:28:32.000Z</published>
    <updated>2019-10-26T08:47:35.288Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h2><p>這題目很哏，真得很哏<br>哏到我都快不想寫了（結果還是用兩節課 AC 了）<br>題目略過，要看原題的<a href="https://tioj.ck.tp.edu.tw/problems/1940" target="_blank" rel="noopener">在這</a><br><a id="more"></a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>我看完題目第一個想法就是 DP</p><p>。。。然後我就 TLE 了（廢話</p><p>因為是要求前 $N$ 項的 $mex$，所以真的會想到 DP<br>但是請看範圍：$1e9$，怎麼看都會 TLE<br>所以只能想一下數學解法了</p><p>$k = 1$ 的解法不用講了，直接輸出數字就好了 = =（好哏</p><p>接著是 $k = 2$，我們觀察一下 $f ( 2, n )$ 的前 $12$ 項：</p><script type="math/tex; mode=display">0, 1, 0, 1, 2, 0, 3, 1, 4, 2, 5, 0, 6</script><p>經過觀察，其實只要當 $n$ 為偶數時，直接輸出 $\frac{n}{2}$ 就好了</p><p>接著再分兩個case : $n$ 為奇術時</p><p>case 餘一：$\frac{n}{4}$ 的整數部分 $\to \lfloor \frac{n}{4} \rfloor$<br>case 餘三：$f ( 2, \frac{n}{2} ) \to$直接對這個函數做遞迴就好</p><p>總結一下，函數大概長這樣</p><script type="math/tex; mode=display">f ( k, n ) =\begin{cases}n, & \text{if $k$ is $1$} \\\begin{cases}\frac{n}{2}, & \text{if $n$ is even} \\\lfloor \frac{n}{4} \rfloor, & \text{if $n = 4\times k + 1 ( k \in \mathbb{R} )$ } \\f ( 2, \frac{n}{2} ), & \text{if $n = 4\times k + 3 ( k \in \mathbb{R} )$ }\end{cases}, & \text{if $k$ is $2$ }\end{cases}</script><p>因為遞迴不需要超過兩次，所以可以視為常數時間內，$O ( 1 )$ 的解法</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// by. MiohitoKiri5474</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string"><bits/stdc++.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxN 10005</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">count</span> <span class="params">( <span class="keyword">int</span> n )</span></span>{</span><br><span class="line">    <span class="keyword">switch</span> ( n ){</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">switch</span> ( n % <span class="number">4</span> ){</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> n / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> n / <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> count ( n / <span class="number">2</span> );</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k, m;</span><br><span class="line">    <span class="built_in">scanf</span> ( <span class="string">"%d%d"</span>, &k, &m );</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"%d\n"</span>, ( k == <span class="number">1</span> ? m : count ( m ) ) );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="後記-2019-03-23-00-29"><a href="#後記-2019-03-23-00-29" class="headerlink" title="後記(2019/03/23 00:29)"></a>後記(2019/03/23 00:29)</h2><p>為了能讓這篇文章的函數好看一些<br>硬生生讓 hexo 支援 mathjax 了<br>然後上面那個精美的函式，我把原始碼放這邊</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f ( k, n ) =</span><br><span class="line">\begin{cases}</span><br><span class="line">n, & \text{if $k$ is $1$} \\</span><br><span class="line">\begin{cases}</span><br><span class="line">\frac{n}{2}, & \text{if $n$ is even} \\</span><br><span class="line">\lfloor \frac{n}{4} \rfloor, & \text{if $n = 4\times k + 1 ( k \in \mathbb{R} )$ } \\</span><br><span class="line">f ( 2, \frac{n}{2} ), & \text{if $n = 4\times k + 3 ( k \in \mathbb{R} )$ }</span><br><span class="line">\end{cases}, & \text{if $k$ is $2$ }</span><br><span class="line">\end{cases}</span><br><span class="line">$$</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;題目&quot;&gt;&lt;a href=&quot;#題目&quot; class=&quot;headerlink&quot; title=&quot;題目&quot;&gt;&lt;/a&gt;題目&lt;/h2&gt;&lt;p&gt;這題目很哏，真得很哏&lt;br&gt;哏到我都快不想寫了（結果還是用兩節課 AC 了）&lt;br&gt;題目略過，要看原題的&lt;a href=&quot;https://tioj.ck.tp.edu.tw/problems/1940&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在這&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="TIOJ" scheme="https://miohitokiri5474.github.io/code/tags/TIOJ/"/>
    
      <category term="math" scheme="https://miohitokiri5474.github.io/code/tags/math/"/>
    
  </entry>
  
</feed>
